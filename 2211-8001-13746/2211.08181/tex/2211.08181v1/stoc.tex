
\documentclass[runningheads]{llncs}

\usepackage{amsmath}
\usepackage{enumitem}
\usepackage{amssymb}
\usepackage{algorithm}
\usepackage{algorithmic}
% \usepackage[hidelinks]{hyperref}
\input{macro}




\sloppy
%%
\begin{document}
%
\title{How hard are verifiable delay functions?}
\titlerunning{$\VDF \subsetneq \CLS$}
\author{Souvik Sur
\orcidID{0000-0003-1109-8595}}
% 
% \authorrunning{XXXX et al.}
% % First names are abbreviated in the running head.
% % If there are more than two authors, 'et al.' is used.
% 
\institute{
\email{souviksur@gmail.com}}
\maketitle              % typeset the header of the contribution

\begin{abstract}
% \hyphenpenalty=2000\exhyphenpenalty=2000\tolerance=500\pretolerance=500%
Verifiable delay functions ($\vdf)$ are functions that take
a specified number of sequential steps to be evaluated but can be verified efficiently. 
In this paper, we introduce a new complexity class that contains all the $\vdf$s. 
We show that this new class $\VDF$ is a subclass of $\CLS$ (continuous local search) and
\textsc{Relaxed-Sink-of-Verifiable-Line} is a complete problem for the class $\VDF$.

\end{abstract}

\keywords{ Verifiable delay functions, Sequentiality, Turing machine, Space-time hierarchy}


\section{Introduction}\label{introduction}
 In 1992, Dwork and Naor introduced the very first notion 
 of $\vdf$ under a different nomenclature ``pricing function" \cite{Dwork1992Price}.
 It is a computationally hard puzzle that needs to be solved
 to send a mail, whereas the solution of the puzzle can be verified efficiently. 
 Later, the concept of verifiable delay functions was
 formalized in~\cite{Dan2018VDF}.

Given the security
parameter $\lambda$ and delay parameter $T$, the prover needs 
to evaluate the $\vdf$ in time $T$. The verifier
verifies the output in $\poly(\lambda,\log T)$-time 
using some proofs produced by the prover. 
A crucial property of $\vdf$s, namely sequentiality,
ensures that the output can not be computed in time much less than $T$ even in the
presence of $\poly(\lambda,T)$-parallelism. 
$\vdf$s have several applications ranging
from non-interactive time-stamping to resource-efficient blockchains, however, are really
rare in practice because of the criteria sequentiality.
In order to design new $\vdf$s we must find problems that offer sequentiality. 
To the best of our knowledge so far, 
all the practical $\vdf$s are based on two inherently sequential algebraic problems 
-- modular exponentiation in groups of unknown
order~\cite{Pietrzak2019Simple,Wesolowski2019Efficient} (fundamentally known as the time-lock puzzle
\cite{Rivest1996Time}) and isogenies over super-singular curves~\cite{Feo2019Isogenie}. 
The security proofs of these $\vdf$s
are essentially polynomial-time reductions from one of these assumptions to the corresponding $\vdf$s.
Thus, from the perspective of the designers, the first hurdle is to find inherently sequential
problems. 
 
The main motivation behind this study has been where should we search for
such inherently sequential problems which are also efficiently verifiable?
In this paper, we show that the class of all $\vdf$s, namely $\VDF$, is a subclass of the
class $\CLS$ (continuous local search). In particular, we prove that
\textsc{Relaxed-Sink-of-Verifiable-Line}~\cite{ChoudhuriNash} is a complete problem for
this new class $\VDF$.




\subsection{Proof Sketch}\label{contributions}
The key challenges with this aim are, 
\begin{description}
\item [$\VDF$-hardness] reducing any arbitrary $\vdf$ into a hard distribution of $\rSVL$
(abbreviation for \textsc{Relaxed-Sink-of-Verifiable-Line}) instances.

\item [$\VDF$-membership] producing $\vdf$s from a family of subexponentially-hard $\rSVL$ instances.
 \end{description}

First, we define $\vdf$ as a language that helps us, in turn, to define the
class $\VDF$ as a special case of interactive proofs. 
The main idea is to detach the Fiat--Shamir transformation from the
traditional definition of $\vdf$ in order to find its hardness 
irrespective of any random oracle.

For the first task, Choudhuri et al. suggest a method in~\cite{ChoudhuriRSW} 
for the $\vdf$s that need proof. We show that it is possible even with the $\vdf$s that have no
proofs. The trick is to define the $\eval$ function of a $\vdf$ in terms of an iterated
sequential function $f$. Use this $f$ in order to design the successor circuit $\S$ of
$\rSVL$ instances. As a much easier case, we also show that the permutation $\vdf$s can be
reduced to such hard $\rSVL$ instances even without using any $f$.

We accomplish the second task by deriving a permutation $\vdf$ from a subexponentially
hard family of $\rSVL$ instances. The derived $\vdf$ is proven to be secure. Although it
suffices for the membership in the class $\VDF$, we also deduce a generic $\vdf$ from
the same $\rSVL$ instances but using an one-way injective function. 

%We show that the class of all $\vdf$s, $\VDF\subsetneq\PSPACE$ in two parts. In order to proof the inclusion 
%$\VDF \subseteq \PSPACE$ first we model $\vdf$s as a special case of interactive proofs,
%thus $\VDF \subseteq \IP$. Therefore $\VDF \subseteq \PSPACE$ by the virtue of the
%seminal result by Shamir $\IP = \PSPACE$ \cite{ShamirIP}.
%We show the opposite exclusion $\PSPACE \nsubseteq \VDF$ by two incorrect attempts to
%build $\vdf$s from two different $\PSPACE$-complete languages. The most important
%finding is that all problems in $\PSPACE$ do not turn out to be subexponentially
%sequential and computationally sound, at the same time.
%
%We consider \textsc{True-Quantified-Boolean-Formula} ($\TQBF$ in short) and \textsc{SPACEHALT} as 
%these $\PSPACE$-complete problems. 
%% We derive a $\vdf$ from a $\PSPACE$-complete language $\HALT$ and prove
%% that $\HALT$ is polynomial time reducible to the derived $\vdf$. But, we also give an
%% efficient adversary that breaks the soundness of the derived $\vdf$.
%The language $\TQBF$ is the set of fully quantified Boolean formula that are true. The
%sumcheck protocol for $\TQBF$ is known to be sound against even computationally
%unbounded provers. We show that despite its soundness sumcheck protocol fails to achieve
%subexponential sequentiality which is necessary for any $\vdf$. 
%
%The language $\HALT$ is the set of all the tuples $(M,x,1^S)$ such that the deterministic 
%Turing machine $M$ halts on input $x$ in space $S$. 
%It is a $\PSPACE$-complete language as any language $\L \in \PSPACE$ can be reduced
%to $\HALT$ in polynomial-time. For any $x\in \L$, the reduction $\L \le_p \HALT$ is nothing but
%$f(x) = (M,x,1^{\O(|x|)})$. Moreover, $\HALT$ is an inherently sequential language in a
%sense that $\HALT$ can not be parallelized. If it could be then all the languages in 
%$\PSPACE$ could be parallelized by the definition of completeness of a language for a class.
%But we already know the existence of inherently sequential languages
%(e.g., time-lock puzzle) that can be recognized in polynomial space. 
%
%We prove that $\vdf$ derived from $\HALT$ may be subexponentially sequential but not
%computationally sound.

% Given the security parameter $\lambda$ and the time parameter $T$, $\vdf$s consist of three algorithms, 
% \begin{enumerate}
%  \item $\setup$ generates the public parameters $\pp$. 
%  \item $\eval$ sequentially maps an input statement $x$ to an output $\phi$ in time $T$. 
%  Also it gives a proof $\pi$, if required, using randomness. 
%  \item $\verify$ checks if $\phi$ is the correct mapping of $x$ using the proof $\pi$, if any.
% 
% \end{enumerate}

% The fundamental idea of deriving $\vdf$s from $\HALT$ 
% is to choose a Turing machine $M$ and a random oracle $\mathsf{H}$ 
% as the public parameter $\pp$. 
% Then $\eval$ computes the state $q_T$ of $M$ after $T$ number of 
% transitions starting from its initial state. The proof $\pi$ is the state $q_{T-t}$ of $M$ after $T-t$ transitions 
% from the initial state. Here $t=\mathsf{H}(x \| y)$ such that $t\le \lambda$. 
% The $\verify$ checks if $M$ reaches at $q_T$ in time $t$ starting from $q_{T-t}$.
% We show that the derived $\vdf$ is correct, sound and sequential.
% 
% The reduction from $\HALT$ to this derived $\vdf$ exploits two fundamental observations
% on Turing machines. 
% \begin{itemize}
% \item the running time $T$ of $M$ having $S$ space is bounded by $|Q|S2^S$.
% \item $M$ continues to stay in the halting states (either accepting or rejecting) once
% it reaches there.
% \end{itemize}
% Thus, in order to reduce $\HALT$ into this $\vdf$ we just need to set $T \ge |Q|S2^S$
% without the precise knowledge of when $M$ halts on $x$.   
% \subsection{Organization of the Paper}
%  This paper is organized as follows.
% Section~\ref{literature} discusses a few existing schemes known to be  
% VDF. In Section~\ref{preliminaries}, we present a succinct review of
% VDFs and cellular automata, and prove three important theorems to establish 
% the randomness of NHCAs.
% % We propose our VDF scheme in Section~\ref{NVDF}.
% % Section~\ref{properties} establishes the essential properties 
% % correctness, sequentiality and soundness of the VDF.
% Finally, Section~\ref{conclusion} concludes the paper
% after highlighting an open problem in this context.

% Finally, we give an adversary that breaks the soundness of the derived $\vdf$. The most
% crucial observation in this context is that the verifier never checks if the state
% $q_{T-t}$ has been computed honestly but can be at most $\lambda$ steps behind. 
% So, an adversary may just start with an arbitrary state and compute the $\lambda$-th
% state ahead of it. Meanwhile, (s)he remembers all the states and the processed input symbol
% in this journey. Receiving upon the off-set $t$, (s)he simply provides the $(\lambda-t)$
% state in this remembered sequence as the proof. Clearly, the verifier will always be
% convinced.
\section{Related Work}\label{literature}
In this section, first we describe some well-known schemes that are qualified as $\vdf$s.

 
\subsubsection{Squaring over $\Z_p$} The pricing function by Dwork--Naor scheme~\cite{Dwork1992Price} asks a prover,
given a prime $p=3\; (\mathbf{mod}\; 4)$ and a quadratic residue $x$ modulo $p$,
to find a $y$ such that $y^2= x\;(\mathbf{mod}\;p)$. The prover
has no other choice other than using the identity $y= x^{\frac{(p+1)}{4}}\;(\mathbf{mod}\;p)$, 
but the verifier verifies the correctness using $y^2= x\;(\mathbf{mod}\;p)$. 
The drawback of this design is that the delay parameter $T=\O(\log p)$. Thus the difference between the evaluation 
and the verification may be made up by a prover with $\poly(T)$-processors by parallelizing the field multiplications.
Moreover, it is difficult to generate the public parameters of this $\vdf$ for sufficiently large $T$
as $\setup$ needs to sample a prime $p > 2^{\Omega(T)}$. 
% Further the massive parallelism with the prover 
% violates its sequentiality. In \cite{Lenstra2017Sloth}, Lenstra and Wesolowski circumvent 
% this problem by the chaining of several easier instances generated by small $p$'s having some permutation
% known as sloth. As sloth lacks efficient verification it is a proof-of-sequential-work only. 

\subsubsection{Injective Rational Maps}
In 2018, Dan et al.~\cite{Dan2018VDF} propose a $\vdf$ based on injective rational
maps of degree $T$, where the fastest possible inversion is to compute the polynomial
GCD of degree-$T$ polynomials. They conjecture that 
it achieves $(T^2,o(T))$ sequentiality using permutation polynomials as the candidate map.
However, it is a weak $\vdf$ as it needs $\mathcal{O}(T)$ processors to evaluate the output in time $T$.

\subsubsection{RSW Puzzle}\label{vdf}
Rivest, Shamir, and Wagner~\cite{Rivest1996Time} introduced the time-lock puzzle stating
that it needs at least $T$ number of sequential squaring to compute 
$y=g^{2^T}\mod{\Delta}$ when the factorization of $\Delta$ is unknown.
Therefore they proposed this encryption that can be decrypted 
only sequentially. Starting with $\Delta=pq$ such that $p,q$ are large primes,
the key $y$ is enumerated as $y=g^{2^T}\mod{\Delta}$. Then the verifier,
uses the value of $\phi(\Delta)$ to reduce the exponent to
$e=2^T\mod{\phi(\Delta)}$ and finds out $y= g^e\mod{\Delta}$.
On the contrary, without the knowledge of $\phi(\Delta)$, the only option available to the prover
is to raise $g$ to the power $2^T$ sequentially. 
As the verification stands upon a secret, the knowledge of $\phi(\Delta)$, 
it is not a $\vdf$ as verification should depend only on public parameters.

Pietrzak~\cite{Pietrzak2019Simple} and Wesolowski~\cite{Wesolowski2019Efficient} circumvent 
this issue independently. We describe both the $\vdf$s in the generic group $\mathbb{G}$
as these schemes can be instantiated over two different groups --
 the RSA group $\multgroup{\Delta}$ and the class group of imaginary quadratic
number field. Both the protocols use a common random oracle
$\RO_\mathbb{G}:\{0,1\}^*\rightarrow \mathbb{G}$ to map the input statement $x$ to the
generic group $\mathbb{G}$. We assume $g:=\RO_\mathbb{G}(x)$.

\begin{description}

\item [Pietrzak's $\vdf$]
It exploits the identity $z^ry=(g^rz)^{2^{T/2}}$
where $y=g^{2^T}$, $z=g^{2^{T/2}}$ and $r \in \Z_{2^\lambda}$ is chosen at random.
So the prover is asked to compute the output $y=g^{2^T}$ and the proof $\pi=\{u_1, u_2, \ldots, u_{\log{T}}\}$ such that 
$u_{i+1}=u_i^{r_i+{2^{T/2^i}}}$, $r_i = \RO(u_i, T/2^{i-1},v_i,u_i^{2^{T/2^{i-1}}})$ and
$v_i=u_i^{r_i\cdot{2^{T/2^i}}+2^T}$. The verifier computes the $v_i=u_i^{r_i\cdot{2^{T/2^i}}+2^T}$
and checks if $v_{\log{T}}=u_{\log T}^2$.
So the verifier performs $\sum_{1}^{\log{T}}\log{r_i}$ number of sequential
squaring. As $\RO$ samples $r_i$ uniformly from its range $\Z_{2^\lambda}$, we have
$\sum_{1}^{\log{T}}\log{r_i}=\O(\lambda \log{T}) $.
The effort to generate the proof $\pi$ is in
$\O(\sqrt{T} \log{T})$.





\item [Wesolowski's $\vdf$]
It asks the prover to compute an output $y=g^{2^T}$ and
a proof $\pi=g^{\lfloor2^T/\ell\rfloor}$, where 
$\ell=\RO_{\texttt{prime}}(\texttt{bin}(g)|||\texttt{bin}(y))$ is a $2\lambda$-bit prime. 
It needs $\O(T/\log {T})$ time to do the same.
The verifier checks if $y=\pi^\ell \cdot g^{(2^T \mod{\ell})}$. 
Hence the verification needs at most $2\log \ell=4 \lambda$ squaring.




\end{description}

\subsubsection{Isogenies over Super-Singular Curves}
Feo et al.~\cite{Feo2019Isogenie} presents two $\vdf$s based on isogenies over super-singular
elliptic curves. They start with five groups $\langle G_1,G_2,G_3,G_4,G_5\rangle$
of prime order $T$ with two non-degenerate bilinear pairing maps
$e_{12}: G_1 \times G_2 \rightarrow G_5$ and $e_{34}: G_3 \times G_4 \rightarrow G_5$.
Also there are two group isomorphisms
$\phi: G_1 \rightarrow G_3$ and $\overline{\phi}: G_4 \rightarrow G_2$. 
Given all the above descriptions as the public parameters along with a generator $P\in G_1$,
the prover needs to find $\overline{\phi}(Q)$, where $Q\in G_4$, using $T$ sequential steps.
The verifier checks if $e_{12}(P,\overline{\phi}(Q))=e_{34}(\phi(P),Q)$ in
$\poly(\log{T})$ time. It runs on super-singular curves over $\mathbb{F}_p$ and $\mathbb{F}_{p^2}$ 
as two candidate groups. 
While being inherently non-interactive, there are two drawbacks as mentioned by the authors themselves.
First, it requires a trusted setup, and second, the 
setup phase may turn out to be slower than the evaluation.


Mahmoody et al. recently rule out the possibility of having a $\vdf$ out 
of random oracles only~\cite{Mahmoody2020RO}.
 \begin{table*}[h]
 \caption{Comparison among the existing VDFs. $T$ is the targeted time bound, $\lambda$ is 
 the security parameter, $\Delta$ is the number of processors. All the quantities may be
 subjected to $\mathcal{O}$-notation, if needed.}
 \label{tab : VDF}
  \centering
  \begin{tabular}{|l@{\quad}|r@{\quad}|r@{\quad}|r@{\quad}|r@{\quad}|r@{\quad}|r@{\quad}}
     \hline
         VDF & \textsf{Eval} & \textsf{Eval} &  \textsf{Verify} & \textsf{Setup} & Proof   \\
 (by authors)&  Sequential   & Parallel      &                  &                &  size   \\
     \hline
     
     Dwork and Naor~\cite{Dwork1992Price}       & $T$   & $T^{2/3}$  &  $T^{2/3}$  & $T$ & $\textendash$ \\ 
     [0.3 em] \hline 
         
     Dan et al.~\cite{Dan2018VDF}         & $T^2$ & $>T-o(T)$  &  $\log{T}$  & $\log{T}$ & $\textendash$  \\
     [0.3 em] \hline
     
     Wesolowski~\cite{Wesolowski2019Efficient} & $(1+\frac{2}{\log{T}})T$   & $(1+\frac{2}{\Delta\log{T}})T$  &  $\lambda^{4}$  & $\lambda^{3}$ & $\lambda^{3}$ \\
     [0.3 em] \hline
     
     Pietrzak~\cite{Pietrzak2019Simple}        & $(1+\frac{2}{\sqrt{T}})T$   & $(1+\frac{2}{\Delta\sqrt{T}})T$  &  $\log{T}$  & $\lambda^{3}$ & $\log{T}$ \\
     [0.3 em] \hline 
     
     Feo et al.~\cite{Feo2019Isogenie}         & $T$   & $T$  &  $\lambda^4$  & $T\log{\lambda}$ & \textendash \\
     [0.3 em] \hline 
     
  \end{tabular}
 \end{table*}


\subsubsection{$\PPAD$-hardness of Cryptographic Protocols}
Now, we briefly mention few works in order to show the significance of the class $\PPAD$ 
in the context of cryptography.

Abbot, Kane and Valiant were the first to show that
virtual black-box obfuscation \cite{Valiant} can be used to generate hard instances of
\textsc{End-of-Line} ($\EOL$). Since, virtual black-box obfuscation is known only for
certain functions, Bitansky et al. consider indistinguishability obfuscation ($i\O$) to
show that quasi-polynomially hard $i\O$ and subexponentially hard one-way function
reduce to $\EOL$ via a new problem \textsc{Sink-of-Verifiable-Line}~\cite{BitanskyNash}. 
Building up further, Garg et al. derived
$\PPAD$-hardness from polynomially-hard $i\O$ or compact public-key functional encryption 
and one-way permutation~\cite{Garg16iO}.  
Relying on sub-exponentially hard injective one-way functions, Komargodski and Segev show that
quasi-polynomially hard private-key functional encryption implies $\PPAD$-hardness.

Hub\'{a}\v{c}ek and Yogev introduced a new total
search problem \textsc{End-of-Metered-Line} ($\EOML$) proving that it is hard to search local optima 
even over continuous domains. They also show that $\EOML$ belongs to a subclass, namely
continuous local search ($\CLS$), of $\PPAD$.

A striking result by Choudhuri et al. shows that relative to a random oracle (used in
Fiat--Shamir transformation), hardness in the class $\#\mathbf{P}$ implies
hardness in $\CLS$~\cite{ChoudhuriNash}. In particular, 
they derive a new verifiable procedure applying the
Fiat--Shamir transformation on the sumcheck protocol for \textsc{\#SAT} and reduce it  
to a new problem \textsc{Relaxed-Sink-of-Verifiable-Line} ($\rSVL$) in $\CLS$. 

A similar work by the same group of authors inspires our work~\cite{ChoudhuriRSW}. 
It reduces the problem of finding $g^{2^T}\mod{N}$ relative 
to a random oracle (used in Fiat--Shamir transformation) to $\rSVL$.
A typical property in Pietrzak's $\vdf$~\cite{Pietrzak2019Simple} 
called "proof-merging" is at the core of this reduction. 
Suppose, $\pi^T_{g \rightarrow y}=\{u_1, \ldots, u_{\log T}\}$ denotes 
the proof for $h=g^{2^T}$ in Pietrzak's $\vdf$. The property proof-merging is the
observation that given two proof $\pi^T_{g \rightarrow h}$ 
and $\pi^T_{h \rightarrow y}$, finding the proof $\pi^{2T}_{g \rightarrow y}$ reduces to
finding a proof $\pi^T_{u \rightarrow v}$ such that,
$u:=g^r \cdot h$,
$v:=h^r \cdot y$ and 
$r:=\RO(u_1,g,y,2T)$.
It works because the element $h$ must be present in the proof 
$\pi^{2T}_{g \rightarrow y}=\{u_1, \ldots,u_{\log T+1}\}$ 
as $u_1$. Therefore, the merged proof $\pi^T_{u \rightarrow
v}=\{u'_1,\ldots, u'_{\log T}\}$ is equivalent to the proof  
$\pi^{2T}_{g \rightarrow y}=\{u_1,u'_1, \ldots,u'_{\log T}\}$. 



\section{Preliminaries}\label{preliminaries}

We start with the notations.

\subsection{Notations}
We denote the security parameter with $\lambda\in\mathbb{Z}^+$.
The term $\poly(\lambda)$ refers to some polynomial of $\lambda$, and
$\negl(\lambda)$ represents some function $\lambda^{-\omega(1)}$.
If any randomized algorithm $\mathcal{A}$ outputs $y$ on an input $x$, 
we write $y\xleftarrow{R}\mathcal{A}(x)$. By $x\xleftarrow{\$}\mathcal{X}$,
we mean that $x$ is sampled uniformly at random from $\mathcal{X}$. For a string $x$, 
$|x|$ denotes the bit-length of $x$, whereas for any set $\mathcal{X}$, $|\mathcal{X}|$ denotes 
the cardinality of the set $\mathcal{X}$. If $x$ is a string then $x[i \ldots j]$ denotes the substring 
starting from the literal $x[i]$ ending at the literal $x[j]$. 
% We denote the time complexity of any algorithm $\mathcal{A}$ by $T$, and 
We consider an algorithm $\adv$ as efficient if it runs in 
probabilistic polynomial time (PPT). 
% We say $\L \le _p \L'$ if the language $\L$ is polynomial time reducible to the language $\L'$.
 
\subsection{Verifiable Delay Function}\label{VDF}
We borrow this formalization from~\cite{Dan2018VDF}.


\begin{definition}\normalfont{ \bf (Verifiable Delay Function).}
A verifiable delay function from domain $\X$ to range $\Y$ is a tuple of algorithms 
$(\setup, \eval, \verify)$ defined as follows,
\begin{itemize}[label=\textbullet]
\item \textsf{Setup}$(1^\lambda, T) \rightarrow \pp$
 is a randomized algorithm that takes as input a security parameter $\lambda$ 
 and a targeted time bound $T$, and produces the public parameters 
 $\pp$. We require \textsf{Setup} to run in $\poly(\lambda,\log{T})$ time.
%  For meaningful security, the target time $T$ is restricted to be sub-exponentially sized in $\lambda$.
 
 \item \textsf{Eval}$(\pp, x) \rightarrow (y, \pi)$ takes an input 
 $x\in\mathcal{X}$, and produces an output $y\in\mathcal{Y}$ and a (possibly empty) 
 proof $\pi$. \textsf{Eval} may use random bits to generate the proof 
 $\pi$. For all $\pp$ generated 
 by $\textsf{Setup}(\lambda, T)$ and all $x\in\mathcal{X}$, the algorithm 
 \textsf{Eval}$(\pp, x)$ must run in time $T$.
 % with  $\poly(\lambda,\log{T})$ processors.
 
 \item \textsf{Verify}$(\pp, x, y, \pi) \rightarrow \{0, 1\}$ is a 
 deterministic algorithm that takes an input $x\in\mathcal{X}$, an output $y\in\mathcal{Y}$,
 and a proof $\pi$ (if any), and either accepts ($1)$ or rejects ($0)$. 
 The algorithm must run in $\poly(\lambda,\log{T})$ time.
\end{itemize}
\end{definition}


 
Before we proceed to the security of $\vdf$s we need the precise model of parallel
adversaries \cite{Dan2018VDF}. 
\begin{definition}\normalfont{(\bf Parallel Adversary)}\label{paradv} 
A parallel adversary $\adv=(\adv_0,\adv_1)$ is a pair of non-uniform 
randomized algorithms $\adv_0$ with total running time $\poly(\lambda,T)$, 
and $\adv_1$ which runs in parallel time $\sigma(T)<T-o(T)$ on at 
most $\poly(\lambda,T)$ number of processors.
\end{definition}
Here, $\adv_0$ is a preprocessing algorithm that precomputes some
$\st$ based only on the public parameters, and $\adv_1$ exploits
this additional knowledge to solve in parallel running time $\sigma$ on 
$\poly(\lambda,T)$ processors.



The three desirable properties of a $\vdf$ are now introduced.

\begin{definition}\normalfont{(\bf Correctness)}\label{def: Correctness} 
A $\vdf$ is correct with some error probability $\varepsilon$,
if for all $\lambda, T$, parameters $\pp$, 
and $x\in\mathcal{X}$, we have
\[
\Pr\left[
\begin{array}{l}
\textsf{Verify}(\pp,x,y,\pi)=1
\end{array}
\Biggm| \begin{array}{l}
\pp\leftarrow\textsf{Setup}(1^\lambda,T)\\
x\xleftarrow{\$} \mathcal{X}\\
(y,\pi)\leftarrow\textsf{Eval}(\pp,x)
\end{array}
\right]
\ge 1 - \negl(\lambda).
\]
\end{definition}

\begin{definition}\normalfont{\bf(Soundness)}\label{def: Soundness} 
A $\vdf$ is computationally sound if for all non-uniform algorithms $\adv$ 
that run in time $\mbox{poly}(T,\lambda)$,
we have
\[
\Pr\left[
\begin{array}{l}
y\ne\textsf{Eval}(\pp,x)\\
\textsf{Verify}(\pp,x,y,\pi)=1
\end{array}
\Biggm| \begin{array}{l}
\pp\leftarrow\textsf{Setup}(1^\lambda,T)\\
(x,y,\pi)\leftarrow\mathcal{A}(1^\lambda,T,\pp)
\end{array}
\right] \le \negl(\lambda).
\]
\end{definition}

Further, a $\vdf$ is called statistically sound when all adversaries 
(even computationally unbounded) have at most $\negl(\lambda)$ advantage.
Even further, it is called perfectly sound if we want this probability to be $0$ 
against all adversaries. Hence, perfect soundness implies statistical soundness which
implies computational soundness but not the reverses. 

\begin{definition}\normalfont{\bf (Sequentiality)}\label{def: Sequentiality}
A $\vdf$ is $(\Delta,\sigma)$-sequential if there exists no
pair of randomized algorithms $\adv_0$ with total running time
$\mbox{poly}(T,\lambda)$ and $\adv_1$ which runs
in parallel time $\sigma$ on at most $\Delta$ processors, such that
\[
\Pr\left[
\begin{array}{l}
y=\textsf{Eval}(\pp,x)
\end{array}
\Biggm| \begin{array}{l}
\pp\leftarrow\textsf{Setup}(1^\lambda,T)\\
\st\leftarrow\mathcal{A}_0(1^\lambda,T,\pp)\\
x\xleftarrow{\$}\mathcal{X}\\
y\leftarrow\mathcal{A}_1(\st,x)
\end{array}
\right]
\le \negl(\lambda).
\]
\end{definition}

% \begin{definition}{\normalfont{\textbf{(Strongly Decodable VDF}.)}} 
% A \textsf{V=(Setup, Eval, Dec)} is a strongly decodable VDF if 
% the decoder \textsf{Dec} has these following properties,
% \begin{enumerate}
%  \item \textsf{Dec} runs in $poly(\lambda, \log T)$-time and requires no proof (i.e., $\pi=\perp)$.
%  \item $\forall x\in\mathcal{X}, \text{ if } 
%  y=\textsf{Eval}(\pp,x)\text{ then }x=\textsf{Dec}(\pp,y)$.
%  \item $\forall y, y'\in\mathcal{Y},\text{ if }y\ne 
%  y'$\text{ then }$\textsf{Dec}(\pp,y)\ne\textsf{Dec}(\pp,y')$.
% \end{enumerate}
% \end{definition}
% Strongly decodable VDFs are perfectly sound by the definition, however, the reverse is not true in general.

\begin{definition}{\normalfont \textbf{(Permutation $\vdf$).}}
Permutation $\vdf$s are the $\vdf$s with $\X=\Y$
where $\X$ and $\Y$ denote the input and output domains respectively.
\end{definition}

We reiterate an important remark from~\cite{Dan2018VDF} but as a lemma.
\begin{lemma}{\normalfont ($T \in \mathsf{SUBEXP(\lambda)}).$}\label{subexp}
If $T > 2^{o(\lambda)}$ then there exists an adversary that breaks the sequentiality of
the $\vdf$ with non-negligible advantage.
\end{lemma}
\begin{proof}
$\adv$ observes that the algorithm $\verify$ is efficient.
So given a statement $x \in \X$,  $\adv$ chooses an arbitrary $y \in \Y$ as the output
without running $\eval(x,\pp,T)$. Now, $\adv$ finds the proof $\pi$ by a brute-force
search in the entire solution space with its $\poly(T)$ number of processors.
In each of its processors, $\adv$ checks if $\verify(x,\pp,T,y,\pi_i)=1$ with different
$\pi_i$. The advantage of $\adv$ is $\poly(T)/2^{\Omega(\lambda)} \ge \negl(\lambda)$ as
$T > 2^{o(\lambda)}$. 

\end{proof}
So we need $T \le 2^{o(\lambda)}$ to restrict the advantage of $\adv$ 
upto $2^{o(\lambda)}/2^{\Omega(\lambda)}=2^{-\Omega(\lambda)}$.

\subsection{Search Problems}
In this section, we review the basics of search problems
from~\cite{ChoudhuriNash,BitanskyNash,PPAD94,TFNP91}. 

Suppose, $R \subseteq \{0,1\}^* \times \{0,1\}^*$ 
is a relation such that, for all $(x,y) \in R$,
\begin{enumerate}[label=\roman*]
\item $R$ is polynomially-balanced i.e., $|y|\le \poly(|x|)$. 
\item $R$ is efficiently-recognizable. 
\end{enumerate}

A search problem $(\L,R)$ is defined by a set of instances $\L \subseteq \{0,1\}^*$ and
a relation $R$. In particular, given a $x \in \L$, the search problem $(\L,R)$ is to
find an $y$ if there exists an $(x,y)\in R$, otherwise say "no". The set of all search problems 
is called as functional-$\NP$ or $\FNP$. For example, the search version 
of 3-$\mathsf{SAT}$ belongs to $\FNP$. 

The relation $R$ is called total if, for every $x$, there is always a $y$ such that
$(x,y)\in R$. A search problem $(\L,R)$ is called total when $R$ is total. It means 
total search problems always have solutions e.g., $\mathsf{FACTORING}$. The set 
of all total search problems is called as total-$\FNP$ or $\TFNP$.




A notable subclass of $\TFNP$ is called as $\PPAD$ which stands for "polynomial 
parity argument in a directed graph". It is defined as the set of all problems that are
polynomial-time reducible in \textsc{End-of-Line} problem~\cite{PPAD94}.

\begin{definition}{\normalfont \textbf{(\textsc{End-of-Line} problem $\EOL$).}} 
An \textsc{End-of-Line} instance $(\S,\P)$ consists of a pair of circuits
$\S,\P: \{0,1\}^n \rightarrow\{0,1\}^n$ such that $\P(0^n)=0^n$ and
$\S(0^n) \ne 0^n$. The goal is to find a vertex $v\in\{0,1\}^n$ 
such that $\P(\S(v))\ne v$ or $\S(P(v))\ne v \ne 0^n$.
\end{definition}

Thus, $\EOL$ deals with a directed graph over the vertices $\{0,1\}^n$ and the edges of
the form $(u,v)$ if and only if $\S(u)=v$ and $\P(v)=u$. Here, $\S$ and $\P$
represent the successor and predecessor functions for this directed graph. The in-degree
and out-degree of every vertex in this graph is at most one except that in-degree of
$0^n$ is 0. the goal is to find a vertex $v$, other than $0^n$, which is either 
a source (in-degree is 0) or a sink (out-degree is 0). Such a vertex always exists by
the parity argument for a graph - the number of odd degree vertex in a graph is even
Therefore, $\EOL$ is in $\TFNP$ and by definition in $\PPAD$.

A subclass of $\PPAD$, namely continuous local search $\CLS$ is 
the class of problems that are polynomial-time reducible to the problem
\textsc{Continuous-Local-Optimum}~\cite{DaskalakisCLS}.
An interesting but not known to be complete problem in 
$\CLS$ is \textsc{End-of-Metered-Line}~\cite{HubacekCLS}.  

\begin{definition}{\normalfont \textbf{(\textsc{End-of-Metered-Line} problem $\EOML$).}} 
An \textsc{End-of-Metered-Line} instance $(\S,\P,\M)$ consists of circuits
$\S,\P: \{0,1\}^n \rightarrow\{0,1\}^n$ and $\M:\{0,1\}^n \rightarrow \{0,\ldots,2^n-1\}$
such that $\P(0^n)=0^n\ne \S(0^n)$ and
$\M(0^n) =1$. The goal is to find a vertex $v\in\{0,1\}^n$ 
satisfying one of the following,

\begin{enumerate}[label=\roman*]
\item \textbf{End of Line:} either $\P(\S(v))\ne v$ or $\S(\P(v))\ne v \ne 0^n$.
\item \textbf{False source:} $v\ne 0^n$ and $\M(v)=1$.
\item \textbf{Miscount:} either $\M(v)>0 $ and $\M(\S(v))-\M(v) \ne 1$ or $\M(v) >1$
and $\M(v)-\M(\P(v))\ne 1$.
\end{enumerate}
\end{definition}

Clearly, $\EOML$ reduces to $\EOL$, but the "odometer" circuit $\M$ makes $\EOML$
easier than $\EOL$. The circuit $\M$ outputs the number of steps required to reach $v$
from the source. Observe that any vertex, for which $\M$ contradicts its correct
behaviour, solves the problem. Thus, there exists a solution for every $\EOML$ instance.
Hence, $\EOML \in \TFNP$.

The problem \textsc{Sink-of-Verifiable-Line}, introduced by Valiant et. al and further, 
developed in~\cite{BitanskyNash}, is defined as follows,


\begin{definition}{\normalfont \textbf{(\textsc{Sink-of-Verifiable-Line} problem $\SVL$).}} 
An \textsc{Sink-of-Verifiable-Line} instance $(\S,\V,T,v_0)$ consists of 
$T\in\{1,\ldots,2^n\}$, $v_0 \in \{0,1\}^n$, and two circuits
$\S: \{0,1\}^n \rightarrow\{0,1\}^n$ and $\V:\{0,1\}^n \times
\{1,\ldots,T\}\rightarrow \{0,1\}$ with the guarantee
that for every $v \in \{0,1\}^n$ and
$i\in\{1,\ldots,T\}$, it holds that $\V(v,i)=1$ if and only if $v=\S^i(v_0)$. 
The goal is to find a vertex $v\in\{0,1\}^n$ such that $\V(v,T)=1$ (i.e., the sink). 
\end{definition}
 
Similar to, $\EOL$ and $\EOML$ the circuit $\S$ implements a successor function for the
directed graph. However, in $\SVL$ the graph is a single line with the source $v_0$. The
circuit $\V$ allows to test if a vertex $v$ is at a distance of $i$ on the line from
$v_0$. The goal is to find the vertex at distance $T$ from $v_0$.
Given an arbitrary instance $(\S,\V,T,v_0)$, 
we do not know how to efficiently check if $\V$ behaves correctly. 
Therefore, every instance of $\SVL$ may not be valid and may not have solutions. 
So $\SVL \notin \TFNP$. 

Although, in \cite{BitanskyNash}, $\SVL$ was defined with the fixed source $v_0=0^n$, 
it is equivalent to $\SVL$ with arbitrary source. The instance $(\S,\V,T,0^n)$ reduces
to the instance $(\S,\V,T,v_0)$ considering $v_0=0^n$. On the other hand, the instance 
$(\S,\V,T,v_0)$ reduces to $(\S',\V',T,0^n)$ when we define $\S'(v):=\S(v \oplus v_0)$ and 
$\V'(v,i):=\V(v \oplus v_0,i)$. Most importantly, this reduction works for any search
problem in the context of $\TFNP$ that considers fixed vertex in its input (like $\EOL$ with $0^n$).

In order to solve the issue $\SVL \notin \TFNP$, Choudhuri et al. introduced a relaxed
version of it, namely \textsc{Relaxed-Sink-of-Verifiable-Line}. In this version, the
circuit $\V$ allows a few vertices off the main line starting at $v_0$. So, these
off-the line vertices also act as solutions. Hence, 

\begin{definition}{\normalfont \textbf{(\textsc{Relaxed-Sink-of-Verifiable-Line} problem $\rSVL$).}} 
An \textsc{Relaxed-Sink-of-Verifiable-Line} instance $(\S,\V,T,v_0)$ consists of 
$T\in\{1,\ldots,2^n\}$, $v_0 \in \{0,1\}^n$, and two circuits
$\S: \{0,1\}^n \rightarrow\{0,1\}^n$ and $\V:\{0,1\}^n \times
\{1,\ldots,T\}\rightarrow \{0,1\}$ with the guarantee
that for every $v \in \{0,1\}^n$ and
$i\in\{1,\ldots,T\}$, it holds that $\V(v,i)=1$ if and only if $v=\S^i(v_0)$. 
The goal is to find:
\begin{enumerate} 
\item \textbf{The sink:} a vertex $v \in \{0,1\}^n$ such that $\V(v,T)=1$ or
\item \textbf{False positive:} a pair $(v,i) \in \{0,1\}^n \times \{1,\ldots, 2^n\}$ 
such that $v \ne \S^i(v_0)$
and $\V(v,i)=1$. 
\end{enumerate} 
\end{definition}

Lemma. 10 in cf.~\cite{ChoudhuriNash} shows that \textsc{Relaxed-Sink-of-Verifiable-Line}
is many-one reducible to \textsc{End-of-Metered-Line}. Since, $\EOML \in \CLS$, 
thus $\rSVL \in \CLS \subset \PPAD$. The off the line vertices guarantee the existence of the
solutions for any arbitrary instances.

% \subsection{The Complexity Classes}
% 
% 
% % \subsection{Turing Machine}\label{PTM}
% We start with the definition of Turing machine in order to discuss complexity classes.
% We consider Turing machines with a read-only input tape and read-write work tape. 
% \begin{definition}{\normalfont \textbf{(Turing machine).}}\label{TM}
% A Turing Machine is a tuple $\mathsf{TM} = \langle Q, \Gamma, q_0, F, \delta \rangle$ with the following meaning,
% \begin{enumerate}
%  \item $Q$ is the finite and nonempty set of states.
%  \item $\Gamma$ is the finite and non-empty set of tape alphabet symbols including the input alphabet $\Sigma$.
%  \item $q_0\in Q$ is the initial state.
%  \item $F \subseteq Q$ is the set of halting states.
%  \item $\delta : \{Q\setminus F\} \times \Gamma \rightarrow Q \times \Gamma \times D$ is the transition functions 
%  where $D=\{-1,0,+1\}$ is the set of directions along the tape.
% % \begin{enumerate}
% %  \item $\delta : Q   \times \{\vdash\} \rightarrow Q \times \{\vdash\}\times \{+1\}$.
% %  \item $\delta : F^+ \times \Gamma\rightarrow F^+ \times \Gamma \times D$
% %  \item $\delta : F^- \times \Gamma\rightarrow F^- \times \Gamma \times D$
% % \end{enumerate}
% \end{enumerate}
% \end{definition}
% 
% Throughout the paper we assume that the initial state $q_0$, one of the final states $q_F$ and the tape alphabet 
% $\Gamma=\{0,1, \vdash\}$ are implicit to the description of a $\TM$. Here $\Sigma=\{0,1\}$ and 
% $\vdash$ marks the left-end of the tape. Thus $ \langle Q,F,\delta \rangle$ suffices to describe any $\TM$.
% \begin{definition}{\normalfont \textbf{(Configuration).}}
%  A configuration of a $\TM$ is a triple $(q,z,n)$ where, at present,
%  \begin{enumerate}
%   \item $q \in Q$ is the state of $\TM$.
%   \item $z \in \Gamma^*$ is the content of the tape.
%   \item $n \in \Z$ is the position of the head at the tape. 
%  \end{enumerate}
% 
% \end{definition}
% 
% $(q_0,x,0)$ denotes the starting configuration for an input 
% string $x$ instead of $(q_0,\vdash x,0)$ (w.l.o.g.).
% 
% 
% \begin{definition}{\normalfont \textbf{($\tau$-th Configuration $\stackrel{\tau}{\rightarrow})$.}}
%  The relation $\stackrel{\tau}{\rightarrow}$ is defined as,
%  \begin{enumerate}
%   \item $(q,z,n) \stackrel{\tau}{\rightarrow} (q', z' ,n+d)$ 
%   where $z'=\ldots z[n-1]\| b  \|z[n+1] \ldots$ if $\delta(q,z[n])=(q',b,d)$.
%   \item $\alpha \stackrel{\tau+1}{\rightarrow} \gamma$ if there exists a $\beta$ such that 
%   $\alpha \stackrel{\tau}{\rightarrow} \beta \stackrel{1}{\rightarrow} \gamma$.
%  \end{enumerate}
% \end{definition}
% We denote $\alpha \stackrel{0}{\rightarrow} \alpha$.
%  and $\alpha \stackrel{*}{\rightarrow} \beta$ if $\alpha \stackrel{\tau}{\rightarrow} \beta$ for some $\tau \ge 0$.
% We say that the $\TM$ halts on a string $x$ with the output $y$ if
% $(q_0,x,0)\stackrel{*}{\rightarrow}(q_F,y,n)$ such that $q_F \in F$.
% % A finite sequence of input symbols from $\Gamma$ is called as a
% % string and a set of strings as a language $\mathcal{L}$. 
% % On an input string written on its tape the machine $\TM$ 
% % processes each of its symbols $s_i$ sequentially in one direction. 
% 
% \begin{definition}{\normalfont \textbf{(Time and Space Complexity).}}
% We say that a $\TM$ computes a function 
% $f:\Sigma^* \rightarrow \Sigma^*$ in time $\tau$ and space $\sigma$
% if $\forall x\in \Sigma^*$, $(q_0,x,0)\stackrel{\tau}{\rightarrow}(q_F,f(x),n)$
%  using (at most) $\sigma$ different cells
% on the working tape (excluding the input tape).
% \end{definition}
% % We consider a single transition $\delta(q_i, s_i)=(q_j, s_j, d)$
% % for all $q_i, q_j\in Q$, $s_i, s_j\in \Gamma$ and 
% % $d \in \{\mathsf{L,S,R}\}$ as
% % the unit of computations. 
% % We say $\TM$ computes $f$ in $T:\mathbb{N}\rightarrow\mathbb{N}$-time 
% % if its computation on every input $x$ requires at
% % most $T(|x|)$ transitions. 
% % % In this paper we will talk about deterministic $\TM$s only, in a sense 
% % % that all the $\delta$ are deterministic. 
% 
% 
% % Similarly $\TM$ rejects a string if it ends up at one of the states from $F^-$ within a finite time. Either of these 
% % is called as halting of the $\TM$. However, the $\TM$ may loop forever if it does not halt within a finite time.
% We call a language $\L$ is decidable by a $\TM$ if and only if there exists a $\TM$ that accepts 
% all the strings belong to $\L$ and rejects all the strings belong to $\overline{\L}=\Sigma^*\setminus \L$.
% We say that a language $\L$ is reducible to another language $\L'$ if and only if there exists a function $f$ 
% such that $f(x) \in \L'$ if and only if $x \in \L$. 
% If the function $f$ is computable in $\poly(|x|)$-time then we call it 
% as a polynomial time reduction $\L \le _p \L'$.
% 
% In order to discuss the complexity classes we follow the definitions provided in~\cite{Arora2009Modern}.
% % \begin{definition}{\normalfont \textbf{(DTIME).}}
% % Suppose $f: \mathbb{N}\rightarrow\mathbb{N}$ be some function. A language $\L$
% % is in $\DTIME(f(n))$ if and only if there is a $\TM$ that decides $\L$ in time $\O(f(n))$.
% % \end{definition}
% 
% \begin{definition}{\normalfont \textbf{(DSPACE).}}
% Suppose $f: \mathbb{N}\rightarrow\mathbb{N}$ be some function. A language $\L$
% is in $\DSPACE[f(n)]$ if and only if there is a $\TM$ that decides $\L$ in space $\O(f(n))$.
% \end{definition}
% 
% % \begin{definition}{\normalfont \textbf{(The Class P).}}
% % $$\P=\bigcup \limits_{k \ge 1} \DTIME(n^k).$$
% % \end{definition}
% 
% \begin{definition}{\normalfont \textbf{(The Class $\PSPACE$).}}
% $$\PSPACE=\bigcup_{k \in \poly(n)}\DSPACE[k].$$
% \end{definition}
% 
% % \begin{definition}{\normalfont \textbf{(The Class $\EXP$).}}
% % $$\EXP=\bigcup \limits_{k \ge 1} \DTIME(2^{n^k}).$$
% % \end{definition}
% % 
% % \begin{definition}{\normalfont \textbf{(The Class NC).}}
% % $$\NC=\bigcup_{k \ge 1} \NC^k$$
% % For every $k$, $\NC^k$ is the set of languages that can be decided
% % by a family of boolean circuits $\{C_n\}$ where $C_n$ has $\poly(n)$ size and depth 
% % $\O(\log^k n)$. 
% % \end{definition}
% % $\NC$ denotes the class of efficiently parallelizable languages. 
% 
% 
% \begin{definition}{\normalfont \textbf{($\PSPACE$-complete).}}
% A language is $\PSPACE$-complete if it is in $\PSPACE$ and every language in $\PSPACE$
% is reducible to it in polynomial time.
% \end{definition}


\subsection{Interactive Proof System}
Goldwasser et al. were the first to show that the interactions between the prover and
randomized verifier recognizes class of languages larger than $\NP$~\cite{Goldwasser85Knowledge}. 
They named the class as $\IP$ and the model of
interactions as the interactive proof system. Babai and Moran introduced the same notion of interactions in
the name of Arthur-Merlin games however with a restriction on the verifiers' side \cite{Babai88AM}. 
Later, Goldwasser and Sipser proved that both the models are equivalent
\cite{Goldwasser86IPAM}. Two important works in this context that motivate our present
study are by the Shamir showing that $\IP=\PSPACE$ \cite{ShamirIP} and by the Goldwasser
et al. proving that $\PSPACE = \mathbf{ZK}$, the set of all zero-knowledge protocols.
We summarize the interactive proof system from \cite{Goldwasser88ZK}.

An interactive proof system $\ips$ consists of a pair of Turing machines ($\TM$), $\prv$ and $\vrf$,
with common alphabet $\Sigma=\{0,1\}$. $\prv$ and $\vrf$ each have distinguished initial and
quiescent states. $\vrf$ has distinguished halting states out of which there is no
transitions. $\prv$ and $\vrf$ operates on various one-way infinite tapes,
\begin{enumerate}[label=\roman*.]
\item $\prv$ and $\vrf$ have a common read-only input tape.
\item $\prv$ and $\vrf$ each have a private random tape and a private work tape.
\item $\prv$ and $\vrf$ have a common communication tape.
\item $\vrf$ is polynomially time-bounded. This means $\vrf$ halts on input $x$ in time
$\poly(|x|)$. $\vrf$ is in quiescent state when $\prv$ is running.
\item $\prv$ is computationally unbounded but runs in finite time. This means $\prv$ 
may compute any arbitrary function $\{0,1\}^*\rightarrow \{0,1\}^*$ on input $x$ 
in time $f(|x|)$. Feldman proved that ``the optimum prover lives in $\PSPACE$"
\footnote{We could not find a valid citation.}.
\item The length of the messages written by $\prv$ into the common communication tape is
bounded by $\poly(|x|)$. Since $\vrf$ runs in $\poly(|x|)$ time, it can not write
messages longer than $\poly(|x|)$.
\end{enumerate}

Execution begins with $\prv$ in its quiescent state and $\vrf$ in its start state.
$\vrf$'s entering its quiescent state arouses $\prv$, causing it to transition to its
start state. Likewise, $\prv$'s entering its quiescent state causes $\vrf$ to
transition to its start state. Execution terminate when $\vrf$ enters in its halting
states. Thus $\ips(x)=1$ denotes $\vrf$ accepts $x$ and $\ips(x)=0$ denotes $\vrf$
rejects $x$.

\begin{definition}{\normalfont \textbf{(Interactive Proof System $\ips$ ).}}
$\ips$ is an interactive proof system for the language $\L\subseteq \{0,1\}^*$ if 

\begin{description}
 \item \noindent {\normalfont (Correctness).} $(x \in \L) \implies \Pr[\ips(x))=1] \ge 1-\negl(|x|)$.
 \item \noindent {\normalfont (Soundness).}  $(x\notin\L) \implies
\forall\prv',\Pr[(\prv'\leftrightarrow\vrf)(x))=1] < \negl(|x|)$.
\end{description}
\end{definition}

The class of polynomial-time interactive proofs $\IP$ is defined as the class of the languages
that have $\ips$ such that $\prv$ and $\vrf$ talk for at most $\poly(n)$-rounds. 
Thus $$\IP=\{\L \mid \L \text{ has a } \poly(n)\text{-round } \ips\}.$$
Alternatively and more specifically,


\begin{definition}{\normalfont \textbf{(The Class IP).}}
$$\IP=\bigcup_{k \in\poly(n)}\IP[k].$$
For every $k$, $\IP[k]$ is the set of languages $\L$ such that there exist a probabilistic polynomial time $\TM$
$\vrf$ that can have a $k$-round interaction with a prover $\prv : \{0,1\}^*\rightarrow \{0,1\}^*$ 
having these two following properties
\begin{description}
 \item \noindent {\normalfont (Correctness).} $(x \in \L) \implies \Pr[\ips(x))=1] \ge 1-\negl(|x|)$.
 \item \noindent {\normalfont (Soundness).}  $(x\notin\L) \implies
\forall\prv',\Pr[(\prv'\leftrightarrow\vrf)(x))=1] < \negl(|x|)$.
\end{description}
\end{definition}

%Using Chernoff bounds it can be shown that if $\vrf$ repeats this 
%experiment for $m$ times then these two probabilities 
%become $(1-2^{-\Omega(m)})$ and $2^{-\Omega(m)}$ causing no harm to the definition.
%The class $\IP$ is the set of interactive proofs 
%with probabilistic polynomial time verifier allowing polynomial number 
%of rounds of interaction with the prover.
%
% We know that $\NC \subseteq \P \varsubsetneq \IP = \PSPACE \subseteq  \EXP$. 
% On the other hand, it is yet to decide if $\NC \varsubsetneq \P$ or not.
% If a class $\S \varsupsetneq \NC$ then the set $\{\S \setminus \NC \}$ represent \emph{some} of the languages 
% that are non-parallelizable or inherently sequential. 
% Informally, a complete language for any class is hardest to decide.
% Therefore it is always safe to assume that $\S$-complete languages are sequential if $\S \varsupsetneq \NC$. 
% In our approach, we need $\PSPACE$ to be the class $\S$.

\section{Fiat--Shamir Transformation}
Any interactive protocol $\ips$ can be transformed into a non-interactive
protocol if the messages from the verifier $\vrf$ are replaced with the response of
a random oracle $\RO$. This is known as Fiat--Shamir transformation (FS)~\cite{FS86}. In
particular, the $i$-th message from $\vrf$ is computed as
$y_i:=\RO(x,x_1,y_1,\ldots,x_i, y_{i-1})$ where $x_i$ denotes the $i$-th
response of $\prv$. When $\RO$ is specified in the public parameters of a $k$-round
protocol, the transcript $x,x_1,y_1,\ldots,x_k, y_{k-1}$ can be verified publicly.
Thus, relative to a random oracle $\RO$, a $k$-round interactive proof protocol 
$\ips$ can be transformed into a two-round non-interactive argument 
$(\prv_{FS} \leftrightarrow \vrf_{FS})$ where $\prv_{FS}$ sends the entire transcript 
$x,x_1,y_1,\ldots,x_k, y_k$ to $\vrf_{FS}$ in a single round. Under the assumption that $\RO$ is
one-way and collision-resistant, $\vrf_{FS}$ accepts $x\in \L$ in the next round if and only if 
$\vrf$ accepts. Here we summarize two claims on Fiat--Shamir transformation stated in~\cite{Ephraim20VDF}.

\begin{lemma}\label{FS}
If there exists an adversary $\adv$ who breaks the soundness of the non-interactive
protocol $(\prv_{FS} \leftrightarrow \vrf_{FS})$ with the probability $p$ using
$q$ queries to a random oracle then there exists another adversary $\adv'$ who breaks
the soundness of the $k$-round interactive protocol $\ips$ 
with the probability $p/q^k$.
\end{lemma}


\begin{proof}
See~\cite{Goldreich96} for details. 
\end{proof}


\begin{lemma}\label{soundFS}
Against all non-uniform probabilistic polynomial-time adversaries,  
if a $k$-round interactive protocol $(\prv \leftrightarrow \vrf)$
achieves $\negl(|x|^k)$-soundness then the non-interactive protocol 
$(\prv_{FS} \leftrightarrow \vrf_{FS})$ has $\negl(|x|)$-soundness.
\end{lemma}


\begin{proof}
Since, all the adversaries run in probabilistic polynomial time, the number of queries
$q$ to the random oracle must be upper-bounded by $\poly(|x|)$.
Putting $q =|x|^c $ for any $c \in \Z^+$ in lemma.~\ref{FS}, it follows the claim. 

\end{proof}

\section{$\vdf$ Characterization}
 
In this section, we investigate the possibility to model $\vdf$s as a language in order
to define its hardness. It seems that there are two hurdles,
\begin{description}
\item [Eliminating Fiat--Shamir]
The prover $\prv$ in Def.~\ref{VDF}, generates the proof $\pi:=f(x,y,T,\RO(x,y,T))$ using Fiat--Shamir
transformation where $y:=\eval(x,\pp,T)$. Unless Fiat--Shamir is eliminated from $\vdf$, its
hardness remains relative to the random oracle $\RO$. Sect.~\ref{ivdf} resolves this
issue.


\item  [Modelling Parallel Adversary] How to model the parallel adversary $\adv$ (Def. \ref{paradv}) 
in terms of computational complexity theory? We model $\adv$ as a special variant of
Turing machines described in Def.~\ref{PTM}.
\end{description}

We address the first issue now.

\subsection{Interactive $\vdf$s}\label{ivdf}
% As discussed in the Sect. \ref{literature}, some $\vdf$s need no proof
% \cite{Dwork1992Price,Dan2018VDF,Feo2019Isogenie}. The proof-size against 
% those $\vdf$s in Tab. \ref{tab : VDF} are empty. These $\vdf$s are called inherently
% non-interactive $\vdf$s because $\prv$ receives no input from $\vrf$. 
% The output $y$ can be ``written down in a book"
% in order to get verified. As $\vrf$ in Def. \ref{VDF} runs only a deterministic
% algorithm $\verify$, we claim that these $\vdf$s should belong to the class $\NP$. 
% However, in case of other 
% two $\vdf$s, $\prv$ needs to produce some proofs $\pi$ on random challenges. 
% In \cite{Wesolowski2019Efficient}, the random challenge 
% is the sampled prime $\ell$ and in \cite{Pietrzak2019Simple} they are the sampled integers
% $\{r_1, r_2, \ldots, r_{\log T}\}$. The randomness is crucial in order 
% to achieve the soundness for both the $\vdf$s.
% Thus they rely on the randomness of a random oracle $\RO$. 
% In particular, $\prv$ obtains $\ell:= \RO(x,y,\pp,T)$
% \cite{Wesolowski2019Efficient} and $r_i := \RO(x_i,y_i,\pp,T/2^i)$
% \cite{Pietrzak2019Simple}. Thus these $\vdf$s are non-interactive (but not inherently)
% only in the presence of the random oracle $\RO$. Otherwise they are interactive where
% the random challenges are chosen only by $\vrf$. So, $\prv$ needs to interact with
% $\vrf$ in order to obtain the challenges. Most importantly, in the interactive versions,
% $\vrf$ uses random coin flips to sample the challenges and thus 
% is a probabilistic polynomial time algorithm.
% This transformation of an interactive protocol
% into a non-interactive one using a random oracle is called the Fiat--Shamir
% heuristic. In fact, we find the interactive version of both these $\vdf$s in
% \cite{VDF2018Survey}
% 
% Still it seems natural to ask then why $\vdf$s are defined as non-interactive protocols? 
% The key reason is that $\vdf$s are used to provide public verifiability in decentralized 
% distributed networks e.g., blockchains or randomness
% beacon generation. The Fiat--Shamir heuristic is known to be a standard technique
% to transform an interactive protocol into a 
% non-interactive protocol.
% The idea is to replace $\vrf$'s coin flips with the output of a random oracle $\RO$
% querying on the computed output $\phi$. The prover $\prv$ obtains a challenge, say
% $t:=\RO(x \| \phi)$, and computes the proof $\pi$ against this $t$. Thus  
% Def.~\ref{VDF} refers to public coins where $\vrf$ never uses 
% randomness as it is inherited from the random oracle $\RO$. 
% So here the verifier is deterministic but the prover may not be.

We introduce the interactive $\vdf$s in order to eliminate the Fiat--Shamir.
In the interactive version of a $\vdf$, the $\vrf$ replaces the
randomness of Fiat--Shamir heuristic. 
In particular, a non-interactive $\vdf$ with the Fiat--Shamir transcript 
$\langle x,x_1,y_1,\ldots,x_k, y_k \rangle$ can be translated into an equivalent $k$-round 
interactive $\vdf$ allowing $\vrf$ to choose $y_i$s in each round.



% $\vrf$ chooses a $t$ uniformly at random, sends it to $\prv$
% and remembers it. When $\prv$ sends the $\pi$ against the $t$, $\vrf$ recalls $t$ and
% runs $\verify$ on $\phi$ and $\pi$. Thus in the interactive versions $\vrf$
% is probabilistic polynomial time algorithm and $\prv$ may also be probabilistic but
% may not be efficient.
% 
% Now, we give the definition of $\vdf$ as an interactive protocol.
% However we are not the first to introduce the idea.
% $\vdf$s belong to a more generalized class of sequential
% protocols known as proof-of-sequential-work ($\PoSW$) \cite{Mahmoody2013Sequential}. 
% In short, $\PoSW$s allow multiple proofs for a given tuple
% $(x,\pp,T)$, thus their verifiers need to verify the same output $\phi$ by the
% prover against several different challenges. So instead of a negligible function in
% $\lambda$, their soundness gets compromised upto $(1-\alpha)^d$ for $d$ challenges
% against an adversary doing only $(1-\alpha) T$ sequential computations.
% Essentially, $\vdf$s are $\PoSW$s that have unique proofs.
% Traditionally, $\PoSW$s are defined as interactive protocols \cite{Mahmoody2013Sequential}. 
% Therefore, in order to define interactive $\vdf$s, we follow the same methodology 
% by introducing another algorithm $\mathsf{Open}$. This $\mathsf{Open}$ actually
% engages $\prv$ and $\vrf$ into interaction and thus eliminates the random oracle $\RO$
% from the Def. \ref{VDF}.

\begin{definition}\normalfont{ \bf (Interactive Verifiable Delay Function).} 
An interactive verifiable delay function is a tuple $(\setup, \eval,\mathsf{Open} ,\verify)$ 
that implements a function $\X\rightarrow\Y$ as follows,
\begin{itemize}[label=\textbullet]
\item $\setup(1^\lambda, T) \rightarrow \pp$
 is a randomized algorithm that takes as input a security parameter $\lambda$ 
 and a delay parameter $T$, and produces the public parameters 
 $\pp$ in $\poly(\lambda,\log{T})$ time.
%  For meaningful security, the target time $T$ is restricted to be sub-exponentially sized in $\lambda$.
 
 \item $\eval(\pp, x) \rightarrow y$ takes an input 
 $x\in\mathcal{X}$, and produces an output $y\in\mathcal{Y}$. 
 For all $\pp$ generated by $\textsf{Setup}(\lambda, T)$ 
 and all $x\in\mathcal{X}$, the algorithm 
 \textsf{Eval}$(\pp, x)$ must run in time $T$.
 % with  $\poly(\lambda,\log{T})$ processors.

 \item $\mathsf{Open}(x,y,\pp,T,t)\rightarrow\pi$ 
 takes the challenge $t$ chosen by $\vrf$ and recursively computes 
 a proof $\pi$ in $k \in \poly(\lambda, \log T)$-rounds of 
 interaction with $\vrf$. In general, for some $k \in \poly(\lambda,\log T)$, 
 $\pi=\{\pi_1, \ldots, \pi_k\}$ can be computed as 
 $\pi_{i+1}:=\mathsf{Open}(x_i,y_i,\pp,T,t_i)$ where 
 $x_i$ and $y_i$ depend on $\pi_i$. Observing $(x_i,y_i,\pi_i)$ 
 in the $i$-th round, $\vrf$ chooses the challenge $t_i$ for 
 the $(i+1)$-th round. Hence, $\vrf$ can efficiently collect all the proofs 
 $\pi=\{\pi_1, \ldots, \pi_k\}$ in $\poly(\lambda,\log T)$-rounds of interactions.
 $\mathsf{Open}$ does not exist for the $\vdf$s that need no proof (e.g., 
 \cite{Feo2019Isogenie}). 
 \item $\verify(\pp, x, y, \pi) \rightarrow \{0, 1\}$ is a 
 deterministic algorithm that takes an input $x\in\mathcal{X}$, an output $y\in\mathcal{Y}$,
 and the proof vector $\pi$ (if any), and either accepts ($1)$ or rejects ($0)$. 
 The algorithm must run in $\poly(\lambda,\log{T})$ time.
\end{itemize}
\end{definition}

All the three security properties remain same for the interactive $\vdf$. 
Sequentiality is preserved by the fact that
$\mathsf{Open}$ runs after the computation of $y:=\eval(x,\pp,T)$. For soundness, we rely
on lemma.~\ref{soundFS}. The correctness of interactive $\vdf$s implies the correctness
of the non-interactive version as the randomness that determines the proof is not in the
control of $\prv$. Therefore, an honest prover always convinces $\vrf$. 

% The crucial observations are,
% \begin{itemize}
% \item Def. \ref{ivdf} does not fail to model inherently non-interactive $\vdf$s. They
% simply do not have the $\mathsf{Open}$ algorithm. 
% 
% \item Although $\verify$ is a deterministic algorithm, it does not mean $\vrf$ is
% a deterministic algorithm. In particular, $\vrf$ might choose the challenge $t$ 
% uniformly at random in $\mathsf{Open}$. Thus in a sharp contrast with Def. \ref{VDF} the
% verifier $\vrf$ in Def. \ref{ivdf} is a probabilistic polynomial time algorithm.
% 
% \item Each call of the random oracle $\RO$ in the non-interactive version corresponds to
% each round of interactions from $\vrf$ and $\prv$ in the interactive version.
% Hence the number of rounds in the interactive version is exactly same as the number of
% calls of the random oracle in the non-interactive version.
%  
% \item As Fiat--Shamir heuristic replaces the coin flips by $\vrf$, from the perspective of
% $\prv$ evaluating the interactive version of a $\vdf$ is no easier than that of the
% non-interactive version.
% \end{itemize}


Although the interactive $\vdf$s do not make much sense as publicly verifiable proofs in
decentralized distributed networks, it allow us to analyze its hardness irrespective of
any random oracle.  

In order to model parallel adversary, we consider a well-known variant of Turing machine that suits the
context of parallelism. We describe the variant namely parallel Turing machine as
briefly as possible from (Sect. 2 in cf.~\cite{Worsch1993Parallel})%  
% including the following theorem. 
 \subsection{Parallel Turing Machine}
 Intuitively, a parallel Turing machine has multiple control units (\textsf{CU})
 (working collaboratively) with a single head associated with each of them
 working on a common read-only input tape \cite{Worsch1993Parallel}. 
 and a common read-write work tape.
 \begin{definition}{\normalfont \textbf{(Parallel Turing Machine).}}\label{PTM}
  a parallel Turing machine is a tuple 
  $\PTM = \langle Q, \Gamma,\Sigma, q_0, F, \delta \rangle$ where
\begin{enumerate}
 \item $Q$ is the finite and nonempty set of states.
 \item $\Gamma$ is the finite and non-empty set of tape alphabet symbols including the input alphabet $\Sigma$.
 \item $q_0\in Q$ is the initial state.
 \item $F \subseteq Q$ is the set of halting states.
 \item $\delta : 2^Q \times \Gamma\rightarrow 2^{Q\times D} \times \Gamma$ 
 where $D=\{-1,0,+1\}$ is the set of directions along the tape.
% \begin{enumerate}
%  \item $\delta : Q   \times \{\vdash\} \rightarrow Q \times \{\vdash\}\times \{+1\}$.
%  \item $\delta : F^+ \times \Gamma\rightarrow F^+ \times \Gamma \times D$
%  \item $\delta : F^- \times \Gamma\rightarrow F^- \times \Gamma \times D$
% \end{enumerate}
\end{enumerate}
 \end{definition}
 
 A configuration of a $\PTM$ is a pair $c=(p,b)$ of mappings
 $p:\Z^+\rightarrow 2^Q$ and $b:\Z^+\rightarrow \Gamma$.
 The mapping $p(i)$ denotes the set of states of the \textsf{CU}s
 currently pointing to the $i$-th cell in the input tape and $b(i)$ is the 
 symbol written on it. So it is impossible for two different \textsf{CU}s 
 pointing to the same cell $i$ while staying at the same state simultaneously.
 During transitions $c'=(M'_i,b'(i))=\delta(c)=\delta(p(i),b(i))$, the set of \textsf{CU}s
 may be replaced by a new set of \textsf{CU}s $M'_i \subseteq Q \times D$. 
 The $p'(i)$ in the configuration $c'$ is defined as 
 $p'(i)=\{q \mid (q,+1)\in M'_{i-1} \lor (q,0)\in M'_{i} \lor (q,-1)\in M'_{i+1}\}$. 
 % Note that the number of \textsf{CU}s may change during computations, however, 
 % we must have $\forall b\in\Gamma, (\varnothing,b)=\delta(\varnothing, b)$. 
 
 Without loss of generality, the cell $1$ is observed in order to find 
 the halting condition of $\PTM$. We say that a $\PTM$ halts on a 
 string if and only if $p(1)\subseteq F$ after some finite time. 
 The notion of decidability by a $\PTM$ 
 is exactly same as in $\TM$. We denote $\PTM(s,t,h)$
 as the family of all languages for which there is a $\PTM$ recognizing them 
 using space $s$, time $t$ and $h$ processors. Thus languages decidable by a
 $\TM$ is basically decidable by a $\PTM(s,t,1)$. Assuming $\TM(s,t)$ is the set of
 languages recognized by a $\TM$ in space $s$ and time $t$, we mention Theorem 15 from
 (cf. \cite{Worsch1993Parallel}) without the proof. 


% \begin{theorem}
% For all functions $s(n) \ge n$ and $t(n) \ge n$ holds:
% $$\TM(\O(s),\O(t)) \subseteq \PTM(\O(s),\O(t),\O(s))$$
% $$\PTM(\O(s),\O(t),\O(h)) \subseteq \TM(\O(s),\O(t\sqrt{sh})).$$
% \end{theorem}

We observe that the parallel adversary $\adv$ defined in Def. \ref{paradv} is
essentially a $\PTM$ having $\poly(\lambda,T)$ processors running on $\poly(\lambda,T)$
space in time $\sigma(T)$. We will refer such a $\PTM$ with $\poly(\lambda,T)$-$\PTM$
(w.l.o.g.) in our subsequent discussions. 


\subsection{$\vdf$ As A Language} 

Now  we characterize $\vdf$s in terms of computational complexity theory. We
observe that, much like $\ips$, $\vdf$s are also proof system for the languages,
\[
\L=\left\{(x,y,T)
\begin{array}{l}
\end{array}
\Biggm| \begin{array}{l}
\pp\leftarrow\setup(1^\lambda,T)\\
x \in  \{0,1\}^\lambda\\
y\leftarrow\eval(\pp,x)
\end{array}
\right\}.
\]
$\prv$ tries to convince $\vrf$ that the tuple $(x,y,T)\in \L$ in
polynomially many rounds of interactions. 
In fact, Pietrzak represents his $\vdf$ using such a language (Sect. 4.2 in cf.
\cite{Pietrzak2019Simple}) where it needs $\log T$ (i.e., $\poly(\lambda))$
rounds of interaction. However, by design, the $\vdf$ is non-interactive. It uses
Fiat--Shamir transformation.

Thus, a $\vdf$ closely resembles an $\ips$ except on the fact
that it stands sequential (see Def.~\ref{def: Sequentiality}) even against 
an adversary (including $\prv$) possessing subexponential parallelism. 
Notice that a $\poly(\lambda,T)$-$\PTM$ (see Def. \ref{PTM})
precisely models the parallel adversary described in Def. \ref{paradv}. 
In case of interactive proof systems, we never talk about the running time of $\prv$
except its finiteness. On the contrary, $\prv$ of a $\vdf$ must run for at least
$T$ time in order to satisfy its sequentiality. Hence, we define $\vdf$ as follows,

\begin{definition}{\normalfont \textbf{(Verifiable Delay Function $\vdfs$).}}
For every $\lambda\in \Z^+$, $T \in 2^{o(\lambda)}$ and for all $s= (x,y,T) \in
\{0,1\}^{2\lambda +\lceil\log T\rceil}$,
$\vdfs$ is a verifiable delay function for a language $\L\subseteq\{0,1\}^*$ if
\begin{description}
 \item \noindent {\normalfont (Correctness).} $(s \in \L) \implies \Pr[\vdfs(s))=1]\ge 1-\negl(\lambda)$.
 \item \noindent {\normalfont (Soundness).} $(s \notin\L)\implies\forall\adv,\Pr[\advs(s))=1] \le \negl(\lambda)$.
 \item \noindent {\normalfont (Sequentiality).} $(s\in\L)\implies\forall\adf,\Pr[\adfs(s))=1] \le \negl(\lambda)$.
\end{description}
where, 
\begin{enumerate}[label=\roman*.]
\item $\prv : \{0,1\}^*\rightarrow \{0,1\}^*$ is a $\TM$ that runs in time $\ge T$, 
\item $\adv : \{0,1\}^* \rightarrow \{0,1\}^*$ is a $\TM$ that runs in 
time $\poly(\lambda,T)$,
\item $\adf$ is a {\normalfont $\poly(\lambda,T)$}-$\PTM$ 
(see Def. \ref{PTM}) that runs in time $<T$.
\end{enumerate}
\end{definition}

% Clearly, a verifiable delay function $\vdfs$ is an interactive proof system 
% $\ips$ with the additional property \emph{sequentiality}.

Further, we define the class of all verifiable delay functions as, 
% that have $k$-round 
% interactions between $\prv$ and $\vrf$ as,
% \begin{definition}{\normalfont \textbf{(The set of $k$-round $\vdf$s).}}
%  $$\VDF[k]=\{\L \mid \L \text{ has an }k \text{-round }\vdfs\}.$$ 
% \end{definition}
% Formally
\begin{definition}{\normalfont \textbf{(The Class $\VDF)$.}}\label{VDF}
$$\VDF=\bigcup_{k \in \poly(\lambda)}  \VDF[k].$$
For every $k\in\Z^+$, $\VDF[k]$ is the set of languages $\L$ 
such that there exists a probabilistic polynomial-time 
$\TM$ $\vrf$ that can have a {\normalfont $k$}-round interaction with
\begin{enumerate}[label=\roman*.]
\item $\prv : \{0,1\}^* \rightarrow \{0,1\}^*$ is a $\TM$ that runs in time $\ge T$, 
\item $\adv : \{0,1\}^* \rightarrow \{0,1\}^*$ is a $\TM$ that runs in time $\poly(\lambda,T)$,
\item $\adf$ is a {\normalfont $\poly(\lambda,T)$}-$\PTM$ 
(see Def. \ref{PTM}) that runs in time $<T$.
\end{enumerate}
satisfying these three following properties,

\begin{description}
 \item \noindent {\normalfont (Correctness).} $(s \in \L) \implies \Pr[\vdfs(s))=1]\ge 1-\negl(\lambda)$.
 \item \noindent {\normalfont (Soundness).} $(s \notin\L)\implies\forall\adv,\Pr[\advs(s))=1] \le \negl(\lambda)$.
 \item \noindent {\normalfont (Sequentiality).} $(s\in\L)\implies\forall\adf,\Pr[\adfs(s))=1] \le \negl(\lambda)$.
\end{description}
\end{definition}

\section{$\VDF$-completeness of $\rSVL$}
In this section, we show that $\rSVL$ is a complete problem the class $\VDF$. 
\begin{theorem}{\normalfont \textbf{($\rSVL$ is $\VDF$-complete).}}\label{thm:complete}
$\rSVL$ is a complete problem for the class $\VDF$.  
\end{theorem}


\begin{proof}
By theorem.~\ref{thm:member} $\rSVL$ belongs to the class $\VDF$.
By theorem.~\ref{thm:hardness}, $\rSVL$ is a hard problem for the class $\VDF$.
Hence, $\rSVL$ is a complete problem for the class $\VDF$.  
\end{proof}

\begin{theorem}{\normalfont \textbf{($\rSVL\in \VDF$).}}\label{thm:member}
For the parameters $\lambda\in \Z^+$ and $T=T(\lambda) \in 2^{o(\lambda)}$, let 
$\S : \{0,1\}^\lambda \rightarrow \{0,1\}^\lambda$, $\V : \{0,1\}^\lambda \times \{1,
\ldots, T\}\rightarrow \{0,1\}$ 
and $x\in\{0,1\}^\lambda$. If there exists a family of $\rSVL$ instances 
$\{\S,\V,v,T\}_{v\in\{0,1\}^\lambda}$ such that each 
instance allows at most polynomially many (i.e., $\poly(\lambda)$) false positive vertices  
then there exists a permutation $\vdf$s with $\X=\Y=\{0,1\}^\lambda$ 
and the delay parameter $T$.
\end{theorem}

\begin{proof}
Given any $\lambda\in \Z^+$ and any $T \in 2^{o(\lambda)}$,
we derive a permutation $\vdf$ from a sub-family of $\rSVL$,
$\{\S,\V,v,T\}^{v\in\{0,1\}^\lambda}$ as follows,

\begin{itemize}[label=\textbullet]
 \item \textsf{Setup}$(1^\lambda, T) \rightarrow \pp$
  It samples a $\rSVL$ sub-family $\{\S,\V,v,T\}_{v\in \{0,1\}^\lambda}$ as the public parameter $\pp$
  from the family $\{\S,\V,v,T\}_{v,\lambda}$, uniformly at random. 
 
 \item \textsf{Eval}$(\pp, x) \rightarrow (y, \bot)$ It takes an input 
 $x\in\mathcal{X}=\{0,1\}^\lambda$, and produces an output $y:=\S^T(x)$. 
 There is no proof, so $\pi=\bot$.
 
 \item \textsf{Verify}$(\pp, x, y, \bot) \rightarrow \{0, 1\}$ 
  It returns $\V(y, T)$. Note that the input $x$ is implicit 
  to the circuit $\V$. Thus, $\verify$ is not independent of $x$. 
\end{itemize}

We prove the correctness, computational soundness and sequentiality of this $\vdf$ 
in Theorem.~\ref{thm:correct}, \ref{thm:sound} and \ref{thm:sequence}.
\end{proof}


\begin{theorem}{\normalfont \textbf{(Correctness).}}\label{thm:correct}
The derived $\vdf$, in Theorem.~\ref{thm:member}, is correct. 
\end{theorem}

\begin{proof}
For the $\rSVL$ instance $(\S,\V,v,T)$, 
$\V(u,T)=1$ if and only if either $u=\S^T(v)$ or $u$ is a false positive
vertex i.e., $\V(u,T)=1$  but $u\ne\S^T(v)$. 
In this $\vdf$, $\eval(x)=\S^T(x)$ and $\verify(x,y,T)=\V(y,T)$. Therefore, 
$\verify(x,y,T)=1$ if and only if either $y=\eval(x,T)$ or $y$ is false positive vertex off
the main line in the $\rSVL$ instance $(\S,\V,x,T)$. Since, the number of false positive
vertices is in $\poly(\lambda)$, the probability that a random vertex $y$ is false
positive is at most $\poly(\lambda)/2^\lambda=\negl(\lambda)$. Therefore, 
$$\Pr[\V(y,T)=1 \land  y=\S^T(x)] \ge  1-\negl(\lambda).$$
\end{proof}

\begin{theorem}{\normalfont \textbf{(Soundness).}}\label{thm:sound}
For the parameters $\lambda\in \Z^+$ and $T=T(\lambda) \in 2^{o(\lambda)}$, let 
$\S : \{0,1\}^\lambda \rightarrow \{0,1\}^\lambda$, $\V : \{0,1\}^\lambda \times \{1,
\ldots, T\}\rightarrow \{0,1\}$ 
and $v\in\{0,1\}^\lambda$. If there exists an adversary $\adv$ that 
breaks the soundness of this permutation 
$\vdf$s with $\X=\Y=\{0,1\}^\lambda$ and the delay parameter $T$ with 
with a non-negligible probability $\epsilon=\epsilon(\lambda)$, 
then there exists another adversary $\adf$ who 
finds false positive vertices for the instances from the $\rSVL$ 
family $\{\S,\V,v,T\}_{v\in\{0,1\}^\lambda}$ with the probability $\epsilon$.
\end{theorem}

\begin{proof}
For the $\rSVL$ instance $(\S,\V,v,T)$, 
$\V(u,T)=1$ if and only if either $u=\S^T(v)$ or $u$ is a false positive
vertex i.e., $\V(u,T)=1$  but $u\ne\S^T(v)$. 
In this $\vdf$, $\eval(x)=\S^T(x)$ and $\verify(x,y,T)=\V(y,T)$. Therefore, 
$\verify(x,y,T)=1$ if and only if either $y=\eval(x,T)$ or $y$ is false positive vertex off
the main line in the $\rSVL$ instance $(\S,\V,x,T)$. 

As the adversary $\adv$ breaks the soundness of this $\vdf$, he must find a $y \ne
\eval(x,T)$ but $\verify(x,y,T)=1$. Therefore, in order to find a false positive vertex
$y$ in the $\rSVL$ instance $(\S,\V,x,T)$, $\adf$ runs $\adv$ on input $(x,T)$. When
$\adv$ outputs $y$, $\adf$ returns $y$ as the false positive vertex. Therefore,

$$\Pr[\adf \text{ wins }]=\Pr[\adv \text{ wins }] =\epsilon(\lambda).$$

\end{proof}
% $\adf$ may break the soundness of the entire family $(\S,\V,x,T)$ running $\adv$ over
% any randomly chosen $x\in\{0,1\}^\lambda$.

Since, the number of false positive
vertices is in $\poly(\lambda)$, the probability that a random vertex $y$ is false
positive is at most $\poly(\lambda)/2^\lambda=\negl(\lambda)$. Therefore, $\adv$ 
has negligible advantage.

\begin{theorem}{\normalfont \textbf{(Sequentiality).}}\label{thm:sequence}
For the parameters $\lambda\in \Z^+$ and $T=T(\lambda) \in 2^{o(\lambda)}$, let 
$\S : \{0,1\}^\lambda \rightarrow \{0,1\}^\lambda$, $\V : \{0,1\}^\lambda \times \{1,
\ldots, T\}\rightarrow \{0,1\}$ 
and $v\in\{0,1\}^\lambda$. If there exists an adversary $\adv$ that
breaks the sequentiality of this permutation 
$\vdf$s with $\X=\Y=\{0,1\}^\lambda$ and the delay parameter $T$ 
in time $T_\adv=T_\adv(\lambda) <T$ with 
the non-negligible probability $\epsilon=\epsilon(\lambda)$
then there exists another adversary $\adf$ who solves the instances
from the $\rSVL$ family $\{\S,\V,v,T\}_{v \in\{0,1\}^\lambda}$ 
in time $T_\adv+\O(1) <T$ with the probability $\epsilon$, 
\end{theorem}

\begin{proof}
For the $\rSVL$ instance $(\S,\V,v,T)$, 
$\V(u,T)=1$ if and only if either $u=\S^T(v)$ or $u$ is a false positive
vertex i.e., $\V(u,T)=1$  but $u\ne\S^T(v)$. 
In this $\vdf$, $\eval(x)=\S^T(x)$ and $\verify(x,y,T)=\V(y,T)$. Therefore, 
$\verify(x,y,T)=1$ if and only if either $y=\eval(x,T)$ or $y$ 
is false positive vertex off the main line in the $\rSVL$ instance $(\S,\V,x,T)$. 

As the adversary $\adv$ breaks the sequentiality of this $\vdf$, he must find the
$y=\eval(x,T)$ or a $y' \ne \eval(x,T)$ but $\verify(x,y',T)=1$, in time $T_\adv <T$. 
Therefore, in order to solve the $\rSVL$ instance $(\S,\V,x,T)$, $\adf$ runs $\adv$ on input $(x,T)$. 
When $\adv$ outputs $y$, $\adf$ returns $y$ as the solution in time
$T_\adv+\O(1)$. Therefore,

$$\Pr[\adf \text{ wins }]=\Pr[\adv \text{ wins }] =\epsilon(\lambda).$$

\end{proof}



Theorem.~\ref{thm:member} gives rise to permutation $\vdf$. Although, it suffices to
prove that $\rSVL \in \VDF$, deriving a $\vdf$ with $\X \ne \Y$, from $\rSVL$ needs 
a family of injective one-way function $\mathcal{H}=\{H:\X \rightarrow \Y\}$. 

\begin{theorem}{\normalfont \textbf{($\rSVL\in \VDF$, in general).}}\label{thm:memberH}
For the parameters $\lambda\in \Z^+$ and $T=T(\lambda) \in 2^{o(\lambda)}$, let 
$\S : \{0,1\}^\lambda \rightarrow \{0,1\}^\lambda$, $\V : \{0,1\}^\lambda \times \{1,
\ldots, T\}\rightarrow \{0,1\}$ 
and $v\in\{0,1\}^\lambda$. If there exists an adversary $\adv$ that
$x\in\{0,1\}^\lambda$. If there exists a family of $\rSVL$ instances 
$\{\S,\V,v,T\}_{v\in\{0,1\}^\lambda}$ such that each 
instance allows at most polynomially many (i.e., $\poly(\lambda)$) false positive vertices  
then there exists a permutation $\vdf$s with $\X\in \{0,1\}^*$, $\Y=\{0,1\}^\lambda$ 
and the delay parameter $T$, assuming
a family of injective one-way function $\mathcal{H}=\{H:\X \rightarrow \Y\}$. 
\end{theorem}

\begin{proof}
Given any $\lambda\in \Z^+$ and any $T \in 2^{o(\lambda)}$,
we derive a permutation $\vdf$ from a sub-family of $\rSVL$,
$\{\S,\V,v,T\}^{v\in\{0,1\}^\lambda}$ as follows,

\begin{itemize}[label=\textbullet]
 \item \textsf{Setup}$(1^\lambda, T) \rightarrow \pp$
  It samples a $\rSVL$ sub-family $\{\S,\V,v,T\}^{v\in \{0,1\}^\lambda}$ as the public parameter $\pp$
  from the family $\{\S,\V,v,T\}_{v\in\{0,1\}^\lambda}$, uniformly at random. 
 Apart from the $\rSVL$ instance, it also chooses an $H \in \mathcal{H}$, uniformly at
 random.  
 \item \textsf{Eval}$(\pp, x) \rightarrow (y, \bot)$ It takes an input 
 $x\in\{0,1\}^*$, and produces an output $y:=\S^T(H(x))$. 
 There is no proof, so $\pi=\bot$.
 
 \item \textsf{Verify}$(\pp, x, y, \bot) \rightarrow \{0, 1\}$ 
  It returns $\V(y, T)$. Note that the input $H(x)$ is implicit 
  to the circuit $\V$. Thus, $\verify$ is not independent of $x$. 
\end{itemize}

The proofs for the correctness, computational soundness and sequentiality of this $\vdf$ 
are same as Theorem.~\ref{thm:correct}, \ref{thm:sound} and \ref{thm:sequence}.
\end{proof}

As before, first we show that every permutation $\vdf$ reduces to $\rSVL$.

\begin{theorem}{\normalfont \textbf{(Reduction from Permutation $\VDF$ to $\rSVL$).}}
For the parameters $\lambda\in \Z^+$ and $T=T(\lambda) \in 2^{o(\lambda)}$, let 
$(\setup, \eval,\mathsf{Open}, \verify)$ be an interactive permutation $\vdf$ on
 the domain $\{0,1\}^\lambda$. Then
there exists a hard distribution of $\rSVL$ instances
$\{\S,\V,v,T\}_{v\in\{0,1\}^\lambda}$  
that have at most polynomially many (i.e., $\poly(\lambda)$) false positive vertices, such that
$\S : \{0,1\}^\lambda \rightarrow \{0,1\}^\lambda$, $\V : \{0,1\}^\lambda \times \{1,
\ldots, T\}\rightarrow \{0,1\}$ 
and $x\in\{0,1\}^\lambda$. 
\end{theorem}

\begin{proof}
Given any $\lambda\in \Z^+$ and any $T \in 2^{o(\lambda)}$,
we derive a hard distribution of $\rSVL$ instances, $\{\S,\V,v,T\}_{v\in\{0,1\}^\lambda}$ 
from a permutation $\vdf$, as follows,

\begin{description}
\item [The $\S$ circuit] 
In order to design $\S$, we observe that, for every permutation $\vdf$,
$\eval(x,T)=\eval(\eval(x,T-1))$ as $\X=\Y$.
This vertex $u$ is the source in the $\rSVL$ instances. 
Therefore, we keep $\S(u)=\eval(\pp,u,T=1)$. In particular,

\begin{algorithm}
\caption{$\S(u)$ from $\eval$}\label{alg:eval}
\begin{algorithmic}[1]
\STATE $y:=\eval(\pp,u,1)$
\RETURN $y$.
\end{algorithmic}
\end{algorithm}

More generally, $\S^i(v)=\eval(\pp,v,i)$ for all $i \le T$.

\item [The $\V$ circuit] 
We take the advantage of the interactive $\vdf$s in order to design $\V$.
In particular, 
\begin{algorithm}[H]
\caption{$\V(v,T)$ from $\eval$}\label{alg:verify}
\begin{algorithmic}[1]
\STATE $\pi:=\mathsf{Open}(\pp,v,y,T)$
\STATE $w:=\verify(\pp,v,y,T,\pi)$.
\RETURN $w$
\end{algorithmic}
\end{algorithm}

 Since, $\mathsf{Open}$ takes at most $\poly(\lambda, \log
T)$-rounds, $\V$ is efficient.
\end{description}

\end{proof}

Now, the challenge is to reduce any arbitrary $\vdf$ into an hard $\rSVL$ instances.
We can not follow the approach used in~\cite{ChoudhuriRSW}. They label the $\rSVL$
graph with the proofs in the Pietrzak's $\vdf$ using the "proof-merging" technique
described in Sect.~\ref{literature}. This approach does not work for the $\vdf$s that
needs no proof e.g., the isogenie-based $\vdf$~\cite{Feo2019Isogenie}. Labelling the $i$-th node
in the $\rSVL$ graph with $\eval(\pp,x,i)$ for $i \le T$, needs $T$ different computation 
of $\eval$ for each $i$ as $\X \ne \Y$. We tackle this problem in the following theorem
using a special function $f$.

\begin{theorem}{\normalfont \textbf{($\rSVL$ is $\VDF$-hard).}}\label{thm:hardness}
For the parameters $\lambda\in \Z^+$ and $T=T(\lambda) \in 2^{o(\lambda)}$, let 
$(\setup, \eval,\mathsf{Open}, \verify)$ be an interactive $\vdf$ on
 the domain $\X=\{0,1\}^*$ and the range $\Y=\{0,1\}^\lambda$. Then
there exists a hard distribution of $\rSVL$ instances
$\{\S,\V,v,T\}_{v\in\{0,1\}^\lambda}$  
that have at most polynomially many (i.e., $\poly(\lambda)$) false positive vertices, such that
$\S : \{0,1\}^\lambda \rightarrow \{0,1\}^\lambda$, $\V : \{0,1\}^\lambda \times \{1,
\ldots, T\}\rightarrow \{0,1\}$ 
and $x\in\{0,1\}^\lambda$. 
\end{theorem}

\begin{proof}
Given any $\lambda\in \Z^+$ and any $T \in 2^{o(\lambda)}$,
we derive a hard distribution of $\rSVL$ instances, $\{\S,\V,v,T\}_{v\in\{0,1\}^\lambda}$ 
from a $\vdf$, as follows,

First, we define a function $f$ as,
$$f(\eval(\pp,x,T=0),i)=\eval(\pp,x,i) \qquad \forall i \le T.$$

The function $\eval(x,T=0)$ maps $x$ into the range $\Y$.
\begin{description}
\item [The $\S$ circuit] 
We observe that, for every $\vdf$,
$\eval(\pp,v,T)=f(v,T)=f(f(v,T-1))$ with the base case $v=\eval(\pp,x,0)$. 
This vertex $v$ is the source in the $\rSVL$ instances. 
Therefore, we keep $\S(u)=f(\pp,u,T=1)$. In particular, 

\begin{algorithm}
\caption{$\S(u)$ from $\eval$}\label{alg:eval}
\begin{algorithmic}[1]
\STATE $y:=f(\pp,u,1)$
\RETURN $y$.
\end{algorithmic}
\end{algorithm}

More generally, $\S^i(v)=f(\pp,v,i)$ for all $i \le T$.

\item [The $\V$ circuit] 
This circuit is same as in the previous theorem. 
In particular, 
\begin{algorithm}[H]
\caption{$\V(v,T)$ from $\eval$}\label{alg:verify}
\begin{algorithmic}[1]
\STATE $\pi:=\mathsf{Open}(\pp,v,y,T)$
\STATE $w:=\verify(\pp,v,y,T,\pi)$.
\RETURN $w$
\end{algorithmic}
\end{algorithm}

 Since, $\mathsf{Open}$ takes at most $\poly(\lambda, \log
T)$-rounds, $\V$ is efficient.
\end{description}

\end{proof}




% \section{$\PSPACE$-hardness}
% 
% Although the definitions of $\IP$ and $\VDF$ appear quite similar, 
% the key differences are,
% \begin{enumerate}
% \item $\IP$ does not demand for sequentiality. In fact, one of the most elegant $\IP$,
% the sumcheck protocol for $\mathsf{UNSAT}$ is known to be parallelizable in nature. The
% sumcheck protocol asks $\prv$ to compute the sum $\sum_{z\in \{0,1\}^n}f(z)=y$ of
% polynomial $f$ of small degree. Therefore, $y$ can be computed in $2^{\O(n)}$-time
% sequentially but in $\O(2^n/\Gamma)$-time parallelly when $\prv'$ has $\Gamma$ number of
% parallel processors. As $\IP$ allows a malicious prover $\prv'$ to have unbounded
% computational power (so processors), sequentiality can not be achieved against $\prv'$. 
% 
% \item $\IP$ demands for statistical soundness i.e., no prover
% has non-negligible advantage to convince $\vrf$ with a false proof. 
% On the contrary, $\VDF$ asks for computational soundness only
% i.e., no prover running in $\poly(\lambda,T)$-time has non-negligible
% advantage. As we see, statistical soundness implies computational soundness. 
% \end{enumerate}
%  
% These two observations together imply that $\vdf$s are special kind of interactive
% proofs that are sequential but with a bit relaxed notion of soundness.  
% 
% % We observe that $\adv$ is allowed to have at most subexponentially many processors as $T
% % \in 2^{o(\lambda)}$. Intuitively, a subexponentially parallel prover 
% % should not recognize larger (or even equal) set of languages that can be done by an unbounded prover.
% % Thus $\VDF \subseteq \IP$ as the only difference between them is that 
% % $\IP$ deals with computationally unbounded prover (maybe an infinite state machine) 
% % where as in case of $\VDF$ the (malicious) prover may have at most subexponential parallelism. 
% % It is clear that $\VDF \subseteq \PSPACE$ with the intuition that the class $\IP$
% % conceives the languages that can be provable by even computationally unbounded provers
% % while $\VDF$ is the class of languages that can be provable by some parallel prover with
% % $\poly(\lambda,\log T)$ parallelism. 
% % 
% % More specifically, by the Theorem \ref{thm : PTM} (Theorem 15 in cf. \cite{Worsch1993Parallel})
% % the languages recognized by a $\PTM$ in time $\O(t)$ time and $\O(s)$ space using
% % $\O(h)$ processors can also be recognized by a $\TM$ in $\O(t\sqrt{sh})$ time and
% % $\O(s)$ space. First we observe that $\poly(\lambda, \log T)=\poly(\lambda)$ as 
% % $T \in 2^{o(\lambda)}$. Then a $\poly(\lambda, \log T)$ prover is basically a $\PTM$
% % having $\poly(\lambda)$ processors operating on $\poly(\lambda)$ space. Thus plugging
% % $\poly(\lambda)$ space and processors in the Theorem 15 (in cf.\cite{Worsch1993Parallel}) 
% % we get that the parallel adversaries in $\VDF$ are actually $\TM$s having $\poly(\lambda)$ space
% % running for $\poly(T)$ time. Clearly these adversaries are less powerful than that in
% % interactive proof system. 
% Therefore, the proof for $\VDF \subseteq \IP = \PSPACE$ is straightforward. 
% 
% \begin{theorem}
%  $\VDF \subseteq  \PSPACE$.
% \end{theorem}
% \begin{proof}
% % By Def.~\ref{VDF}, $\VDF \subseteq \IP$. We know that $\IP=\PSPACE$ \cite{ShamirIP}. 
% % Moreover, 
% An honest prover $\prv$ needs to run for time $T$ 
% to decide if a tuple $(x,y,T)\in\L$ for all $\L\in \VDF$.
% By lemma.~\ref{subexp}, $T$ can be at most $2^{o(\lambda)}$. 
% By lemma.~\ref{halttime}, a $\TM$ with $S$-space may run for $|Q|S2^S$-time.
% Therefore, a $\TM$ with even $o(\lambda)$-space suffices to decide $\L$. 
% Hence, $\VDF \subseteq \PSPACE$.
% 
% \end{proof}
% 
% 
% The standard way to prove $\PSPACE \subseteq \VDF$ is to derive a $\vdf$
% from a $\PSPACE$-complete language~\cite{ShamirIP}. Existence 
% of such a $\vdf$ would imply that there is an inherently sequential 
% $\PSPACE$-complete problem whose solution is sound also.
% We claim that such a $\PSPACE$-complete problem that commits 
% sequentiality and soundness together, hardly exists. We present two flawed $\vdf$s
% in order to show this.
% 
% 
% \subsection{A Sound But Non-sequential Approach}
% Our goal is to check if a statistically sound interactive proof evokes a $\vdf$.
% Thus, following~\cite{ShamirIP}, we attempt to derive a $\vdf$ from $\TQBF$. 
% 
% \begin{definition}{\normalfont (\textsc{True-Quantified-Boolean-Formula} $\TQBF$).}
% Let, $\Psi=Q_1x_1,\ldots Q_nx_n \phi(x_1, \ldots, x_n)$ be a quantified Boolean formula
% of $n$ variables and $m$ clauses such that all $Q_i \in\{\exists, \forall\}$ and $\phi$ is in 3-CNF
% (w.l.o.g.). The language $\TQBF$ is defined as the set of all quantified Boolean 
% formula that are true. Formally,
% 
% $$ \TQBF = \{\Psi(x_1, \ldots, x_n)=1 \}.$$
% \end{definition}
% 
% \subsubsection{Sumcheck Protocol for $\TQBF$}
% 
% We summarize the sumcheck protocol for $\TQBF$ from~\cite{ShamirIP}.
% 
% Given a quantified Boolean formula (QBF) $\Psi$, first we arithmetize $\Psi$ to obtain
% a polynomial $f$ as follows, 
% \begin{enumerate}
% \item $\forall x_n \phi(x_1,\ldots, x_n)$ evaluate $\prod_{x_n\in \{0,1\}} f(x_1,\ldots, x_n)$.
% \item $\exists x_n \phi(x_1,\ldots, x_n)$ evaluate $\sum_{x_n\in \{0,1\}} f(x_1,\ldots, x_n)$. 
% \end{enumerate}
% Thus, a QBF $\Psi=\forall x_1 \exists x_2 \ldots \forall x_n \phi(x_1,\ldots, x_n) \in \TQBF$ 
% if and only if 
% $h(x_1,\ldots, x_n)=\prod_{x_1\in \{0,1\}} \sum_{x_2\in \{0,1\}} \ldots \prod_{x_n\in \{0,1\}} f(x_1,\ldots, x_n) \ne 0$. 
% As $\phi$ is in 3-CNF, degree of $f$ 
% is $\O(n^3)$.But, due to the presence of $\prod$ operator in $h$, its degree and number
% of coefficients can be $\O(2^n)$ in the worst-case.
% 
% It is resolved with the observation that $x^k=x$ for all $k \ge 1$ as $x\in\{0,1\}$. It
% allows to define a linearization operator $L_n$ as follows,
% $$ L_n f(x_1,\ldots, x_n)=x_n\cdot f(x_1,\ldots, x_{n-1},1)+(1-x_n)\cdot f(x_1,\ldots, x_{n-1},0).$$ 
% Thus, in order to keep the degree and size of $h$ in $\poly(n)$, we sprinkle the
% linearization operators in between $h$ as,
% $$h'=\prod_{x_1\in \{0,1\}}L_1 \sum_{x_2\in \{0,1\}} L_1 L_2
% \prod_{x_3\in \{0,1\}} \ldots \prod_{x_n\in \{0,1\}}L_1 L_2 \ldots L_n  f(x_1,\ldots, x_n).$$
% The size of $h'$ is $\O(n^2)$ as there are exactly $n(n+3)/2$ operators. 
% 
% The sumcheck protocol for $\TQBF$ asks the prover $\prv$ to prove that 
% $h'(x_1,\ldots, x_n)=y \ne 0 \mod{p}$ for a prime $p \ge 2^n 3^m$ in at most
% $n(n+3)/2$-rounds. In each round, $\prv$ strips one operator.
% Let us denote the operator before $x_i$ in $h'$ with $\otimes_i \in
% \{\prod_i,\sum_i, L_i\}$. The protocol is defined recursively as follows,
% 
% Suppose the partial sum of $h'(r_1, r_2, \ldots, r_{i-1}, x_i,\ldots x_n)=y'$
% where $r_j$ is chosen from the finite field $\F_p$ uniformly at random. For all $i$,
% \begin{description}
% \item [Case 1:] If $\otimes_i = \sum_{x_i}$ then $\prv$ sends a univariate polynomial
% $s(x_i)=h'(r_1, r_2, \ldots, r_{i-1}, x_i,\ldots, x_n)$. The verifier $\vrf$ rejects if
% $s(0)+s(1) \ne y'$, otherwise asks $\prv$ to prove in the next round that 
% $s(r_i)=h'(r_1, r_2, \ldots, r_{i-1}, r_i,x_{i+1},\ldots, x_n)$ for some $r_i \in_R \F_p$.
% 
% \item [Case 2:] If $\otimes_i = \prod_{x_i}$ Exactly same as case (1) except that $\vrf$ 
% rejects if $s(0)\cdot s(1) \ne y'$ instead of $s(0)+s(1)\ne y'$.
% 
%  
% \item [Case 3:] If $\otimes_i = L_{x_i}$ then $\prv$ sends a univariate polynomial
% $s(x_i)=h'(r_1, r_2, \ldots, r_{i-1}, x_i,\ldots, x_n)$. The verifier $\vrf$ rejects if
% $r_i\cdot s(0)+(1-r_i)\cdot s(1) \ne y'$, otherwise asks $\prv$ to prove in the next round 
% that $s(r_i)=h'(r_1, r_2, \ldots, r_{i-1}, r_i,x_{i+1},\ldots, x_n)$ for some 
% $r_i \in_R \F_p$.
% \end{description}
% 
% \begin{lemma}
%  For all adversaries $\adv$ even with computationally unbounded power the probability the $\vrf$
%  accepts a false $y \ne h'(x_1,\ldots, x_n)$ is at most $\frac{3mn+n^2}{p}$.
% \end{lemma}
%  
% \begin{proof}
% For case (1) and (2), the degree of the polynomial $s(x_i)$ is $1$ as $L_{x_i}$s
% linearize $s$. For case (3), the degree of $s(x_i)$ can be at most $2$.
% 
% By Schwartz-Zippel lemma, every two distinct univariate polynomials of degree 
% $\le d$ over a field $\F$ agree in at most $d$ points. So, the probability that $\vrf$
% accepts a wrong $y$ has this two components,
% \begin{enumerate}[label=\roman*.]
% \item For the inner $L_{x_i}$, this probability is $\le \frac{2}{p}$.  
% \item For the final $L_{x_i}$, this probability is $\le \frac{3m}{p}$.  
% \end{enumerate}
% 
% Therefore, by the union bound, the total probability that $\vrf$ accepts a wrong $y$
% is at most,
% 
% $$ \frac{n}{p} + \frac{3mn}{p} + \frac{2}{p}\sum_{i=1}^{n-1} i= \frac{3mn+n^2}{p}.$$ 
% 
% \end{proof}
% 
% \subsubsection{Argument Against Sequentiality}
% Although $\TQBF$ raises an interactive proof with statistical soundness, we are not sure
% if it admits a subexpoentially long sequential computation too. The reason is that the
% maximum number of sequential steps required to evaluate $h'$ in the worst-case is the
% number of operators in it i.e., $n(n+3)/2$. So, in order to setup a $\vdf$ for
% sequential time $T$, it needs to sample a QBF of length $\Omega(\sqrt{T})$ as the public
% parameter. To support efficient execution in practice, cryptographic protocols should allow
% polynomially long public parameters only. Therefore, such a $\vdf$ may work for 
% $T \in\poly(\lambda)$ but not for $T \in 2^{o(\lambda)}$.
% 
% \subsection{A Sequential But Unsound Approach}
% In this section, we present another wrong attempt to derive a $\vdf$ which turns out to
% be sequential but not computationally sound.
% 
% \begin{definition}{\normalfont \textbf{($\HALT)$.}}
% Suppose $M$ is a Turing machine, $x\in\Sigma^*$ is an input string and $S\in\mathbb{N}$.  
% The language $\HALT$\footnote{See $\mathsf{SPACE\; TMSAT}$ (cf. Def. 4.9)
% in \cite{Arora2009Modern}.} is the
% set of all the tuples $(\langle M \rangle, x, 1^S)$  
% such that the $\TM$ $M$ halts on input $x$ in space $S$. Formally, 
% $$\HALT = \{ (\langle Q,F,\delta \rangle ,x,1^S) \mid
% (q_0,x,0)\xrightarrow{*}(q_F,y,n)\text{ in space } S\}.$$
% \end{definition}
% 
% \begin{lemma}\label{haltcomp}
%  $\HALT$ is $\PSPACE$-complete.
% \end{lemma}
% \begin{proof}
% We show that any language $\L \in \PSPACE$ is reducible to $\HALT$ in polynomial-time.
% Suppose $\L \in \PSPACE = \DSPACE (\poly(n))$ is decided by a $\TM$ $M$.
% Then the function $f(x)=(\langle M  \rangle, x, 1^{\poly(\mid x \mid )})$
% is a polynomial-time reduction from $\L$ to $\HALT$. 
% \end{proof}
% 
% \begin{lemma}\label{haltseq}
% If time-lock puzzle is inherently sequential then $\HALT$ is inherently sequential.
% \end{lemma}
% \begin{proof}
% We prove this by contradiction.
% Suppose $(\langle M \rangle, x, T)\in \HALT$ and we parallelize the simulation of $M$ 
% with another $\TM$ $\widehat{M}$. Then any $\TM$ that decides a language $\L \in \PSPACE$ must be parallelizable
% using the $\TM$ $\widehat{M}$. Then it means that there exists no inherently sequential
% language in $\PSPACE$. But we already know the existence of languages
% (e.g., time-lock puzzle \cite{Rivest1996Time}) which is
% sequential but can be evaluated in polynomial space.
% % $\NC = \PSPACE$ which is a contradiction.i
%  
% \end{proof}
% 
% 
% \begin{lemma}\label{halttime}
%  $\HALT$ is decidable in at most $|Q|S2^S$ time.
% \end{lemma}
% \begin{proof}
% There are $2^S$ different strings that could appear in the work tape of $M$.
% The head could be in any of $S$ different places and the $M$ could be
% in one of $|Q|$ different states. So the total number of configurations is
% $|Q|S2^S$. 
% 
% \end{proof}
% By the pigeonhole principle, if $M$ is run for further steps, it must visit
% a configuration again resulting into looping.
% We design a $\vdf$ from the language $\HALT$.
% % \begin{theorem}
% %  $\PSPACE\nsubseteq \VDF$.
% % \end{theorem}
% % \begin{proof}
% % First, we give a $\vdf$ based on the $\HALT$ (See Sect.~\ref{haltvdf}). 
% % By lemma \ref{haltcomp}, every language in $\PSPACE$ reduces 
% % to $\HALT$ in polynomial time. Thus, every language in $\PSPACE$ supposed to have
% % a $\vdf$. But, Theorem.~\ref{thm : smart} gives an adversary that breaks the soundness
% % of this derived $\vdf$. Hence, $\PSPACE \nsubseteq \VDF$.
% %   
% % \end{proof}
% 
% \subsubsection{$\vdf$ From $\HALT$}\label{haltvdf}
% The design of this $\vdf$ is based on two 
% fundamental observations on Turing machines. 
% \begin{itemize}
% \item the running time $T$ of $M$ having $S$ space is bounded by $|Q|S2^S$ 
% (by lemma.~\ref{halttime}).
% \item $M$ continues to stay within the set of halting states 
% (either accepting or rejecting) once it reaches at one of them.
% \end{itemize}
% 
% We specify the algorithms for $\vdf$s as follows,
% \begin{description}
% \item [$\setup(1^\lambda, T)\rightarrow \pp$]
%  It samples a Turing machine, $M=(Q,F,\delta)$ such that
%  $2^{\Omega(\lambda)} \le  |Q| \le 2^{\poly(\lambda)}$ and
%  $|F| \le \poly(\lambda)$. Although the description of $M$ 
% is exponentially large, it suffices to provide $\delta$ as a $\poly(\lambda)$-size
% circuit that outputs the next state $q_{i+1}$ on an input $q_i$. Without loss of
% generality, we assume an encoding $Q=\{0,1\}^{\lceil \log |Q| \rceil}$ with 
% the implicit initial state $q_0=0^{\lceil \log |Q| \rceil}$.
% 
% \item[$\eval(x, \pp)\rightarrow (y,\pi)$]
% The prover $\prv$ computes the $T$-th state $q_T$ of $M$ on the input $x$ starting from
% the initial state $q_0$ and sends it to the verifier $\vrf$. Formally,
% $q_T:=\delta^T(q_0,x)$. Now, $\vrf$ asks $\prv$ to provide another state $q_t$ from this
% sequence of states $q_0, \delta(q_0), \ldots, \delta^T(q_0)$ such that $(T-t) \le
% \lambda$. With $q_t$, $\vrf$ also asks for the tape content $z$ of $M$ at time $t$.
% 
% 
% \begin{algorithm}
% \caption{$\eval$ from $\HALT$}\label{alg:eval}
% \begin{algorithmic}[1]
% \STATE  $(q_0,x,0)\stackrel{T}{\rightarrow}(q_T,y,n)$. 
% \STATE Obtains $t \ge T -\lambda$ from $\vrf$. 
% \STATE $(q_0,x,0)\stackrel{t}{\rightarrow}(q_{t},y_{t},n_{t})$.
% \STATE Initialize a string $z:=y_{t}[n_{t}]$.
% \FOR  {$t \le  i \le T$}
% \STATE  $(q_{i},y_{i},n_{i})\stackrel{1}{\rightarrow}(q_{i+1},y_{i+1},n_{i+1})$.
% \STATE  $z:=z \| y_{i+1}[n_{i+1}]$.
% \ENDFOR
% \STATE $y:=q_T$
% \STATE $\pi:(q_t,z)$
% \RETURN $(x,y,T,\pi)$
% \end{algorithmic}
% \end{algorithm}
% % The output $\phi = q_T$ and the proof $\pi=(q_{T-t},z)$. Observe that 
% % $(q_{T-t},z,0)\stackrel{t}{\rightarrow}(q_T,y,n)$ as $z$ is the 
% % tape content that $M$ reads in $t$ moves to reach state $q_T$ from $q_{T-t}$. 
% % Theorem~\ref{thm : soundness} shows that $\HALT \le_p \eval$.
% % It is a polynomial time reduction as $|F|=2^{\O(\log n)}$.
% 
% \item[$\verify(x, \pp, \phi, \pi)\rightarrow \{0,1\}$]
% Using $\verify$, $\vrf$ checks if $y=q_T$ in $(T-t) \le \lambda$ steps, as follows,
% 
% \begin{algorithm}
% \caption{$\verify$ for $\HALT$}\label{alg:verify}
% \begin{algorithmic}[1]
%  \STATE $(q_{t},z,0)\stackrel{T-t}{\rightarrow}(q_T,y,n)$.
%  \IF {$y=q_T$}
% 	\RETURN 1;
%  \ELSE 
% 	\RETURN 0; 
%  \ENDIF
% \end{algorithmic}
% \end{algorithm}
% \end{description}
% 
% 
% 
% \subsection{Efficiency}
% Here we discuss the time and the memory required by the prover and the verifier.
% \begin{description}
%  \item [Proof Size] The output $\phi=q_T$ needs $\log |Q|$-bits where 
%  $\lambda \le \log |Q| \le \poly(\lambda)$. The proof $\pi=(q_{T-t},z)$ 
%  requires $\log |Q|+t$-bits as $|z|=t$.
%  
%  \item [$\prv$'s Effort] $\prv$ needs $T$ time to find $q_T$, then $T-t$ time to find $q_{T-t}$ and 
%  finally $t$ time to find $z$. By the Theorem~\ref{thm : seq} it requires $2T$ time in total.
%  
%  \item [$\vrf$'s Effort] $\vrf$ needs only $t$ time to find $q_T$ from $q_{T-t}$ using $z$. 
% Deciding $q \in F$ is already shown to be efficient.
% \end{description}
% 
% \section{Security}
% We claim that the derived $\vdf$ is correct and sequential but not sequential.
% 
% \begin{theorem}
%  The constructed $\vdf$ is correct.
% \end{theorem}
% 
% \begin{proof}
%  If $\prv$ has run $\eval$ honestly then $(q_0,x,0)\stackrel{T}{\rightarrow}(q_T,y,n)$.
%  The integer $t$ is solely determined by the input statement $x$ and the output $q_T$. 
%  Thus $\vrf$ will always find $y=q_T$ by computing $(q_{t},z,0)\stackrel{T-t}{\rightarrow}(q_T,y,n)$. 
% \end{proof}
% 
% % \begin{theorem}\label{thm : soundness}
% %  If there is an adversary $\adv$ breaking the soundness of this $\vdf$ with the probability $p$ then 
% %  there is a Turing machine $\adv'$ that decides the language $\HALT$ with the same probability.
% % \end{theorem}
% % 
% % \begin{proof}
% % The task of $\adv'$ is to decide if a tuple $(M,x,1^S) \in \HALT$ or not using the
% % $\adv$. In particular, given $(M,x,1^S)$,
% % $\adv'$ needs to find the public parameters $\pp$ and $T$ on which running $\adv$
% % against $x$ helps $\adv'$ to decide the tuple.
% % 
% % $\adv'$ notices that, 
% % \begin{enumerate}[label=\roman*.]
% % \item the running time of $M$ having $S$ space is bounded by $|Q|S2^S$ (see lemma
% % \ref{halttime}).
% % \item $M$ continues to stay in the halting states 
% % (either accepting or rejecting) once it reaches there.
% % \end{enumerate}
% % 
% % So $\adv'$ does not need to know the exact time to decide $(M,x,1^S)$
% % but $T$ must be sufficient to do the same. Therefore, $T \ge |Q|S2^S$ 
% % serves the purpose of $\adv'$ because
% % running $\adv$ for longer than the time to decide the tuple $(M,x,1^S)$ 
% % does not alter the decision on the same.
% %  
% % Thus, given a string $(M,x,1^S)$, $\adv'$ finds a $\lambda$ and a $T$ such that,
% % \begin{enumerate}
% % \item $T=2^{\lambda^{k}}\ge |Q|S2^S$ for some $k<1$ as $T\in 2^{o(\lambda)}$.
% % \item $\lambda \le \log |Q| \le \poly(\lambda)$ as required in $\setup$.
% % \end{enumerate}
% % 
% %  $\adv'$ notices that the $\setup$ is efficient and public algorithm.
% %  So $\adv'$ runs the $\setup(1^\lambda,T)$ to obtain the public parameters $\pp$
% %  and passes the tuple $(x,\pp,T)$ to $\adv$. When $\adv$ outputs $(q,\pi)$,
% %  $\adv'$ checks if $q \in F$ or not and decides the string $(M,x,1^S)$.
% %  Observe that deciding $q \in F$ is efficient as $|F| \in \poly(\lambda)$.
% %  % $\verify(x,q,\pi,\pp,)=1$ and decides the string $(M,x,1^S)$.
% %  
% % As $\adv$ breaks the soundness of this $\vdf$ with the probability $p$, 
% % must be as large as the time
% % to accommodate all the computations that can be done within the space $S$. 
% % $\adv'$ decides $\HALT$ with the probability $p$.
% % \end{proof}
% 
% 
% \begin{theorem}\label{thm : seq}
%  If there is an adversary $\adv$ breaking the sequentiality of this $\vdf$ with the probability $p$ then 
%  there is a Turing machine $\adv'$ breaking the sequentiality of the language $\HALT$ with the same probability.
% \end{theorem}
% 
% \begin{proof}
%  Suppose a $\TM$ halts on input $x$ in space $S$ and in time $T \le |Q|S2^S$.
%  Thus to decide if the string $ ( M,x,1^S ) \in \HALT$ in time $<T$,
%  $\adv'$ passes it to $\adv$ that runs in time $<T$. 
%  When $\adv$ outputs $(q_T,\pi)$, $\adv'$ checks if
%  $q_T \in F$ or not and decides the string $(M,x,1^S)$.
%  Observe that deciding $q_T \in F$ is efficient as $|F| \in \poly(\lambda)$.
%  
%  As $\adv$ breaks the sequentiality of this $\vdf$ with the probability $p$ so $\Pr[q_T \in F]=p$. 
%  Hence $\adv'$ decides $\HALT$ in time $<T$ with the probability $p$ violating the sequentiality of $\HALT$.
% \end{proof}
% 
% While everything seems perfect in the above construction of the $\vdf$, there exists an
% adversary that breaks the soundness of this $\vdf$ \emph{certainly}. 
% 
% \begin{theorem}\label{thm : smart}
% There exists an adversary $\adv$ who breaks the soundness of the $\vdf$ derived from
% $\HALT$.
% \end{theorem}
% 
% 
% \begin{proof}
% The key observation made by $\adv$ is that the verifier $\vrf$ never checks if the state
% $q_{t}$ in proof $\pi$ has correctly been computed starting from the state $q_0$ in
% $t$-steps. However, $\adv$ knows that the maximum distance from the state $q_{t}$ and
% $q_T$ is upper-bounded by $\lambda$.
% 
% Therefore, $\adv$ chooses an arbitrary configuration $\alpha$ of $M$. (S)he never runs
% $\eval$. Rather, by simulating $M$, (s)he computes another configuration $\alpha \xrightarrow{\lambda}
% \beta$ remembering the sequence of all the states and the scanned input symbols in these $\lambda$ steps. 
% This can be done efficiently as $Q$ can be encoded using only $\poly(\lambda)$-bits. 
% Suppose, the sequence of states and the scanned symbols are denoted as $\mathcal{Q}$ and $\mathcal{Z}$.
% Observe that $|\mathcal{Q}|=|\mathcal{Z}|=\lambda$. 
% Finally, $\adv$ announces the state in the configuration $\beta$ as the
% output $q_T$
% 
% 
% When $\adv$ obtains the offset $t$ from $\vrf$, 
% $\adv$ fixes the $q_{t}:=\mathcal{Q}[t-\lambda-1]$ and
% $z:=\mathcal{Z}[t-\lambda-1, \ldots, \lambda]$. Essentially, $\adv$ sets the
% $(t-\lambda)$-th state in $\mathcal{Q}$ as the state $q_{t}$ in the proof $\pi$. 
% Similarly, the tape content $z$ in $\pi$ is the sequence of last $(T-t)$ symbols in 
% $\mathcal{Z}$. 
% 
% Clearly, $\vrf$ will be convinced as $(q_{t},z,0)\xrightarrow{T-t}(q_T,z',n)$.
%  
% 
% \end{proof}
% % \begin{theorem}\label{thm : seq}
% %  If the number of states $|Q| < 2^{\Omega(\lambda)}$ in $M$
% %  then there is an adversary $\adv$ breaking the sequentiality of
% %  this $\vdf$ with non-negligible probability.
% % \end{theorem}
% % 
% % \begin{proof}
% %  $\adv$ observes that $\vrf$ never verifies the correctness of either the output $q_T$ or the
% %  tape content $z$ in the proof $\pi$. Rather, $\vrf$ checks only if $q_T$ and $\pi$ are
% %  consistent with each other. So, $\adv$ adopts the same strategy described in lemma
% % \ref{subexp}. 
% % 
% %  Given the public parameters $\pp=(M,\RO)$, $\adv$ chooses an arbitrary state $q
% % \in Q$ as the output $\phi$ and the (partial) tape content $z \in \{0,1\}^t$ uniformly at random. 
% %  Receiving upon $t$, $\adv$ only needs to find
% %  a state $q'$ such that $(q',z,0)\stackrel{t}{\rightarrow}(q,y,n)$.
% %  In order to do this, $\adv'$ brute-force the entire $Q$ using
% %  $\poly(T)$ processors; each initialized with different $q'_i \in Q$.
% %  As $t <\lambda$, finding $q'$ parallelly is efficient. 
% %  
% %  Thus the advantage of $\adv$ is at most $\poly(T)/|Q|$. We know that $T \in
% %  2^{o(\lambda)}$, thus the advantage of $\adv$ becomes non-negligible in $\lambda$ 
% %  when $|Q|<2^{\Omega(\lambda)}$.
% % 
% % \end{proof}
% 
% 
% \subsubsection{Argument Against Soundness} Theorem.~\ref{thm : smart} suggests that the
% $\vdf$ is not computationally sound, however, is sequential for any $T \in 2^{o(\lambda)}$.
% This argument can be supported with an informal claim that if such a sequence of states
% can be verified efficiently with soundness then a chain of hashes (i.e., $\RO^T(x)$) may
% also raise $\vdf$s. Unfortunately, we do know no efficient verification algorithm
% for hash-chains.
% 
% \section{Frequently Asked Questions}
% In this section, we would like to clear some obvious confusions in our results. 
% 
% \begin{itemize}
% 
% \item [Q.1)] Does Lemma.~\ref{haltseq} suggest that every problem in $\PSPACE$
% is inherently sequential?
% 
% \item [A.1)] Yes and no both. Because our interpretation of this theorem is that we call
% a problem inherently sequential as long as we do not know an efficiently parallelizable
% for the same. For example, the time-lock puzzle or the isogenies over the super-singular 
% curves. Similarly, having a parallel algorithm for a problem does not really deny the
% chance of having another sequential algorithm for the same. Because a parallelizable
% language in $\PSPACE$ also reduces to $\HALT$. So, we believe that every language in
% $\PSPACE$ has sequential algorithm and parallelizable algorithm together. 
% 
% 
% \item [Q.2)] Does the answer A.1 suggest that problems in $\P$ can also be used to
% derive $\vdf$?
% 
% \item [A.2)] Yes. Because, the key observation is that the definition of $\vdf$ imposes an upper bound on
% $T \le 2^{o(\lambda)}$ but not the lower bound. For arbitrarily small $T$ , the computation can not
% be arbitrarily hard. For all $T \le \poly(\lambda)$, the hardness can not be beyond $\P$.  In
% principle, we need sequentially hard problems rather than the computationally hard
% problems to derive VDFs.
% 
% For example, circuit value problem (CVP) is known to be a P-complete problem. 
% The algorithm that solves CVP is efficient but is sequential also as we do not know faster parallel algorithm. 
% So, $\vdf$s derived from $\P$-complete problems should work for all $T \in \poly(\lambda)$.
% 
% \item [Q.3)] The $\vdf$ derived in Sect.~\ref{haltvdf} uses a random oracle $\RO$ in
% $\eval$ and $\verify$. Does it mean that all the subsequent claims are relative to
% a random oracle?
% 
% \item [A.3)]
% The definitions of the class $\VDF$ [Def. 19] and the interactive $\vdf$s [Def. 18] are
% independent of any random oracle. As the class VDF is defined to be the set of
% interactive VDFs, this result is not relative to any random oracle. It could have been
% only if the class $\VDF$ was defined to be the set of non-interactive VDFs.
% 
% The random oracle $\RO$ is required only in the non-interactive version of this $\vdf$ 
% as per the FiatShamir heuristic, but not in the interactive VDF. We have explicitly
% mentioned how the verifier replaces the random oracle $\RO$ in the interactive version  
% in the descriptions of each algorithm $\setup$, $\eval$ and $\verify$.
% Still the interactive version satisfies all the security proofs in Sect.~\ref{ivdf} which are
% also independent of any random oracle.
% 
% 
% % \item [Q.4)]  Can we use the adversary stated in Theorem. \ref{thm : smart} upon
% % a $\vdf$ practically?
% % 
% % \item [A.4)] Yes. Here we give an attacker $\adv_w$ that breaks the soundness of the non-interactive version of 
% % Wesolowski's $\vdf$ with the probability $1/\ell$ where $\ell$ is the sampled prime.
% % Two important observations relevant to this attack are,
% % \begin{enumerate}
% %  \item The sampled prime $\ell:=\RO_{\texttt{prime}}(\texttt{bin}(g)|||\texttt{bin}(y))$
% %  is independent of the delay parameter $T$. So the prover may claim that $y=g^{2^T}$ for any arbitrary values of $T$.
% %  \item The equivalence $y=\pi^\ell\cdot g^r$ implies $y=g^{2^T}$ if and only if  
% %  $\pi=g^{\lfloor 2^T/\ell \rfloor}$ which is never verified by the verifier.
% % \end{enumerate}
% % 
% % Thus, $\adv_w$ chooses a small ($2\lambda+1$-bit suffices in this context) number 
% % $\tau$ and computes $y=g^\tau$. Then (s)he samples the prime $\ell$ in order to compute 
% % $\pi=g^{\lfloor \tau/\ell \rfloor}$. Now (s)he finds a number $T>\log_2 \tau$ such that 
% % $\tau \mod{ \ell}=2^T \mod{ \ell}$. 
% 
% % In particular $\adv_w$ runs Alg. ~\ref{alg:wes}.
% 
% % \begin{algorithm}
% % \caption{Serial adversary $\adv_w$ for Wesolowski's $\vdf$}\label{alg:wes}
% % \begin{algorithmic}[1]
% %  \STATE $g:= \RO_\mathbb{G}(x)$
% %  \STATE $\tau\in_R \Z_{2^{(2\lambda+1)}}\setminus \Z_{2^\lambda}$ \hfill //
% % uniformly randomly
% %  \STATE $y:=g^{\tau}$
% %  \STATE $\ell:=\mathsf{H}_{\texttt{prime}}(\texttt{bin}(g)|||\texttt{bin}(y))$
% %  \STATE $\pi:=g^{\lfloor \tau/\ell \rfloor}$
% %  \STATE $T := \lceil \log_2 \tau\rceil$
% %  \WHILE {$(\tau \mod{\ell}\ne 2^T \mod{\ell})$} \STATE $T:= T+1$
% %  \ENDWHILE
% % \RETURN $T$
% % \end{algorithmic}
% % \end{algorithm}
% 
% % $\adv_w$ announces the tuple $(x,G,y,\pi,T)$ to get verified.
% % The verifier will find that, 
% % 
% % $$\pi^\ell \cdot g^{2^T \mod{\ell}}=\pi^\ell \cdot g^{\tau \mod{\ell}}=
% % (g^{\lfloor \tau/\ell \rfloor})^\ell g^{\tau \mod{\ell}}=y.$$
% % 
% % For any arbitrary $T$, $\adv_w$ succeeds with probability,
% % $$\Pr[\adv_w \; \text{wins}]=\Pr[\tau \mod{\ell}=2^T \mod{\ell}]=1/\ell.$$
% % Inclusion of $T$ in $\ell:=\mathsf{H}_{\texttt{prime}}(\texttt{bin}(g)|||\texttt{bin}(y)|||\texttt{bin}(T))$ 
% % requires $\adv_w$ to include only this sampling of $\ell$ within the while loop incurring the same 
% % success probability $1/\ell$. Thus the expected number of iterations to find such a $T$ is $\O(\ell)$.
% 
% \item [Q.5)] Do the flawed attempts to derive $\vdf$s suggest 
% that no problems in $\PSPACE$ can be used to derive $\vdf$s?
% 
% \item [A.5)] No. They suggest that all problems in $\PSPACE$ do not have
% subexpoentially long sequentiality and computational soundness together.
% Time-lock puzzle probably one among such rare problems that has both the properties. 
% In particular, Pietrzak's $\vdf$~\cite{Pietrzak2019Simple} is known 
% to be statistically sound and, of course, sequential. It is derived from time-lock
% puzzle. Hence, these flawed attempts actually introduce the notion a subclass $\VDF$ 
% full of such special problems within $\PSPACE$.
%  
% 
% 
%   
% 
% \end{itemize}


\bibliographystyle{splncs04}
%\bibliography{ref}
\begin{thebibliography}{10}
\providecommand{\url}[1]{\texttt{#1}}
\providecommand{\urlprefix}{URL }
\providecommand{\doi}[1]{https://doi.org/#1}

\bibitem{Valiant}
Abbott, T., Kane, D., Valiant, P.: On algorithms for nash equilibria.
  Unpublished manuscript  (2004),
  \url{https://web.mit.edu/tabbott/Public/final.pdf}

\bibitem{Babai88AM}
Babai, L., Moran, S.: Arthur-merlin games: {A} randomized proof system, and a
  hierarchy of complexity classes. J. Comput. Syst. Sci.  \textbf{36}(2),
  254--276 (1988). \doi{10.1016/0022-0000(88)90028-1},
  \url{https://doi.org/10.1016/0022-0000(88)90028-1}

\bibitem{Goldwasser88ZK}
Ben{-}Or, M., Goldreich, O., Goldwasser, S., H{\aa}stad, J., Kilian, J.,
  Micali, S., Rogaway, P.: Everything provable is provable in zero-knowledge.
  In: Goldwasser, S. (ed.) Advances in Cryptology - {CRYPTO} '88, 8th Annual
  International Cryptology Conference, Santa Barbara, California, USA, August
  21-25, 1988, Proceedings. Lecture Notes in Computer Science, vol.~403, pp.
  37--56. Springer (1988). \doi{10.1007/0-387-34799-2\_4},
  \url{https://doi.org/10.1007/0-387-34799-2\_4}

\bibitem{BitanskyNash}
Bitansky, N., Paneth, O., Rosen, A.: On the cryptographic hardness of finding a
  nash equilibrium. In: {IEEE} 56th Annual Symposium on Foundations of Computer
  Science, {FOCS} 2015, Berkeley, CA, USA, 17-20 October, 2015. pp. 1480--1498
  (2015). \doi{10.1109/FOCS.2015.94},
  \url{https://doi.org/10.1109/FOCS.2015.94}

\bibitem{Dan2018VDF}
Boneh, D., Bonneau, J., B{\"{u}}nz, B., Fisch, B.: Verifiable delay functions.
  In: Shacham, H., Boldyreva, A. (eds.) Advances in Cryptology - {CRYPTO} 2018
  - 38th Annual International Cryptology Conference, Santa Barbara, CA, USA,
      August 19-23, 2018, Proceedings, Part {I}. Lecture Notes in Computer Science,
  vol. 10991, pp. 757--788. Springer (2018).
  \doi{10.1007/978-3-319-96884-1\_25}

\bibitem{ChoudhuriNash}
Choudhuri, A.R., Hub{\'{a}}cek, P., Kamath, C., Pietrzak, K., Rosen, A.,
  Rothblum, G.N.: Finding a nash equilibrium is no easier than breaking
  fiat-shamir. In: Proceedings of the 51st Annual {ACM} {SIGACT} Symposium on
  Theory of Computing, {STOC} 2019, Phoenix, AZ, USA, June 23-26, 2019. pp.
  1103--1114 (2019). \doi{10.1145/3313276.3316400},
  \url{https://doi.org/10.1145/3313276.3316400}

\bibitem{ChoudhuriRSW}
Choudhuri, A.R., Hub{\'{a}}cek, P., Kamath, C., Pietrzak, K., Rosen, A.,
  Rothblum, G.N.: Ppad-hardness via iterated squaring modulo a composite.
  p.~667 (2019), \url{https://eprint.iacr.org/2019/667}

\bibitem{DaskalakisCLS}
Daskalakis, C., Papadimitriou, C.H.: Continuous local search. In: Proceedings
  of the Twenty-Second Annual {ACM-SIAM} Symposium on Discrete Algorithms,
  {SODA} 2011, San Francisco, California, USA, January 23-25, 2011. pp.
  790--804 (2011). \doi{10.1137/1.9781611973082.62},
  \url{https://doi.org/10.1137/1.9781611973082.62}

\bibitem{Dwork1992Price}
Dwork, C., Naor, M.: Pricing via processing or combatting junk mail. In:
  Brickell, E.F. (ed.) Advances in Cryptology - {CRYPTO} '92, 12th Annual
  International Cryptology Conference, Santa Barbara, California, USA, August
  16-20, 1992, Proceedings. Lecture Notes in Computer Science, vol.~740, pp.
  139--147. Springer (1992). \doi{10.1007/3-540-48071-4\_10}

\bibitem{Ephraim20VDF}
Ephraim, N., Freitag, C., Komargodski, I., Pass, R.: Continuous verifiable
  delay functions. In: Advances in Cryptology - {EUROCRYPT} 2020 - 39th Annual
  International Conference on the Theory and Applications of Cryptographic
  Techniques, Zagreb, Croatia, May 10-14, 2020, Proceedings, Part {III}. pp.
  125--154 (2020). \doi{10.1007/978-3-030-45727-3\_5},
  \url{https://doi.org/10.1007/978-3-030-45727-3\_5}

\bibitem{Feo2019Isogenie}
Feo, L.D., Masson, S., Petit, C., Sanso, A.: Verifiable delay functions from
  supersingular isogenies and pairings. In: Galbraith, S.D., Moriai, S. (eds.)
  Advances in Cryptology - {ASIACRYPT} 2019 - 25th International Conference on
  the Theory and Application of Cryptology and Information Security, Kobe,
  Japan, December 8-12, 2019, Proceedings, Part {I}. Lecture Notes in Computer
  Science, vol. 11921, pp. 248--277. Springer (2019).
  \doi{10.1007/978-3-030-34578-5\_10}

\bibitem{FS86}
Fiat, A., Shamir, A.: How to prove yourself: Practical solutions to
  identification and signature problems. In: Advances in Cryptology - {CRYPTO}
  '86, Santa Barbara, California, USA, 1986, Proceedings. pp. 186--194 (1986).
  \doi{10.1007/3-540-47721-7\_12},
  \url{https://doi.org/10.1007/3-540-47721-7\_12}

\bibitem{Garg16iO}
Garg, S., Pandey, O., Srinivasan, A.: Revisiting the cryptographic hardness of
  finding a nash equilibrium. In: Advances in Cryptology - {CRYPTO} 2016 - 36th
  Annual International Cryptology Conference, Santa Barbara, CA, USA, August
  14-18, 2016, Proceedings, Part {II}. pp. 579--604 (2016).
  \doi{10.1007/978-3-662-53008-5\_20},
  \url{https://doi.org/10.1007/978-3-662-53008-5\_20}

\bibitem{Goldreich96}
Goldreich, O., Krawczyk, H.: On the composition of zero-knowledge proof
  systems. {SIAM} J. Comput.  \textbf{25}(1),  169--192 (1996).
  \doi{10.1137/S0097539791220688},
  \url{https://doi.org/10.1137/S0097539791220688}

\bibitem{Goldwasser85Knowledge}
Goldwasser, S., Micali, S., Rackoff, C.: The knowledge complexity of
  interactive proof-systems (extended abstract). In: Sedgewick, R. (ed.)
  Proceedings of the 17th Annual {ACM} Symposium on Theory of Computing, May
  6-8, 1985, Providence, Rhode Island, {USA}. pp. 291--304. {ACM} (1985).
  \doi{10.1145/22145.22178}, \url{https://doi.org/10.1145/22145.22178}

\bibitem{Goldwasser86IPAM}
Goldwasser, S., Sipser, M.: Private coins versus public coins in interactive
  proof systems. In: Hartmanis, J. (ed.) Proceedings of the 18th Annual {ACM}
  Symposium on Theory of Computing, May 28-30, 1986, Berkeley, California,
  {USA}. pp. 59--68. {ACM} (1986). \doi{10.1145/12130.12137},
  \url{https://doi.org/10.1145/12130.12137}

\bibitem{HubacekCLS}
Hub{\'{a}}\v{c}ek, P., Yogev, E.: Hardness of continuous local search: Query
  complexity and cryptographic lower bounds. {SIAM} J. Comput.  \textbf{49}(6),
   1128--1172 (2020). \doi{10.1137/17M1118014},
  \url{https://doi.org/10.1137/17M1118014}

\bibitem{Mahmoody2020RO}
Mahmoody, M., Smith, C., Wu, D.J.: Can verifiable delay functions be based on
  random oracles? In: Czumaj, A., Dawar, A., Merelli, E. (eds.) 47th
  International Colloquium on Automata, Languages, and Programming, {ICALP}
  2020, July 8-11, 2020, Saarbr{\"{u}}cken, Germany (Virtual Conference).
  LIPIcs, vol.~168, pp. 83:1--83:17. Schloss Dagstuhl - Leibniz-Zentrum
  f{\"{u}}r Informatik (2020). \doi{10.4230/LIPIcs.ICALP.2020.83}

\bibitem{TFNP91}
Megiddo, N., Papadimitriou, C.H.: On total functions, existence theorems and
  computational complexity. Theor. Comput. Sci.  \textbf{81}(2),  317--324
  (1991). \doi{10.1016/0304-3975(91)90200-L},
  \url{https://doi.org/10.1016/0304-3975(91)90200-L}

\bibitem{PPAD94}
Papadimitriou, C.H.: On the complexity of the parity argument and other
  inefficient proofs of existence. J. Comput. Syst. Sci.  \textbf{48}(3),
  498--532 (1994). \doi{10.1016/S0022-0000(05)80063-7},
  \url{https://doi.org/10.1016/S0022-0000(05)80063-7}

\bibitem{Pietrzak2019Simple}
Pietrzak, K.: Simple verifiable delay functions. In: Blum, A. (ed.) 10th
  Innovations in Theoretical Computer Science Conference, {ITCS} 2019, January
  10-12, 2019, San Diego, California, {USA}. LIPIcs, vol.~124, pp. 60:1--60:15.
  Schloss Dagstuhl - Leibniz-Zentrum f{\"{u}}r Informatik (2019).
  \doi{10.4230/LIPIcs.ITCS.2019.60}

\bibitem{Rivest1996Time}
Rivest, R.L., Shamir, A., Wagner, D.A.: Time-lock puzzles and timed-release
  crypto. Tech. rep., USA (1996)

\bibitem{ShamirIP}
Shamir, A.: Ip=pspace. In: 31st Annual Symposium on Foundations of Computer
  Science, St. Louis, Missouri, USA, October 22-24, 1990, Volume {I}. pp.
  11--15. {IEEE} Computer Society (1990). \doi{10.1109/FSCS.1990.89519},
  \url{https://doi.org/10.1109/FSCS.1990.89519}

\bibitem{Wesolowski2019Efficient}
Wesolowski, B.: Efficient verifiable delay functions. In: Ishai, Y., Rijmen, V.
  (eds.) Advances in Cryptology - {EUROCRYPT} 2019 - 38th Annual International
  Conference on the Theory and Applications of Cryptographic Techniques,
  Darmstadt, Germany, May 19-23, 2019, Proceedings, Part {III}. Lecture Notes
  in Computer Science, vol. 11478, pp. 379--407. Springer (2019).
  \doi{10.1007/978-3-030-17659-4\_13}

\bibitem{Worsch1993Parallel}
Worsch, T.: Parallel turing machines with one-head control units and cellular
  automata. In: Theoretical Computer Science. Lecture Notes in Computer
  Science, vol.~217, pp. 3--30. Springer (1999).
  \doi{https://doi.org/10.1016/S0304-3975(98)00148-0}

\end{thebibliography}


\end{document}

