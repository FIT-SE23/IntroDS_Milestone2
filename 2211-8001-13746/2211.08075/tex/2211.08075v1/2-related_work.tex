\section{Related work}\label{sec:related_work}

This section presents research work in the field of knowledge related to this paper. It starts by reviewing ontologies proposed in the literature for DevOps environments. Special attention is payed to those that focus on the challanges explained in Section~\ref{sec:introduction}. \ac{OSLC} stands out for its approach to interoperability. Then, a study is conveyed to find architectures where the \ac{OSLC} standard has been used, emphasising those where automation is the main focus.

% First, in Section~\ref{devops_ontologies}, semantic technologies that intersect with DevOps are explored to learn from concepts defined in other ontologies. Then, Section~\ref{oslc_architectures} reviews how \ac{OSLC}-based architectures have been used before to solve integration problems in multiple domains.
% Finally, Section~\ref{event-based_automation_rules} studies examples of automation capabilities using event-based rules.

% \subsection{DevOps ontologies}\label{devops_ontologies}

As mentioned before, an interesting approach to the problem of integrating tools in a DevOps environment is to use semantic technologies~\citep{mcilraithSemanticWebServices2001}. These techniques can provide a flexible representation of resource data that different programs and devices can seamlessly understand. However, defining an ontology model for DevOps is not a simple task, as it is a concept related to different domains. Moreover, the very definition of DevOps is still imprecise and a subject of many debates, so the attempts to create such a vocabulary are often either excessively abstract and general or too specific for a particular tool. A definition based on the concepts found in the literature that has been proposed is the following: \say{DevOps is a development methodology aimed at bridging the gap between Development (Dev) and Operations, emphasizing communication and collaboration, continuous integration, quality assurance, and delivery with automated deployment utilizing a set of development practices}~\citep{jabbariWhatDevOpsSystematic2016}.

There are case studies where the use of Linked Data in a system of systems has been used for a road construction project~\citep{axelssonExperiencesUsingLinked2019}. A core ontology was defined and made extensible using word models. In another work~\citep{johngHarmoniaContinuousService2019}, a DevOps ontology extracted from Jenkins logs was used. Concepts where defined like Deployment Task or Infrastructure Change, but it is warned that this is just a reference ontology and might not be generalizable to other scenarios.

Another example of semantic technologies used with DevOps~\citep{mccarthyComposableDevOpsAutomated2015} establishes a common language for operations and development teams to use and defines some ontologies for the maturity of DevOps. More examples include a framework based on a DevOps ontology~\citep{guerreroSystematicMappingStudy2020} built on top of the PrMO (Ontology of Process-reference Models)~\citep{pardo-calvacheReferenceOntologyHarmonizing2014} and the SMO (Software Measurement Ontology)~\citep{barcellosWellFoundedSoftwareMeasurement2010}. Finally, the PaaSport semantic model~\citep{bassiliadesPaaSportSemanticModel2018}, an extension of the DUL (DOLCE+DnS Ultralite) ontology~\citep{gangemiUnderstandingSemanticWeb2003}, has been reviewed. However, it is more focused on compatibility between cloud computing platform providers.

Different Linked Data approaches to the tool interoperability problem in software development projects have been analyzed before~\citet{rodriguezFormalOntologiesData2019}. One of them was \ac{OSLC}. The \ac{OSLC} project~\citep{amsdenOSLCCoreVersion2021} tries to define a standardized interface for software development tools that applies the semantic technologies provided by \ac{W3C}. \ac{OSLC} is a set of open specifications for tool integration using the Linked Data initiative. The project consists of a Core specification that every \ac{OSLC} compliant tool must follow and a series of domain-specific protocols that are more suited for the particular needs of some groups of tools.

% There have been different approaches to the problem of modeling \ac{OSLC} resources. \citet{zhangClassModelingOSLC2013} \citep{zhangModelingToolIntegration2014} explains how \ac{OSLC} Resources can be modeled using Class Models and how Artifacts and Roles improve tool integration capabilities.
% In \citet{rymanOSLCResourceShape2013}, it is demonstrated that \ac{RDFS} and \ac{OWL} are not suitable languages to define constraints for \ac{OSLC} data.
% Instead, \ac{OSLC} Resource Shapes are proposed.

Based on \ac{OSLC}, a modeling tool for the specification of Linked Data resources focused on the development toolchain has been proposed~\citep{el-khouryModellingSupportLinked2016}. However, the authors also state that their modeling tool should be extended to cover other aspects of DevOps, like requirements analysis and automated testing.

% From the different Linked Data solutions found in the literature that could be used to model DevOps services, the one selected for the architecture proposed in this paper is \ac*{OSLC}.
The combination of standardization and flexibility found in \ac{OSLC} made it suited for the purpose of this paper. To learn more about previous applications of it, different architectures based on \ac{OSLC} from the literature are explore. The following case studies help illustrate how versatile \ac{OSLC} is and how different domains could benefit from it being more widely adopted.

% The following section explores some practical applications of \ac*{OSLC} in different projects gathered from the literature.

% \subsection{Application of \ac{OSLC} in practical scenarios}\label{oslc_architectures}

Beyond the software engineering field, architectures integrating IoT devices using \ac{OSLC} have been proposed~\citep{chenOpenSourceLifecycle2019}. Because of the heterogeneity of these IoT devices and the data they generate, getting them to interoperate becomes a problem. Using Linked Data and a standard protocol is helpful in this situation. 
% Every hardware interface has an \ac{OSLC} adapter that serves the data in the cloud so that other services can interact with it.

Another \ac{OSLC}-based architecture is used to integrate testing and requirements tools~\citep{nardoneOSLCbasedEnvironmentSystemlevel2020} in the context of the European Rail Traffic Management System/European Train Control System. Furthermore, the implications that \ac{OSLC} architectures have on implementation in the context of space systems have also been discussed~\citep{hoppeRequirementsSharedData2015}. Finally, \ac{OSLC} has been used to connect \ac{CAD} design tools and product visualization~\citep{ebelingOSLCBasedApproach2017}.

Modeling also presents interoperability challenges because system models are usually composed of submodels from different tools. For example, combinations of \ac{OSLC} and OpenModelica for model management and traceability~\citep{mengistTraceabilitySupportOpenModelica2017} or uses of the \ac{OSLC} Knowledge Management specification to allow lifecycle artifacts to be reused~\citep{alvarez-rodriguezElevatingMeaningData2019}.
In addition, the PROMIS project~\citep{aoyamaPROMISManagementPlatform2013} uses \ac{OSLC} to allow for an interorganizational software development model with a Software Supply Network (SSN).

% \todo[inline]{Aqu√≠ he metido lo de Crystal:}

A previous work that implemented an interoperability platform based on \ac*{OSLC} is the Crystal project~\citep{leitner_lessons_2016}. It was tested in a larger and more complex case study than the one presented in this paper. However, although \ac{OSLC} is used as the foundation for the project, their models go far beyond the proposed \ac*{OSLC} standards. This paper aims to define a model that could serve as a potential new specification in \ac{OSLC}. Also, the semantic models they proposed are not explicitly designed for \ac*{ECA} automation, which is the primary purpose of the present work.

There is a previous article that presents an architecture that includes something similar to event-based automation with \ac*{OSLC}~\citep{berezovskyiImprovingLifecycleQuery2018}. It uses it in the context of an integrated toolchain for IoT and uses the \ac{TRS}~\citep{crossleyOSLCTrackedResource2021}, an \ac*{OSLC}-based protocol, to automate different tasks.
% \ac{TRS} is a specification defined as part of the \ac{OSLC} project and allows a server to expose a log consisting of the changes data resources suffer so that a client can access them.
They affirm that this approach would also be very beneficial in Big Data environments because \say{using microservices and Linked Data to integrate systems within the toolchain eliminates the need for multiple transformations}, achieving better velocity and variety than previous techniques. They propose a case study of a robotic warehouse optimized for logistics automation. It uses a few tools from the change management and requirements management domains, each with its own \ac{OSLC} adapter. To communicate changes in these tools, instead of using HTTP, they resort to the \ac{MQTT} protocol~\citep{banksMQTTVersion2019} to have everything synchronized.

The proposal is exciting because it integrates various tools and devices using semantic technologies and creates a centralized communication network between these tools, which offers the possibility to automate their behavior.
They even make an effort to deliver messages asynchronously, essential for faster and more efficient communication.
However, the semantic models it uses have not been designed explicitly for \ac*{ECA}, as \ac*{TRS} is a change tracking protocol, but it was not created with events in particular.
The following section explores \ac*{OSLC} in more detail to provide a better context and to highlight the limitations found when it comes to automation based on event-based models.

% This section shown the versatility of \ac*{OSLC} and the possibilities it offers for automation environments. Although it does not support automated events and actions at the moment, this paper presents an extension to the standard to fill this gap. The following section explores other ontologies used in event-based automation scenarios, focusing on \ac*{EWE}, also used in the paper's proposed architecture.

% \subsection{Event-based automation rules and \ac{EWE}}\label{event-based_automation_rules}

% The \ac{ECA} model allows a system to define events that trigger actions based on certain conditions.
% This technique allows databases to be active sources of information in the system (\citet{gohECARulebasedSupport2001}).
% These automation rules have been utilized in Workflow Management Systems (WfMS), \citet{casatiEnvironmentDesigningExceptions1999} and \citet{baeAutomaticControlWorkflow2004}.

% Some commercial solutions that apply this model to provide automation capabilities have become very popular in recent years.
% For example, services like IFTTT \citep{iftttIFTTT} or Zapier \citep{ZapierAutomationThat} allow users to generate automation rules between applications, while StackStorm \citep{StackStorm} or Clarive \citep{Clarive} can be used to automate DevOps workflows.
% There are also examples in the literature of this model being used to automate business workflows, like in \citet{baeAutomaticControlWorkflow2004}.
% The concept implemented here is \ac{AaaS}.

% This service can be enhanced using semantic technologies.
% Two examples of such enhancements are the \ac{EYE} reasoner and the \ac{EWE} ontology.
% The \ac{EYE} reasoning engine (\citet{verborghDrawingConclusionsLinked2015}) allows defining semantical rules using the Notation3 format, which can then be executed using advanced reasoning techniques.
% The \ac{EWE} ontology was created to model the \ac{TAS} knowledge domain (\citet{coronadoModellingRulesAutomating2015}).
% It defines a vocabulary with the necessary concepts for event-based service automation.

% \ac{EWE} Tasker (\citet{munozSmartOfficeAutomation2016}) is a task automation server that combines the \ac{EWE} data schema and the \ac{EYE} reasoner to perform service automation based on semantically defined rules.
% It defines Channels that generate Events used to execute Actions if some Rule is triggered, following the \ac{ECA} model.
% \ac{EWE} Tasker offers flexibility, as many software tools and devices can be connected to the server by defining semantic representations as channels, which allows for the definition of events and actions.

% The \ac*{EWE} ontology is suited for defining of automated workflows in DevOps environments.
% Furthermore, because the architecture proposed in this paper uses \ac*{OSLC} for interoperability between its services,
% the \ac*{TAS} implemented should be accessible via \ac*{OSLC}.
% Therefore, a bridge between \ac*{OSLC} and \ac*{EWE} is defined along with the extension of the \ac*{OSLC} standard to support events and actions.
