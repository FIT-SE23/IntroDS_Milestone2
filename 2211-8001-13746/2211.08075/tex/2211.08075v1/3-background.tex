\section{Background}\label{sec:background}

% intro
This section explains how the \ac*{OSLC} Core Specifiaction works in more detail. It also presents \ac{OSLC} Automation and \ac{TRS}, domains that are relevant in the motivational DevOps scenarios. First, Section~\ref{sec:service_modelling} introduces the Core specifaction of \ac*{OSLC} which is the foundation for every service modeling. Then, Section~\ref{sec:auto_modelling} showcases the Automation domain which would be the best suited to model a \ac*{TAS} in the current state of the project. Next, Section~\ref{sec:logging_modelling} presents the \ac*{TRS} protocol, useful for logging and change tracking. Finally, Section~\ref{sec:oslc_limitations} discusses some of the limitations found in these vocabularies when trying to use them to model an \ac*{ECA} environment.

% resumen
% Services in the proposed architecture are modeled using \acf{OSLC} (\citet{amsdenOSLCCoreVersion2021}).
% Resources in each service are defined using the appropriate \ac{OSLC} domain, while the \ac{OSLC} Core vocabulary ensures interoperability.
% This is explained in more detail in Section~\ref{sec:service_modelling}.

% The \ac*{OSLC} Automation Server is modeled using the concepts from the \ac{OSLC} Automation domain (\citet{amsdenOSLCAutomationVersion2021}).
% They are explained in Section~\ref{sec:auto_modelling}.
% At the moment of writing this, the Automation domain is not in its final version, and it does not support events and actions.
% An extension to the domain is proposed to provide the necessary concepts for events (Section~\ref{sec:event_modelling}) and actions (Section~\ref{sec:action_modelling}).

% To model the automation rules used internally by the \ac*{TAS}, the \acf*{EWE} ontology (\citet{coronadoEWEOntologySpecification2017}) is used.
% The concepts from this ontology are presented in Section~\ref{sec:rule_modelling}.

% Finally, changes in the resources are exposed via \acf{TRS} (\citet{crossleyOSLCTrackedResource2021}) to be used for logging and monitoring.
% The \ac*{TRS} protocol is a specification provided by the \ac*{OSLC} family and is explained in more detail in Section~\ref{sec:logging_modelling}.

\subsection{OSLC Core overview}\label{sec:service_modelling}

% oslc general
% As briefly mentioned in Section~\ref{sec:state_of_the_art}, 
\ac{OSLC} is a family of open specifications for integrating tools. Its purpose is to integrate product/application lifecycle services regardless of their internal model. This goal makes the standard suitable for modeling the services in a DevOps infrastructure. In \ac{OSLC}, different topics such as change management, test management, or requirements management define specifications for their respective resources. They are known as domains. These domains are built on top of the \ac*{OSLC} Core Specification~\citep{amsdenOSLCCoreVersion2021} to ensure their compatibility.

% oslc detalle
In \ac{OSLC}, data is represented using \ac{RDF} and retrieved via HTTP\@. Therefore, each service must provide a catalog of its Service Providers, represented by the \oslc{ServiceProviderCatalog} and \oslc{ServiceProvider} classes. The \ac{OSLC} primer defines Service Providers as \say{organizing concepts that partition the overall space of artifacts in the tool into smaller containers. Examples of common partitioning concepts offered by tools include \say{projects}, \say{modules}, \say{user databases}, and so on}~\citep{speicherOSLCPrimer2019}. Hence, the meaning of Service Provider changes for each service, but the main idea is that it classifies the resources in that service.

% oslc core
An \ac*{OSLC} API offers clients the possibility of discovering all its resources and capabilities based on its root resource, the \oslc{ServiceProviderCatalog}. This resource allows clients to obtain its list of Service Providers responsible for providing the URLs needed to send creation and query requests to the server. These endpoints can be discovered through the \oslc{CreationFactory} and \oslc{QueryCapabilities} services. They may also provide an \oslc
{ResourceShape} that describes the properties a resource from that service is expected to have. An overview of the \ac{OSLC} Core specification from \citet{amsdenOSLCCoreVersion2021} can be found in Figure~\ref{fig:oslc_core_overview}.

% Figure~\ref{fig:oslc_execution} shows how a client could interact with an \ac{OSLC} service in a \ac{BPMN} diagram.

% \begin{figure}[!ht]
%     \centering
%     \includegraphics[width=0.9\textwidth]{figures/bpmn/oslc.png}
%     \caption{Execution process to modify an \ac{OSLC} resource.}\label{fig:oslc_execution}
% \end{figure}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.9\textwidth]{figures/ontologies/oslc.png}
    \caption{\ac{OSLC} Core overview.}\label{fig:oslc_core_overview}
\end{figure}

\subsection{OSLC Automation}\label{sec:auto_modelling}

% oslc automation
Regarding the process automation field, \ac{OSLC} defines a specific domain called \ac{OSLC} Automation~\citep{amsdenOSLCAutomationVersion2021}. This domain aims to model an interface so that an automation provider can interact with other \ac{OSLC} services. It defines three different resources a Service Provider exposes following the Core standard. The first of these resources is the \auto{AutomationPlan} which defines a unit of automation available for execution. Next, the \auto{AutomationRequest} resource provides the information required to execute an Automation Plan. Finally, the standard defines an \auto{AutomationResult} resource to track an Automation Request status and contributions. Figure~\ref{fig:oslc_automation_overview} displays a diagram of these resources and their relationships.

\begin{figure}
    \centering
    \includegraphics[width=0.8\textwidth]{figures/ontologies/oslc-auto.png}
    \caption{\ac{OSLC} Automation diagram.}\label{fig:oslc_automation_overview}
\end{figure}


% \subsection{Rule modeling}\label{sec:rule_modelling}

% % ewe intro
% Besides \ac*{OSLC}, the architecture uses another vocabulary to model its automation rules: the \ac{EWE} ontology.
% As briefly explained in Section~\ref{sec:state_of_the_art}, \ac{EWE} is a vocabulary designed to describe \ac{TAS}s.
% According to its specification (\citet{coronadoEWEOntologySpecification2017}), one of the main goals of \ac{EWE} is to \say{provide a base vocabulary for building domain-specific vocabularies, e.g., Twitter Task Ontology or Evernote Task Ontology}.
% Because \ac{OSLC} can model services from different domains, this feature is essential to enable interoperability.

% % ewe detalle
% The core concepts in \ac{EWE} are \ewe{Rule}, \ewe{Channel}, \ewe{Event}, and \ewe{Action}.
% Every \ewe{Rule} follows the \ac{ECA} model; if an \ewe{Event} is received and certain conditions are met, an \ewe{Action} is executed.
% The concept of \ewe{Channel} represents \say{individuals that either generate Events, provide Actions, or both.
% In the context we refer to, Channel mainly defines Web Services} \citet{coronadoEWEOntologySpecification2017}.
% Events and Actions can have different \ewe{Parameter} resources used for \ewe{Rule} evaluation and execution.
% Diagrams showing the execution process followed to evaluate rules can be observed in Figure~\ref{fig:ewe_execution}.
% The main concepts from \ac{EWE} are shown in Figure~\ref{fig:ewe_main_entities}.

% \begin{figure}[!ht]
%     \centering
%     \includegraphics[width=0.8\textwidth]{figures/bpmn/ewe.png}
%     \caption{Description of the execution process after an event is received in \ac{EWE}.}\label{fig:ewe_execution}
% \end{figure}


% \begin{figure}[!ht]
%     \centering
%     \includegraphics[width=0.9\textwidth]{figures/ontologies/ewe.png}
%     \caption{Main concepts defined in \ac{EWE} ontology, from \citet{munozSmartOfficeAutomation2016}.}\label{fig:ewe_main_entities}
% \end{figure}

% % resumen
% In summary, services in the proposed architecture are modeled using \ac{OSLC}.
% Resources in each service are defined using the appropriate \ac{OSLC} domain while the \ac{OSLC} Core vocabulary ensures interoperability.
% Changes in the resources are exposed via \ac{TRS} to be used for logging and monitoring.
% To provide the whole environment with automation capabilities, a semantic \ac{TAS} is utilized.
% Internally, it is modeled with \ac{EWE}, while \ac{OSLC} Automation defines the external interface, so it can be interacted with in a standardized way.

\subsection{The TRS protocol}\label{sec:logging_modelling}

% trs
% To fulfill requirement RQ3, \ac{OSLC} services need a model to generate logs. 
As briefly mentioned in Section~\ref{sec:related_work}, the \ac{TRS} protocol~\citep{crossleyOSLCTrackedResource2021} is specified as part of the \ac{OSLC} project. It was conceived to track changes in the resource set of an \ac{OSLC} service and expose them as \ac{RDF} HTTP resources themselves. These exposed changes have been used before to trigger automated actions~\citep{berezovskyiImprovingLifecycleQuery2018}.

\ac{TRS} defines a list of \trs{ChangeLog} resources. Each of these Change Logs contains numbered entries representing every creation, modification, or deletion suffered by any resource in the set. Because this list can be accessed via HTTP, a client can periodically check what changes have occurred in the resource set to monitor the behavior of the service. The protocol also offers the \ac{TRS} Patch mechanism to allow a \trs{ChangeEvent} to carry more detailed information about the modifications suffered by the resources.

\subsection{OSLC limitations for ECA-based automation}\label{sec:oslc_limitations}

After reviewing the current state of the \ac*{OSLC} project, the goal is to introduce it in a DevOps environment. More specifically, an environment where a \ac*{TAS} provides automation for other services using a system of \ac*{ECA} rules. To achieve this, \ac*{OSLC} needs a standardize way for services to provide event detection and actions execution capabilities.

As previously mentioned, there is a specific \ac*{OSLC} domain for Automation. However, key concepts are still missing for this model to support event detection. For example, to run an \auto{AutomationPlan}, \ac*{OSLC} Automation requires a consumer to create an \auto{AutomationRequest} by making a POST request to the Automation server. The ideal scenario would be to have the \ac*{OSLC} Automation service listening for events generated in another service by itself. This idea is the starting point for defining events in the proposed extension model.
% This is what the Event Listener component described in the architecture does. To model this component with \ac*{OSLC}, an extension to the Automation domain is proposed.

On the other hand, \ac{OSLC} resources already support basic CRUD actions (create, read, update and delete). It was already mentioned how Service Providers enable resource creation and querying. The resources in \ac{OSLC} can also be updated or deleted using the corresponding HTTP methods (PUT and DELETE, respectively). The \ac{OSLC} community has shown efforts to support the execution of more concrete actions~\citep{painOSLCActions2020} over resources. The proposal allows a service to perform actions on other service resources without knowing their type and properties. The document is a potential candidate for a future specification. It even suggests ideas of introducing actions in the \ac{OSLC} Core Specification. This draft serves as foundation for the action model proposed in this paper, extending to improve some key aspects still missing.
Next section presents the extension to \ac*{OSLC} for event and action support. It details all the properties that have been defined and explians how it is suposed to be used for interoperability.
