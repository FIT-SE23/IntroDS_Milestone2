\section{Validation}\label{sec:evaluation}

This section discusses the validity of the results obtained by the proposed semantic model.
The need for these extension to the \ac*{OSLC} standard was justified in Section~\ref{sec:introduction} with the benefits it provides to the DevOps field.
Section~\ref{sec:problem_overview} explores the literature to find notable issues faced by DevOps practitioners.
Based on these challenges, requirements are defined for a DevOps architecture.
Meeting these requirements means the architecture improves practitioners' experience regarding the issues found in the literature.

To prove that \ac*{OSLC} and, more specifically, the proposed semantic model help in fulfilling the requirements, a DevOps architecture is presented in Section~\ref{sec:architecture}.
The concepts defined in Section~\ref{sec:semantic_model} are used to build an automation environment based on the \ac{ECA} model.
To ensure the architecture actually follows the DevOps philosophy, a set of characteristic for such architectures are gathered from the literature.
The most relevant are included in the design process.

Finally, to validate the proposed semantic model, the architecture enabled by it is put to the test with a worked example conducted in Section~\ref{sec:case_study}.
It presents a real-world scenario where two popular commercial services are integrated into the \ac*{ECA} environment.
It proves that the model and the architecture it made possible meet the established requirements.

\subsection{Problem overview}\label{sec:problem_overview}

% A precise understanding of the problem is the key to making design decisions.
This section focuses on establishing a set of requirements to face the challenges identified in the DevOps domain. The goal is to show how the proposed model can be used to build an architecture that meets the requirements and, therefore, helps improving DevOps practices. The list challenges has been gathered from a systematic review of the literature~\citep{bolscherDesigningSoftwareArchitecture2019}. The ones addressed by this proposal have been selected and are shown in Table~\ref{tab:issues}. They also put together a list of characteristics desirable for DevOps environments that will be useful for the design of the architecture.

% \renewcommand{\arraystretch}{2}
\begin{table}[!ht]
    \centering
    \begin{tabular}{ccc}
        \toprule
        \textbf{ID} & \textbf{Issue} & \textbf{Description} \\ \midrule
        IS1 & Methods and tools &
        \begin{tabular}[c]{@{}c@{}}
          Complex tooling and lack \\
          of proper support
        \end{tabular} \\ \midrule

        IS2 &
        \begin{tabular}[c]{@{}c@{}}
          Ever-changing operational \\
          environments and tools
        \end{tabular} &
        \begin{tabular}[c]{@{}c@{}}
          Deploying in heterogeneous \\
          operations environments
        \end{tabular} \\ \midrule

        IS3 & Logging & Bug traceability with many services \\ \midrule

        IS4 & Monitoring & Complex and sophisticated \\ \midrule

        IS5 & Scaling &
        \begin{tabular}[c]{@{}c@{}}
          Hard to implement DevOps if the \\
          architecture does not scale
        \end{tabular} \\ \bottomrule
    \end{tabular} 
\caption{List of issues/challenges for DevOps environments~\citep{bolscherDesigningSoftwareArchitecture2019}.}\label{tab:issues}
\end{table}
% \renewcommand{\arraystretch}{1}

% problema: de integración de herramientas
Section~\ref{sec:introduction} mentions some issues found when adopting DevOps practices. First, the problem known as vendor lock-in appears when software companies become dependent on the tools they are using, not being able to substitute them when they need to~\citep{opara-martinsCriticalAnalysisVendor2016}. Companies seeking to adopt DevOps practices like \ac{CI} could face this challenge due to the complexity of the required tools and the effort needed to integrate them into their workflows~\citep{stahlCindersContinuousIntegration2017} (issue IS1). Even those companies that have already successfully transitioned to DevOps could suffer from this issue, as the environments and tools are changing fast and constantly~\citep{shahinIntersectionContinuousDeployment2016} (issue IS2). This issue results in a lack of flexibility that is incompatible with the DevOps idea of quickly adapting to changes in the market.

% problema: falta de flexibilidad en los TAS
Regarding \ac{AaaS}, designing flexible solutions can be a problematic task~\citep{coronadoTaskAutomationServices2016}. For most \ac{TAS} platforms, workflows are defined based on available features. Regardless of how extensive they make this set of features, there can be situations where users need some specific functionality that the vendor does not offer. Users might, for example, want to integrate a recently released service into their infrastructure, but it may not be yet supported by the \ac{TAS} they are currently using~\citep{coronadoTaskAutomationServices2016}.

Even when users implement such integrations themselves, they might want to switch to another \ac{TAS} later. However, because they have all of their automated tasks built on top of the \ac{TAS} they are currently using, they might find it too expensive to make the migration, getting again to a position of vendor lock-in. These issues could lead to companies not adapting and evolving fast enough, so their infrastructure quickly becomes obsolete.

% problema: trazabilidad
Another issue that arises when adopting DevOps is managing logging and monitoring (issues IS3 and IS4). In a microservices architecture, traceability becomes increasingly hard to handle at scale. Failing to address traceability adequately could delay finding bugs which means less efficient \ac{CI}.

% problema: perder otros beneficios de DevOps en el proceso
While facing the previous challenges, other DevOps concepts should not be overlooked. Flexible implementations and a short time to market are key DevOps aspects, but the scalability of the infrastructure (issue IS5) should not be sacrificed to achieve them.

These concepts will be the foundation for the defined requirements. Other works presenting DevOps architectures make quantitative analyses to evaluate the performance gained by their proposed approach~\citep{vergoriDevOpsPerformanceEngineering2017}. However, in this case, it is hard to find values that can be measured to make such assessments. Therefore, the proposed model is evaluated by defining a set of requirements, presenting an architecture based on such a model, and implementing a test case to verify that they are correctly satisfied.

% \begin{figure}[!ht]
%     \centering
%     \includegraphics[width=\textwidth]{figures/sysml/requirements.png}
%     \caption{SysML requirements diagram.}\label{fig:requirements}
% \end{figure}


% RQ1
% To tackle the service integration issue (composed of IS1 and IS2), requirement \textbf{RQ1} is defined in Table~\ref{tab:rq1}.
To tackle the service integration issue (composed of IS1 and IS2), requirement \textbf{RQ1} is defined. Because changes in the development and business model can happen over time, tools will need to be added, updated, or removed from the infrastructure. The integration between these tools should be as independent of their internal structure as possible to maximize versatility. Tools need to provide a means to interact with them in a standardized way, either directly or through an adapter. For the architecture proposed in this paper, that standard will be \ac{OSLC}. This requirement can be validated by successfully executing a complete workflow that detects an event in one service, triggers a rule in a \ac{TAS}, and executes an action in a different service. Such a workflow should be implemented without changing the system interfaces. They have to work regardless of the internal structure of the integrated service.

% \begin{table}[!ht]
%   \begin{tabular}{ll}
%     \toprule
%     \textbf{RQ1} &
%     \begin{tabular}[c]{@{}l@{}}
%       The infrastructure shall seamlessly integrate any tool, as long\\
%       as it follows specific standards.
%     \end{tabular} \\ \midrule
%     \textbf{Precondition} &
%     \begin{tabular}[c]{@{}l@{}}
%       The service that needs to be integrated into the system is already\\
%       compliant with \ac{OSLC}. No changes to the system were required for\\
%       this particular service.
%     \end{tabular} \\ \midrule
%     \textbf{Postcondition} &
%     \begin{tabular}[c]{@{}l@{}}
%       The system detects events in the new service and actions take\\
%       effect in its resources. Rules can be defined utilizing these events and\\
%       actions.
%     \end{tabular} \\ \midrule
%     \textbf{Validation} &
%     \begin{tabular}[c]{@{}l@{}}
%       To consider the integration process sufficiently fast and seamless,\\
%       rule definition needs to be possible without coding API calls.\\
%       For two different \ac{OSLC} compliant services, if a set of rules involving\\
%       one event and one action from each service can be executed; the requirement\\
%       will be considered satisfied.
%     \end{tabular} \\ \bottomrule
%   \end{tabular}
% \caption{Seamless integration of services (RQ1).}\label{tab:rq1}
% \end{table}

% RQ2
% It is subdivided into requirement RQ21 from Table~\ref{tab:rq21} and requirement RQ22 from Table~\ref{tab:rq22}.
Requirement \textbf{RQ2} focuses on the flexibility challenges faced by \ac{AaaS} platforms. To avoid the vendor lock-in problem, it should be possible to interact with the \ac*{TAS} using a standardized protocol. In this case, that standard is \ac*{OSLC}. In particular, it uses the concepts from the \ac*{OSLC} Automation domain.
% Rules should also be standardized, otherwise every automated workflow would have to be reimplemented when migrating to a new \ac*{TAS}.

% \begin{table}[!ht]
%   \begin{tabular}{ll}
%     \toprule
%     \textbf{RQ21} &
%     \begin{tabular}[c]{@{}l@{}}
%       The system shall use a standardized interface to communicate with automation\\
%       services.
%     \end{tabular} \\ \midrule
%     \textbf{Precondition} &
%     \begin{tabular}[c]{@{}l@{}}
%       The automation service used complies with the\ac*{OSLC} Automation standard.
%     \end{tabular} \\ \midrule
%     \textbf{Postcondition} &
%       Interaction with the automation service is standardized. \\ \midrule
%     \textbf{Validation} &
%     \begin{tabular}[c]{@{}l@{}}
%       When the automation service can be interacted with using \ac*{OSLC} patterns,\\
%       then it is easier to integrate with new services and replacing it with another\\
%       \ac*{OSLC}-compliant \ac*{TAS} would take less effort.
%     \end{tabular} \\ \bottomrule
%   \end{tabular}
%   \caption{Standardized automation service interface (RQ21).}\label{tab:rq21}
% \end{table}

% \begin{table}[!ht]
%   \begin{tabular}{ll}
%     \toprule
%     \textbf{RQ22} &
%     \begin{tabular}[c]{@{}l@{}}
%       The system shall support the standardized definition of automation rules.
%     \end{tabular} \\ \midrule
%     \textbf{Precondition} &
%     \begin{tabular}[c]{@{}l@{}}
%       A \ac*{TAS} with support for the definition of semantic rules.
%     \end{tabular} \\ \midrule
%     \textbf{Postcondition} &
%       Automation features implemented using a semantic standard for automation rules. \\ \midrule
%     \textbf{Validation} &
%     \begin{tabular}[c]{@{}l@{}}
%       Automation rules should follow a standard based on Linked Data to be interoperable.
%     \end{tabular} \\ \bottomrule
%   \end{tabular}
%   \caption{Interoperable automation rules (RQ22).}\label{tab:rq22}
% \end{table}

% RQ3
% \textbf{RQ3}, shown in Table~\ref{tab:rq3}, addresses the problem of logging and monitoring (IS3 and IS4) the components of the architecture.
\textbf{RQ3} addresses the problem of logging and monitoring (IS3 and IS4) the components of the architecture. Once again, using a standard would simplify this task. In additon, traceability becomes easier if every service follows the same model for its logs. The \ac*{TRS} standard fits because of its compatibility with \ac*{OSLC}.

% \begin{table}[!ht]
%   \begin{tabular}{ll}
%     \toprule
%     \textbf{RQ3}           & The system shall use a standard for logging and monitoring.\\ \midrule
%     \textbf{Precondition}  & \ac*{OSLC} support by the components of the system.\\ \midrule
%     \textbf{Postcondition} & 
%     \begin{tabular}[c]{@{}l@{}}
%       Logs can be retrieved using the \ac*{TRS} standard.
%     \end{tabular}\\ \midrule
%     \textbf{Validation}    &
%     \begin{tabular}[c]{@{}l@{}}
%       Every component of the system uses the same Linked Data model for logging.
%     \end{tabular} \\ \bottomrule
%   \end{tabular}
%   \caption{Traceability (RQ3).}\label{tab:rq3}
% \end{table}

% RQ4
% \textbf{RQ4} is defined in Table~\ref{tab:rq4} to guarantee that the architecture can scale and adapt to such changes without being restructured (IS5).
Growth in the complexity of the infrastructure is supported as the number of tools integrated increases. \textbf{RQ4} guarantees that the architecture can scale and adapt to such changes without being restructured (IS5). To satisfy this requirement, the system should rely on technologies able to scale horizontally. In other words, as long as the different modules can be containerized and provide APIs to access them, the infrastructure can be considered scalable.

% \begin{table}[!ht]
%   \begin{tabular}{ll}
%     \toprule
%     \textbf{RQ4}           & The infrastructure shall be scalable and support larger scenarios.\\ \midrule
%     \textbf{Precondition}  & Follow DevOps design principles.\\ \midrule
%     \textbf{Postcondition} & 
%     \begin{tabular}[c]{@{}l@{}}
%       Several services are integrated into the system communicating via \ac{OSLC}\\
%       compatible REST APIs.
%     \end{tabular}\\ \midrule
%     \textbf{Validation}    &
%     \begin{tabular}[c]{@{}l@{}}
%       The technologies used in implementing the system must allow it to scale\\
%       horizontally.
%     \end{tabular} \\ \bottomrule
%   \end{tabular}
%   \caption{Scalability (RQ4).}\label{tab:rq4}
% \end{table}

% Once the requirements for the architecture have been laid out, it is possible to make the appropriate design decisions.

% Table ? showcases all the requirements along with the issues that justify them and their validation methods.
The following section presents an architecture based on the proposed semantic model to fulfill these requirements, summarised in Table~\ref{table:reqs}.
%It also possesses a series of characteristics essential for a DevOps architecture.

\begin{table}
    \centering
    \begin{tabular}{lp{0.5\textwidth}l} 
        \toprule
        \textbf{RQ ID} & \textbf{Description} &\textbf{Related Issues}\\ 
        \hline
        RQ1         & The infrastructure shall seamlessly integrate any tool, as long as it follows specific standards. & IS1, IS2 \\ 
        \hline
        RQ2         & The system shall use a standardized interface to communicate with automation services. & IS1, IS2 \\ 
        \hline
        RQ3         & The system shall use a standard for logging and monitoring. & IS3, IS4 \\ 
        \hline
        RQ4         & The infrastructure shall be scalable and support larger scenarios. & IS5 \\
        \bottomrule
    \end{tabular}
    \caption{Summary of defined requirements and their relation to the issues found in the literature for DevOps.}\label{table:reqs}
\end{table}


% \begin{table}
%     \centering
%     \caption{Requirements and their relation to the issues found in the literature for DevOps.}
%     \begin{tabular}{llll} 
%     \hline
%     \textbf{RQ} & \textbf{Description}                                                                                                                         & \textbf{Validation}                                                                                                                                                                                                                                                                                                                                                & \begin{tabular}[c]{@{}l@{}}\textbf{Related}\\\textbf{issues}\end{tabular}  \\ 
%     \hline
%     RQ1         & \begin{tabular}[c]{@{}l@{}}The infrastructure shall\\seamlessly integrate any\\tool, as long as it follows\\specific standards.\end{tabular} & \begin{tabular}[c]{@{}l@{}}To consider the integration process\\sufficiently fast and seamless, rule\\definition needs to be possible without\\coding API calls. For two different OSLC\\compliant services, if a set of rules\\involving one event and one action from\\each service can be executed; the\\requirement will be considered satisfied.\end{tabular} & IS1 and IS2                                                                \\ 
%     \hline
%     RQ2         & \begin{tabular}[c]{@{}l@{}}The system shall use a\\standardized interface\\to communicate with\\automation services.\end{tabular}            & \begin{tabular}[c]{@{}l@{}}When the automation service can be\\interacted with using OSLC patterns,\\then it is easier to integrate with new\\services and replacing it with another \\OSLC-compliant TAS would take less\\effort.\end{tabular}                                                                                                                    &                                                                            \\ 
%     \hline
%     RQ3         & \begin{tabular}[c]{@{}l@{}}The system shall use a\\standard for logging and\\monitoring.\end{tabular}                                        & \begin{tabular}[c]{@{}l@{}}Every component of the system uses\\the same Linked Data model for logging.\end{tabular}                                                                                                                                                                                                                                                & IS3 and IS4                                                                \\ 
%     \hline
%     RQ4         & \begin{tabular}[c]{@{}l@{}}The infrastructure shall\\be scalable and support\\larger scenarios.\end{tabular}                                 & \begin{tabular}[c]{@{}l@{}}The technologies used in implementing\\the system must allow it to scale\\horizontally.\end{tabular}                                                                                                                                                                                                                                    & IS5                                                                        \\
%     \hline
%     \end{tabular}
% \end{table}

\subsection{Prototype Architecture}\label{sec:architecture}

This section presents an architecture that uses the \ac*{OSLC} extension model as a foundation. 
% First, Section~\ref{sec:characteristics} showcases a list of characteristics found beneficial for DevOps architectures in the literature. Then, Section~\ref{sec:overview} presents a general view of the architecture.
% Finally, Section~\ref{sec:building_blocks} explores the details of its internal components.

% \subsubsection{Beneficial characteristics for DevOps architectures}\label{sec:characteristics}

This section presents an architecture founded on the \ac*{OSLC} extension model. The decisions made in the architecture design are aimed to meet the requirements established in Section~\ref{sec:problem_overview}. Because it is meant to be applicable in DevOps scenarios, it also includes the essential characteristics deemed beneficial for such an architecture in the literature~\citep{bolscherDesigningSoftwareArchitecture2019}. The most relevant of these characteristics have been selected to guide its design. The criteria used are based on the number of references and the relation to the requirements of this proposal. These chosen characteristics are listed in Table~\ref{tab:characteristics}. Some characteristics not selected could be included in future work.

% \renewcommand{\arraystretch}{2}
\begin{table}[!ht]
    \centering
    \begin{tabular}{cccl}
        \toprule
        \textbf{ID} & \textbf{Characteristic} & \textbf{Related RQs} & \textbf{Description} \\ \midrule

        CH1 & Deployability & RQ1 and RQ4 &
        \begin{tabular}[l]{@{}l@{}}
            The architecture deploying downtime is \\
            minimized and moving between different \\
            environments is fast.
        \end{tabular} \\ \midrule

        CH2 & Modularity & RQ1 and RQ4 &
        \begin{tabular}[l]{@{}l@{}}
            Services in the architecture have minimized \\
            dependencies and changes are isolated.
        \end{tabular} \\ \midrule

        CH3 & Loosely coupled & RQ1 and RQ4 &
        \begin{tabular}[l]{@{}l@{}}
            Decreasing application and inter-team \\
            dependencies.
        \end{tabular} \\ \midrule

        CH4 & Agility/Modifiability & RQ1 &
        \begin{tabular}[l]{@{}l@{}}
            Architectural changes can be performed fast.
        \end{tabular} \\ \midrule

        CH5 & Automation & RQ2 &
        \begin{tabular}[l]{@{}l@{}}
            Processes like testing and deployment \\
            are automated as much as possible.
        \end{tabular} \\ \midrule

        CH6 & Monitoring & RQ3 &
        \begin{tabular}[l]{@{}l@{}}
            Services can be monitored.
        \end{tabular} \\ \midrule

        CH7 & Logging & RQ3 &
        \begin{tabular}[l]{@{}l@{}}
            Services produce and store meaningful logs.
        \end{tabular} \\ \bottomrule
    \end{tabular} 
\caption{List of beneficial characteristics for DevOps architectures by \citet{bolscherDesigningSoftwareArchitecture2019}.}\label{tab:characteristics}
\end{table}
% \renewcommand{\arraystretch}{1}

% \subsubsection{Architecture overview}\label{sec:overview}

The architecture comprises five layers, as shown in Figure~\ref{fig:basic_architecture}. These five layers are the Service Layer, the \ac*{OSLC} Adaption Layer, the Distributed Messaging Layer, The \ac{OSLC} Automation Layer, and the \ac{OSLC} Logging Layer. In the following paragraphs, the inclusion of each layer is justified by the defined requirements and the selected characteristics.

\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.9\textwidth]{figures/architecture/basic.png}
    \caption{Diagram of the prototype architecture for validation.}\label{fig:basic_architecture}
\end{figure}

The most frequently required characteristic in a DevOps environment is deployability (CH1). A deployable architecture needs to be easily moved between environments. This is often achieved by dividing it into smaller components that can be deployed independently (microservices). Modularity (CH2) and loosely coupled (CH3) are two more characteristics this pattern meets. In the proposed architecture, these components form the \textbf{Service Layer}.

To meet requirement RQ1, services in the architecture need to be able to communicate via \ac*{OSLC}. This would also achieve modifiability (CH4), as services would be easier to substitute if their interfaces are standardized. Some of these services might be natively compliant with \ac*{OSLC}, but those not following the standard require adapters. These adapters are independent component, so the previously mentioned characteristics are not sacrificed. They form the \textbf{\ac*{OSLC} Adaptation Layer}.

Automation (CH5) is another crucial characteristic for DevOps practitioners. It is fulfilled, along with requirement RQ2, by the \textbf{\ac{OSLC} Automation Layer}. To keep the architecture modular, automation is separated into its own service. It is compliant with \ac*{OSLC} and communicates with the other services through \ac*{OSLC} adapters. However, having the \ac{OSLC} Automation Layer directly communicate via HTTP requests with the adapters would cause issues as the system scales and complexity grows.

To avoid conflicts with requirement RQ4, a \textbf{\ac{DML}} is included. This service is responsible for delivering the messages generated in the services to the \ac{OSLC} Automation Layer and vice versa. Any service in the architecture can push messages to the \ac*{DML} that will be received by those subscribed to the appropriate topic.

Finally, to meet requirement RQ3, every \ac*{OSLC}-compliant service implements the \ac*{TRS} specification. \ac*{TRS} provides tracking capabilities for changes in a service's resource set. This capability can be used for monitoring (CH6) and logging (CH7). The \ac*{TRS} functionality is separated from the service into its own component to keep a modular architecture. The collection of \ac*{TRS} services form the \textbf{\ac{OSLC} Logging Layer}.

% \subsubsection{Architecture components}\label{sec:building_blocks}

% Several layers of the architecture include components that require further discussion.
% The Service Layer depends on the particular tools used when implementing the architecture in practice and is explored in Section~\ref{sec:service_layer}.
% The \ac*{OSLC} Adaption Layer includes an adapter component for each service.
% The elements inside this adapter are presented in Section~\ref{sec:oslc_adapter}.

% Section~\ref{sec:dml} shows the internal architecture of the \ac*{DML}.
% The \ac{OSLC} Automation Layer needs more detail as well.
% Its components are explained in Section~\ref{sec:auto_layer}.
% Finally, the \ac{OSLC} Logging Layer consists of servers implementing the \ac*{TRS} specification, so it is omitted from the explanation.

% % \subsubsubsection{The Service Layer}\label{sec:service_layer}

% The particular services used in actual architecture implementations live in the Service Layer.
% This layer has several properties.
% On the one hand, because of the deployability, modularity, and loosely coupled characteristics (CH1, CH2, and CH3, respectively), services should be isolated and not have dependencies on each other.
% This often leads to a very heterogeneous set of services.
% On the other hand, the services should be easy to change and replace because of the agility/modifiability characteristic (CH4).
% The \ac*{OSLC} Adaptation Layer standardizes the communication between the services using \ac*{OSLC} adapters to simultaneously support all of these characteristics.

% % \subsubsubsection{The \ac*{OSLC} Adaption Layer}\label{sec:oslc_adapter}

% The main components in the \ac{OSLC} Adaption Layer are the \ac*{OSLC} adapters for the services in the Service Layer.
% In most cases, an \ac*{OSLC} adapter only needs an HTTP server to expose its resources and core capabilities and a backdoor connection to its adapting service.
% In the case of supporting \ac*{TRS}, it also needs to expose those resources via HTTP\@.
% However, for the architecture proposed in this paper, \ac*{OSLC} adapters also need to generate events and execute actions.
% Therefore, they have two extra elements: an \textbf{Event Listener} and an \textbf{Action Dispatcher}.

% The \textbf{Event Listener} has several roles.
% First, it substitutes the backdoor connection between the central \ac*{OSLC} server and the adapted service.
% How the Event Listener detects the events generated at the service depends on the service's implementation (it could be via webhooks, for example).
% Once an event is received, the Event Listener models it using the \ac*{OSLC} vocabulary from the corresponding domain.
% The standardized event is then sent to the \ac*{DML} to be delivered to the \ac{OSLC} Automation Layer.
% They are also logged at the \ac*{TRS} server.

% The \textbf{Action Dispatcher} is subscribed to the \ac*{DML} to receive the resources containing the actions sent by the \ac{OSLC} Automation Layer.
% The actions are described using the appropriate \ac*{OSLC} vocabulary and are meant to be executed on the adapted service.
% The execution mechanism depends on the service (an HTTP request would be the most common example).
% The Action Dispatcher is responsible for understanding the action's standardized description and executing it on the adapted service.
% The resource containing the action is logged at the \ac*{TRS} server.
% Any changes to its execution status (pending, failed, success) are also logged.

% Figure~\ref{fig:oslc_adapter} shows the internal architecture of an adapter like this.
% Modeling events and actions in \ac*{OSLC} requires extending the specification.
% This is addressed in Section~\ref{sec:semantic_model}.

% \begin{figure}[!ht]
%     \centering
%     \includegraphics[width=0.8\textwidth]{figures/architecture/adapter.png}
%     \caption{\ac*{OSLC} adapter architecture.}\label{fig:oslc_adapter}
% \end{figure}

% % \subsubsubsection{The Distributed Messaging Layer}\label{sec:dml}

% The role of the \ac*{DML} is to handle the delivery of messages between the services and the \ac*{OSLC} Automation Layer.
% The main reason for having a separate tool for this functionality is better \textbf{scalability (RQ4)}.
% If the services communicated directly with the \ac*{OSLC} Automation Layer, it could produce a bottleneck.
% Therefore, the \ac*{DML} has to be distributed, which means it scales horizontally as the architecture gets bigger and incorporates more services.
% The distributedness of the \ac*{DML} also satisfies characteristics CH1, Ch3, and CH4.
% The architecture of the \ac*{DML} consists of a server and two types of clients.

% The server acts as a \textbf{message broker}.
% Its role is to have open connections with the clients, which they can use to push messages or receive them asynchronously.
% As previously stated, to keep it scalable, it has to be distributed.

% The clients can act as \textbf{producers and consumers}.
% Producers can use an open connection with the broker to push messages indexed by a particular topic.
% Consumers can use their connections to subscribe to topics and receive a message asynchronously when it is pushed to that topic.

% There are topics specific for events generated by certain services in the architecture so the \ac*{OSLC} Automation Layer can receive them.
% In addition, there are topics for actions that are sent to the \ac*{OSLC} adapters for execution.

% % \subsubsubsection{The \ac{OSLC} Automation Layer}\label{sec:auto_layer}

% The \ac{OSLC} Automation Layer needs to fulfill requirements RQ21 and RQ22 from Section~\ref{sec:problem_overview}.
% Requirement RQ21 stated that the automation service has to offer the means to interact with it via \ac*{OSLC}.
% On the other hand, requirement RQ22 established that the automation rules managed by the service need a semantic model for interoperability.
% Two submodules are included in the \ac{OSLC} Automation Layer to meet these requirements: an \textbf{\ac*{OSLC} Automation Server} and a \textbf{Semantic \ac*{TAS}}.
% Figure~\ref{fig:automation_module} shows the architecture of the whole \ac{OSLC} Automation Layer.

% \begin{figure}[!ht]
%     \centering
%     \includegraphics[width=0.8\textwidth]{figures/architecture/automation.png}
%     \caption{\ac{OSLC} Automation Layer architecture.}\label{fig:automation_module}
% \end{figure}

% The \textbf{\ac*{OSLC} Automation Server} is basically an \ac*{OSLC} adapter for the Semantic \ac*{TAS}.
% It contains the same elements as any other adapter.
% An Event Listener listens to events from the \ac*{DML} that come from all the different services in the architecture.
% These are translated appropriately and sent to the \ac*{TAS}.
% If an action is generated due to the execution of a rule, an Action Dispatcher standardizes it using the semantic model from Section~\ref{sec:semantic_model}.
% It then publishes the action to the \ac*{DML} to be delivered to the corresponding service.

% Regarding the \textbf{Semantic \ac*{TAS}}, the \ac*{EWE} ontology has been selected to model the automation rules.
% The implementation of the \ac*{TAS} needs to have an API so that the adapter can communicate with it and a rule engine capable of evaluating events and returning actions accordingly.
% A \ac*{TAS} implementation that uses this model is \ac*{EWE} Tasker (\citet{munozSmartOfficeAutomation2016}).
% In \ac*{EWE} Tasker, rule evaluation is performed by an engine capable of making inferences using Notation3 formulas (\citet{berners-leeNotation3N3Readable2011}).
% This rule engine is based on the \ac{EYE} reasoner (\citet{verborghDrawingConclusionsLinked2015}).
% A \ac*{TAS} like this meets the requirements to be included in the architecture.

% Figure~\ref{fig:exec_process} shows a BPMN diagram representing the execution process of an automated workflow.
% It follows every step from an event generated in one service until an action is executed in another.

% \begin{figure}[!ht]
%     \centering
%     \includegraphics[width=0.9\textwidth]{figures/bpmn/workflow.png}
%     \caption{\ac*{BPMN} diagram showing the execution process.}\label{fig:exec_process}
% \end{figure}

% When a service generates an event at the Service Layer, it is notified to the Event Listener in that service's \ac*{OSLC} adapter.
% The system used for this notification process depends on the implementation of the service.
% The Event Listener translates it to \ac*{OSLC} vocabulary, exposes it as an HTTP resource, and saves a log in the \ac*{TRS}.
% Finally, it sends the event to the \ac*{DML} using the appropriate topic.

% The Event Listener in the \ac*{OSLC} Automation Server receives the event and repeats the same process.
% The event triples are sent to the Semantic \ac*{TAS}, which evaluates it with its Rule Engine.
% If it finds a rule triggered by that specific event, an action is returned to the \ac*{OSLC} Automation Server.
% The Action Dispatcher processes it and sends it back to the related topic of the \ac*{DML}.

% The \ac*{OSLC} adapter of the corresponding service receives the action.
% Its Action Dispatcher is in charge of logging, processing, and executing it.
% This completes the execution process.

\subsection{Worked Example of an ECA-based automation in the motivational scenario}\label{sec:case_study}

% intro
This section presents a worked example with a practical architecture implementation involving two real-world services.
Its goal is to demonstrate that the proposed model enabled an architecture that can meet the requirements defined in Section~\ref{sec:problem_overview}.
The issues and requirements defined in that section are addressed throughout this worked example.
The chosen tools are Bugzilla~\citep{Bugzilla}, a bug tracking web service, and GitHub \citep{GitHub}, a git-based version control tool.
Both tools are well known and widely used in the software development industry.
Also, \ac*{OSLC} already provides a Change Management domain to model bug tracking tools.
This presents an opportunity to show how the model integrates with other parts of \ac*{OSLC}.
All the code is available in a public repository\footnote{Worked example source code: \url{https://github.com/gsi-upm/oslc-eca_environment}}.

% historieta
A practical example is introduced where this integration could be helpful. A company that has already adopted some DevOps practices. The development team uses GitHub repositories to manage the code of the applications they are working on. They are also using GitHub issues for change management. GitHub offers integration with many tools, and the development team uses some of them for CI/CD\@. For example, they have an automated workflow that deploys a new version of an application when a pull request to the main branch is accepted. This workflow is only executed if there are no open issues with a \say{critical} label.

Working on the same project, another team is in charge of testing the application. This team wants to use Bugzilla instead of GitHub issues to keep track of the bugs and errors they find. A reason they want this could be, for example, because Bugzilla is open source and can be hosted by them. The development team needs to be aware of this new tool and integrate it into their automated workflows, so the application is not deployed while there are unresolved bugs (issue \textbf{IS1}). To save the work of manually doing this, they could use some already developed solutions to integrate GitHub and Bugzilla, such as GitZilla~\citep{geraGitZilla2021}. However, this approach makes them more dependent on these tools. As established by issue \textbf{IS2}, the tools and environments in DevOps change all the time. The testing team might want to move to a different bug tracking tool in the future. To avoid these issues and meet the requirement \textbf{RQ1}, the company decides to use \ac*{OSLC} standardized interfaces to integrate both tools.

% bugzilla adapter
Adapters must be built because none of these services are natively integrated with \ac{OSLC} or \ac{TRS}.
This tool is based on the \ac*{ECA} model: it receives events from other services, evaluates internal rules, and sends back actions for execution.
An adapter has already been implemented for Bugzilla as part of a tutorial on \ac{OSLC} made by some Core committee members\footnote{OSLC Bugzilla tutorial: \url{https://oslc.github.io/developing-oslc-applications/integrating_products_with_oslc/running_the_examples}}. Bugzilla classifies its \say{bugs} into \say{products}. Hence, the adapter chooses these elements as its \ac{OSLC} resources and \oslc{ServiceProviders}. It operates in the Change Management domain. Whenever a bug is created or updated, it is reflected in the \ac{TRS} server provided by the adapter.

% github adapter
GitHub has no \ac{OSLC} capabilities implemented but provides a REST API with all the necessary features to implement an \ac{OSLC} server. For this worked example, the resources of interest on GitHub are its \say{issues}, as they are closely related to bugs in Bugzilla. The concept of \say{repository} is chosen as \oslc{ServiceProvider} and Change Management as the domain. GitHub also offers a webhook-based notification system whenever an event occurs. The \ac{TRS} server can be updated without periodically polling the API to check for changes with this feature.

% They are concerned about being locked into a specific \ac*{TAS}, so they choose \ac*{EWE} Tasker for its support of interoperable semantically modeled rules.
The development team uses a \ac*{TAS} to implement its automation rules keeping its architecture modular.
Because the rest of the tools they are using are integrated with \ac*{OSLC}, they implement an \ac*{OSLC} interface to interact with the \ac*{TAS} in a standardized way. These decisions are consistent with the requirement \textbf{RQ2}. Three workflows are defined to synchronize the services using these events and actions. Table~\ref{tab:table_workflows} illustrates how these workflows and their respective rules operate.

% \renewcommand{\arraystretch}{2}
\begin{table}[!ht]
    \centering
    \begin{tabular}{cccc} 
        \toprule
        \multicolumn{2}{l}{\multirow{2}{*}{}} & \multicolumn{2}{c}{Workflows}                                                               \\ 
        \cmidrule(lr){3-4}
        \multicolumn{2}{l}{}                   & Bugzilla to GitHub                         & GitHub to Bugzilla                            \\ 
        \midrule
        \multirow{3}{*}{Rules} & Create        & \(Bug\:created \rightarrow Create\:issue\) & \(Issue\:created \rightarrow Create\:bug\)    \\ 
        \cmidrule(lr){2-4}
                               & Update        & \(Bug\:updated \rightarrow Update\:issue\) & \(Issue\:updated \rightarrow Update\:bug\)  \\
        \cmidrule(lr){2-4}
                               & Resolve        & \(Bug\:resolved \rightarrow Close\:issue\) & \(Issue\:closed \rightarrow Resolve\:bug\)  \\
        \bottomrule
    \end{tabular}
    \caption{Workflows and rules defined for the worked example.}\label{tab:table_workflows}
\end{table}
% \renewcommand{\arraystretch}{1}

To support standardized logging and monitoring of their services (\textbf{RQ3}), they use \ac*{TRS} servers to expose changes in every \ac*{OSLC} resource. In addition, they use Apache Kafka to send messages between servicest to maintain scalability as their automation environment grows (\textbf{RQ4}).

Figure~\ref{fig:case_study} shows the complete implementation of the architecture for the exposed worked example. The diagram shows the workflow where a bug is created using Bugzilla, and an issue is automatically generated on GitHub following the \ac*{OSLC} \ac*{ECA} proposed extension.

\begin{figure}[!ht]
    \centering
    \includegraphics[width=\textwidth]{figures/architecture/case_study.png}
    \caption{Workflow detailed in the worked example, where the creation of a bug in Bugzilla triggers the generation of an issue in GitHub.}\label{fig:case_study}
\end{figure}

% ejecución
Following the diagram steps (Figure~\ref{fig:case_study}), the workflow starts with a bug creation in Bugzilla (Step 1).
To describe resources for bug tracking like this, \ac*{OSLC} provides the Change Management domain~\citep{amsdenOSLCChangeManagement2020}.
The \ac*{OSLC} Bugzilla adapter uses this domain's \textit{oslc\_cm:ChangeRequest} class to model bugs.
Listing~\ref{listing:bug} shows the example resource generated from the created bug in Notation 3 language.

\begin{lstlisting}[caption={\ac{RDF} representing the bug created in Bugzilla.}, label={listing:bug}]
@prefix bgz: <http://www.bugzilla.org/rdf#> .
@prefix oslc: <http://open-services.net/ns/core#> .
@prefix dcterms: <http://purl.org/dc/terms/> .
@prefix oslc_cm: <http://open-services.net/ns/cm#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

<http://bugzilla.example.com/ServiceProvider/1/bugs/1> a oslc_cm:ChangeRequest ;
    oslc_cm:severity "enhancement"^^xsd:string ;
    oslc_cm:status "CONFIRMED"^^xsd:string ;
    oslc:serviceProvider <http://bugzilla.example.com/ServiceProvider/1> ;
    dcterms:contributor "admin"^^xsd:string ;
    dcterms:created "2021-12-10T07:07:33+00:00"^^xsd:dateTime ;
    dcterms:identifier "1"^^xsd:integer ;
    dcterms:modified "2021-12-10T07:07:33+00:00"^^xsd:dateTime ;
    dcterms:title "Testing bug to issue automation"^^xsd:string ;
    bgz:component "TestComponent"^^xsd:string ;
    bgz:operatingSystem "Linux"^^xsd:string ;
    bgz:platform "PC"^^xsd:string ;
    bgz:priority "---"^^xsd:string ;
    bgz:version "unspecified"^^xsd:string .    
\end{lstlisting}

The creation is notified to the Event Listener of its \ac*{OSLC} adapter, which sends an \ac*{OSLC} modeled event containing all the bug's properties to the Apache Kafka server (Step 2).
Listing~\ref{listing:bugzilla_event} shows an example of such an \events{Event} and its corresponding \events{EventListener}.

\begin{lstlisting}[caption={\ac{RDF} representing an event generated by the creation of a bug.}, label={listing:bugzilla_event}]
    @prefix oslc: <http://open-services.net/ns/core#> .
    @prefix oslc_auto: <http://open-services.net/ns/auto#> .
    @prefix oslc_eca: <http://open-services.net/ns/eca#> .
    @prefix dcterms: <http://purl.org/dc/terms/> .
    @prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
    @prefix example: <http://subclass.example.com#> .

    <http://bugzilla.example.com/ServiceProvider/1/Events/1> a oslc_eca:Event ,
            a example:BugCreationEvent ;
        oslc:serviceProvider <http://bugzilla.example.com/ServiceProvider/1> ;
        oslc_eca:generatedBy <http://bugzilla.example/EventListener/1> ;
        oslc_eca:causedBy <http://bugzilla.example.com/ServiceProvider/1/bugs/1> ;
        dcterms:created "2021-07-14T07:07:33+00:00"^^xsd:dateTime ;
        dcterms:title "Event generated by the creation of a bug"^^xsd:string .
\end{lstlisting}

%     <http://bugzilla.example.com/EventListener/1> a oslc_eca:EventListener ;
%         oslc_eca:source <http://bugzilla.example.com> ;
%         dcterms:title "Listener detecting events from  Bugzilla"^^rdf:XMLLiteral .
% \end{lstlisting}

The \ac*{OSLC} Bugzilla adapter also generates a changelog for the \ac*{TRS} server (Step 3).
It contains two \trs{Creation} resources pointing at the bug created and the event resource generated by the event listener.
The changelog is shown in Listing~\ref{listing:trs}.

\begin{lstlisting}[caption={\ac{RDF} representing the \ac*{TRS} logs that register the creation of the bug and its consequent event.}, label={listing:trs}]
    @prefix trs: <http://open-services.net/ns/core/trs#> .
    @prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

    <http://bugzilla.example.com/trs/ChangeLog/1> a trs:ChangeLog ;
        trs:change [
            a trs:Creation ;
            trs:order "1"^^xsd:integer ;
            trs:changed <http://bugzilla.example.com/ServiceProvider/1/bugs/1> .
        ] ;
        trs:change [
            a trs:Creation ;
            trs:order "2"^^xsd:integer ;
            trs:changed <http://bugzilla.example.com/ServiceProvider/1/Events/1> .
        ] .
\end{lstlisting}

The event is then pushed to the \ac*{OSLC} Automation Server (Step 4), which sends it to the \ac*{TAS} in the corresponding format.
The \ac*{TAS} evaluates its automation rules and returns an action to the \ac*{OSLC} Automation Server.
The \ac*{OSLC} Automation Server stores a changelog in its \ac*{TRS} server, registering the creation of the corresponding AssertedCondition (Step 5).
Listing~\ref{listing:trs_auto} shows an \ac{RDF} representation of this changelog.

\begin{lstlisting}[caption={\ac{RDF} representing the \ac*{TRS} log message generated at the Automation Server.}, label={listing:trs_auto}]
    @prefix oslc_eca: <http://open-services.net/ns/eca#> .
    @prefix trs: <http://open-services.net/ns/core/trs#> .
    @prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

    <http://auto.server/AssertedCondition/1> a oslc_eca:AssertedCondition ;
            oslc_eca:asserts <http://auto.server/ServiceProvider/1/Rule/1> ;
            oslc_eca:produces <http://auto.server/Action/1> ;
            oslc_eca:asserted "true"^^xsd:boolean .

    <http://auto.server/trs/ChangeLog/1> a trs:ChangeLog ;
        trs:change [
            a trs:Creation ;
            trs:order "1"^^xsd:interger ;
            trs:changed <http://auto.server/AssertedCondition/1> .
        ] .
\end{lstlisting}

%     <http://auto.server/ServiceProvider/1/AssertedCondition/1> a oslc_eca:AssertedCondition ;
%         oslc_eca:asserts <http://auto.server/ServiceProvider/1/Rule/1> ;
%         oslc_eca:produced <http://auto.server/Action/1> .
% \end{lstlisting}

Then, the \ac*{OSLC} Automation Server sends an action back to the Apache Kafka server (Step 6).
The \auto{status} and \auto{verdict} properties also indicate that it is still in process of being executed.
For this specific \textit{example:CreateIssueAction}, which is described by a ResourceShape not included for the sake of brevity, the \textit{example:originalChangeRequest} property links to the bug created previously in Bugzilla, which will be the source of information when GitHub's Action Dispatcher would execute the action.
Listing~\ref{listing:github_action} shows the Notation 3 code for this example \actions{Action}.

\begin{lstlisting}[caption={\ac{RDF} representing an action sent for execution to create a GitHub issue.}, label={listing:github_action}]
    @prefix oslc: <http://open-services.net/ns/core#> .
    @prefix oslc_eca: <http://open-services.net/ns/eca#> .
    @prefix oslc_auto: <http://open-services.net/ns/auto#> .
    @prefix oslc_cm: <http://open-services.net/ns/cm#> .
    @prefix dcterms: <http://purl.org/dc/terms/> .
    @prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
    @prefix example: <http://subclass.example.com#> .

    <http://auto.server/Action/1> a oslc_eca:Action,
            example:CreateIssueAction ;
        oslc:serviceProvider <http://github.example.com/ServiceProvider/1> ;
        oslc_actions:executedBy <http://github.example.com/ActionDispatcher/1> ;
        oslc_auto:status oslc_auto:new ;
        oslc_auto:veredict oslc_auto:unavailable ;
        example:originalChangeRequest <http://bugzilla.example.com/ServiceProvider/1/bugs/1> ;
        dcterms:created "2021-07-14T07:07:33+00:00"^^xsd:dateTime ;
        dcterms:title "Action to be executed on GitHub"^^xsd:string .
        
    <http://auto.server/Action/1/versions/1>  dcterms:isVersionOf    
            <http://auto.server/Action/1> .
\end{lstlisting}

%         oslc_actions:executedOn <http://github.example.com/OSLCResource/1> ;
%         dcterms:created "2021-07-14"^^xsd:dateTime ;
%         dcterms:title "Action executed on GitHub"^^rdf:XMLLiteral .

%     <http://github.example.com/ActionDispatcher/1> a oslc_eca:ActionDispatcher ;
%         oslc:serviceProvider <http://github.example.com/ServiceProvider/1> ;
%         oslc:resourceShape <http://github.example.com/CustomAction/resourceShape> ;
%         oslc_actions:execute <http://github.example.com/url/to/post/actions/to/execute> ;
%         dcterms:title "Dispatcher that exposes actions from GitHub"^^rdf:XMLLiteral .
% \end{lstlisting}

The action is delivered to the Action Dispatcher of the GitHub \ac*{OSLC} adapter (Step 7).
It then modifies the action's status and sets it to queued.
A \ac{TRS} changelog is generated representing this update.
It uses \ac{TRS} patch to show what properties changed and is displayed in Listing~\ref{listing:action_update}.

\begin{lstlisting}[caption={\ac{RDF} of a \ac{TRS} changelog showing the changes in an action status.}, label={listing:action_update}]
    @prefix xsd: <http://www.w3.org/2001/XMLSchema#>.
    @prefix dcterms: <http://purl.org/dc/terms/> .
    @prefix trs: <http://open-services.net/ns/core/trs#>.
    @prefix trspatch: <http://open-services.net/ns/core/trspatch#>.
    @prefix oslc_auto: <http://open-services.net/ns/auto#> .
    
    <http://github.example.com/trs/ChangeLog/1> a trs:ChangeLog ;
        trs:change [
            a trs:Creation;
            trs:changed <http://auto.server/Action/1/version/2>;
            trs:order "2"^^xsd:integer;
            trspatch:createdFrom <http://auto.server/Action/1/version/1>;
            trspatch:rdfPatch
                """
                D <http://auto.server/Action/1/versions/1>  dcterms:isVersionOf    
                        <http://auto.server/Action/1> .
                A <http://auto.server/Action/1/versions/2>  dcterms:isVersionOf          
                        <http://auto.server/Action/1> .
                D <http://auto.server/Action/1> oslc_auto:status oslc_auto:new.
                A <http://auto.server/Action/1> oslc_auto:status oslc_auto:queued.
                """ .
            ] .
\end{lstlisting}

The adapter then uses GitHub's API to create the issue described by the action parameters (Step 8).
Listing~\ref{listing:issue} showcases the newly created issue \ac*{RDF} representation.

% % \todo{RDF issue example}
\begin{lstlisting}[caption={\ac{RDF} representing the issues created in GitHub.}, label={listing:issue}]
    @prefix dcterms <http://purl.org/dc/terms/> .
    @prefix oslc_cm: <http://open-services.net/ns/cm#> .
    @prefix oslc: <http://open-services.net/ns/core#> .
    @prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

    <http://github.example.com/ServiceProvider/1/issue/1> a oslc_cm:ChangeRequest ;
        oslc_cm:status "open"^^xsd:string ;
        oslc:serviceProvider <http://github.example.com/ServiceProvider/1 ;
        dctermscontributor "admin"^^xsd:string ;
        dcterms:created "2021-12-10T07:07:33+00:00"^^xsd:dateTime ;
        dctermsidentifier "1"^^xsd:integer ;
        dcterms:modified "2021-12-10T07:07:33+00:00"^^xsd:dateTime ;
        dcterms:title "Testing bug to issue automation"^^xsd:string .
\end{lstlisting}

Finally, the adapter sends the corresponding changelog to its \ac*{TRS} server (Step 9), registering the creation of the issue, as shown in Listing~\ref{listing:issue_trs}.
It also signals the update of the action to have its \actions{executedOn} property pointing to the appropriate resource, which was just created.

\begin{lstlisting}[caption={\ac*{RDF} representing a \ac*{TRS} log registering the correct execution of the action.}, label={listing:issue_trs}]
    @prefix trs: <http://open-services.net/ns/core/trs#> .
    @prefix oslc_auto: <http://open-services.net/ns/auto#> .
    @prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

    <http://github.example.com/trs/ChangeLog/2> a trs:ChangeLog ;
        trs:change [
            a trs:Creation ;
            trs:order "1"^^xsd:integer ;
            trs:changed <http://github.example.com/ServiceProvider/1/issue/1> .
        ] ;
        trs:change [
            a trs:Modification ;
            trs:order "2"^^xsd:integer ;
            trs:changed <http://auto.server/Action/1> ;
            trspatch:createdFrom <http://auto.server/Action/1/version/2>;
            trspatch:rdfPatch
                """
                D <http://auto.server/Action/1/versions/2>  dcterms:isVersionOf    
                        <http://auto.server/Action/1> .
                A <http://auto.server/Action/1/versions/3>  dcterms:isVersionOf          
                        <http://auto.server/Action/1> .
                D <http://auto.server/Action/1> oslc_auto:status oslc_auto:queued.
                A <http://auto.server/Action/1> oslc_auto:status oslc_auto:completed.
                D <http://auto.server/Action/1>      oslc_auto:veredict oslc_auto:unavailable ;
                A <http://auto.server/Action/1>      oslc_auto:veredict oslc_auto:passed ;
                A <http://auto.server/Action/1> oslc_eca:executedOn
                        <http://github.example.com/ServiceProvider/1/issue/1>.
                """ .
            ] .
        ] .
\end{lstlisting}

% resumen final
To summarize, the worked example presents a practical implementation of the architecture based on the proposed \ac*{OSLC} extension to support events and actions. It meets the requirements to address the common issues faced when adopting DevOps. Because both services are integrated using \ac*{OSLC} interfaces, requirement RQ1 is fulfilled, making integrating new services more straightforward and efficient. Automation is separated into its own service accessible via \ac*{OSLC}, satisfying requirement RQ2. Traceability is managed with the \ac*{TRS} protocol, a standard within \ac*{OSLC}, and meets requirement RQ3. Finally, requirement RQ4 is fulfilled because the components are loosely coupled, and a distributed service handles messaging, allowing the architecture to scale horizontally.












% inicialización EventListeners
% Before the workflow can be executed, the \ac{OSLC} Automation Server needs to be initialized.
% There are two \ac{TRS} servers it needs to listen to, so a \events{EventListener} is created for each one.
% The \ac{OSLC} Automation Server creation URL request contains the following \events{EventListener}.
% Creating each \events{EventListener} initializes an \ewe{Channel} in the \ac{TAS} representing the events interface from each tool.

% \begin{lstlisting}[caption={\ac{RDF} representation of the \events{EventListener} that tracks changes from the Bugzilla \ac{TRS} server.}]
% @prefix oslc: <http://open-services.net/ns/core#> .
% @prefix oslc_events: <http://open-services.net/ns/events#> .
% @prefix trs: <http://open-services.net/ns/core/trs#> .
% @prefix dcterms: <http://purl.org/dc/terms/> .
% @prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .

% <bugzillaEventListener_url> a oslc_events:EventListener ;
%     oslc:serviceProvider <oslcAutomationServiceProvider_url> ;
%     oslc_events:source <bugzillaTrackedResourceSet_url> ;
%     dcterms:title "Listener detecting events from Bugzilla"^^rdf:XMLLiteral .
% \end{lstlisting}

% % inicialización ActionDispatchers
% Once the \events{EventListeners} are created, the Automation Server starts listening for events in both services.
% An \actions{ActionDispatcher} has to be created for each service, so the Automation Server can discover the available \actions{Actions} they provide.
% The following \ac{RDF} represents the \actions{ActionDispatcher} after discovering the actions provided by GitHub.
% Besides the basic creation and update actions through regular HTTP requests, an \actions{PotentialAction} is found, the \actions{ResolveChangeRequest} action.
% Creating these \actions{ActionDispatchers} updates the \ewe{Channels} representing the services with their actions interfaces.

% \begin{lstlisting}[caption={\ac{RDF} representation of the \events{EventListener} that tracks changes from the Bugzilla \ac{TRS} server.}]
% @prefix oslc: <http://open-services.net/ns/core#> .
% @prefix oslc_actions: <http://open-services.net/ns/actions#> .
% @prefix dcterms: <http://purl.org/dc/terms/> .
% @prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .

% <githubActionDispatcher_url> a oslc_actions:ActionDispatcher ;
%     oslc:serviceProvider <oslcAutomationServiceProvider_url> ;
%     oslc_actions:actionProvider <githubServiceProvider_url> ;
%     oslc_actions:supportedAction <bugzillaResolveChangeRequestPotentialAction_url> ;
%     dcterms:title "Action dispatcher that discovered actions from GitHub"^^rdf:XMLLiteral .
% \end{lstlisting}

% % definición de reglas
% After the \ac{OSLC} Automation Server has started listening for events and has discovered the available actions, rule definition is possible via \ac{EWE} Tasker.
% \ewe{Rules} are written in Notation 3, a compact and readable alternative to RDF's XML syntax. \ac{EWE} Tasker uses the \ac{EYE} reasoner from \citet{verborghDrawingConclusionsLinked2015} to evaluate the events.
% \ac{EYE} stands for \say{Euler Yet another proof Engine}, and it is a further incremental development of Euler, an inference engine supporting logic-based proofs.
% It uses \ac{FOL} to perform the reasoning, expressed with Notation 3 logic.
% This allows us to make an inference like \({  ?x a :Person }  => { ?x  :mother [ a :Person] }\).
% In this case, the evaluated event is on the left side of the formula and the resulting action on the right side.
% Following this method, an \ewe{Rule} can be defined.
% It will be triggered by a bug creation event and execute an issue creation action in consequence.
% The corresponding \auto{AutomationPlan} is also created, allowing \ac{OSLC} services to discover the workflow.

% % paso 1: se crea el bug
% When a bug is created in the Bugzilla client application, an \ac{OSLC} resource representation is exposed in the server.
% This resource is of the type \oslccm{ChangeRequest}, one of the domains defined by the \ac{OSLC} specification.
% It has a set of properties, some of them are present in every \oslccm{ChangeRequest} and others are specific to Bugzilla bugs.
% The following \ac{RDF} represents a generic bug.

% \begin{lstlisting}[caption={Bug \ac{RDF} example.}]
% @prefix bgz: <http://www.bugzilla.org/rdf#> .
% @prefix oslc: <http://open-services.net/ns/core#> .
% @prefix dcterms: <http://purl.org/dc/terms/> .
% @prefix oslc_cm: <http://open-services.net/ns/cm#> .
% @prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
% @prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

% <bug_url> a oslc_cm:ChangeRequest ;
%     oslc_cm:severity "enhancement" ;
%     oslc_cm:status "CONFIRMED" ;
%     oslc:serviceProvider <bugzillaServiceProvider_url> ;
%     dcterms:contributor "admin" ;
%     dcterms:created "2021-12-10T07:07:33+00:00"^^xsd:dateTime ;
%     dcterms:identifier 1 ;
%     dcterms:modified "2021-12-10T07:07:33+00:00"^^xsd:dateTime ;
%     dcterms:title "Testing bug to issue automation"^^rdf:XMLLiteral ;
%     bgz:component "TestComponent" ;
%     bgz:operatingSystem "Linux" ;
%     bgz:platform "PC" ;
%     bgz:priority "---" ;
%     bgz:version "unspecified" .    
% \end{lstlisting}

% % paso 2: se detecta el evento
% In the Bugzilla \ac{TRS} server, a new \trs{ChangeEvent} is added to the \trs{ChangeLog}.
% The \ac{TRS} client in the \ac{OSLC} Automation Server discovers this new modification and reads the URI of the \ac{OSLC} resource that has suffered the change.
% The type of modification is a \trs{Creation}.
% The moment it is detected, an \auto{AutomationRequest} (which is a subclass of \events{Event}) is created and exposed in the Automation Server.
% This resource is also an \ewe{Event} and is sent to \ac{EWE} Tasker for evaluation.

% \begin{lstlisting}[caption={\ac{RDF} representing an event generated by the creation of a bug.}]
% @prefix oslc: <http://open-services.net/ns/core#> .
% @prefix oslc_auto: <http://open-services.net/ns/auto#> .
% @prefix oslc_events: <http://open-services.net/ns/events#> .
% @prefix trs: <http://open-services.net/ns/core/trs#> .
% @prefix ewe: <http://gsi.dit.upm.es/ontologies/ewe/ns/> .
% @prefix dcterms: <http://purl.org/dc/terms/> .
% @prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .

% <event_url> a ewe:Event,
%         oslc_events:Event,
%         oslc_auto:AutoamtionRequest,
%         trs:Creation ;
%     oslc:serviceProvider <oslcAutomationServiceProvider_url> ;
%     trs:changed <bug_url> ;
%     oslc_events:generatedBy <bugzillaEventListener_url> ;
%     dcterms:title "Event generated by the creation of a bug"^^rdf:XMLLiteral .
% \end{lstlisting}

% % paso 3: se evalúan las reglas
% \ac{EWE} Tasker receives the event.
% Every \ewe{Rule} stored in the \ac{TAS} is evaluated using the \ac{EYE} reasoning engine.
% The \ewe{Rule} defined in the initialization step (which \ac{RDF} is shown below) is triggered.
% This results in the execution of a creation action.

% \begin{lstlisting}[caption={\ac{RDF} representing an \ewe{Rule} which sends a creation action to GitHub when it receives a creation event from Bugzilla.}]
% @prefix oslc: <http://open-services.net/ns/core#> .
% @prefix oslc_cm: <http://open-services.net/ns/cm#> .
% @prefix oslc_auto: <http://open-services.net/ns/auto#> .
% @prefix oslc_events: <http://open-services.net/ns/events#> .
% @prefix oslc_actions: <http://open-services.net/ns/actions#> .
% @prefix trs: <http://open-services.net/ns/core/trs#> .
% @prefix ewe: <http://gsi.dit.upm.es/ontologies/ewe/ns/> .
% @prefix dcterms <http://purl.org/dc/terms/> .
% @prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
% @prefix http: <http://www.w3.org/2011/http#> .
% @prefix http-methods: <http://www.w3.org/2011/http-methods#> .

% {
%     ?event a ewe:Event,
%             oslc_events:Event,
%             oslc_auto:AutoamtionRequest,
%             trs:Creation ;
%         oslc:serviceProvider <oslcAutomationServiceProvider_url> ;
%         trs:changed <bug_url> ;
%         oslc_events:generatedBy <bugzillaEventListener_url> .
%     <bug_url> a oslc_cm:ChangeRequest ;
%         dcterms:title ?title ;
%         dcterms:contributor ?contributor ;
%         oslc:serviceProvider <bugzillaServiceProvider_url> ;
%         oslc_cm:status ?status .
% } => {
%     oslc_actions:action1 a oslc_actions:Action,
%         a oslc_actions:CreateChangeRequestAction,
%         ewe:Action ;
%         oslc_actions:executes <bugzillaResolveChangeRequestPotentialAction_url> ;
%         oslc_actions:binding [
%             a http:Request ;
%             http:mthd http-methods:POST ;
%             http:requestURI <githubCreation_url> ;
%             http:body [
%                 a oslc_cm:ChangeRequest
%                 dcterms:title ?title ;
%                 dcterms:contributor ?contributor ;
%                 oslc:serviceProvider <githubServiceProvider_url> ;
%                 oslc_cm:status ?status .
%             ]
%         ]        
% }.
% \end{lstlisting}

% % paso 4: se ejecuta la acción
% The triples in the first formula determine that the rule is executed when the subject is an \ewe{Event} and an \auto{AutomationRequest}.
% This event is also a \trs{Creation} and points at the newly created bug URL\@.
% The values from some properties, like title and status, are stored in variables and retrieved when generating the action.
% In the second formula, an \ewe{Action} of the type \actions{CreateChangeRequestActions} is obtained due to the inference. 
% This action uses the previously stored variables to generate the corresponding GitHub issue. 
% The \actions{binding} on the action represents the HTTP request sent to create this issue.
% The \ac{OSLC} adapter exposes the \ac{RDF} representing the issue while creating the actual issue via the GitHub API\@.

% % \todo{RDF issue example}
% \begin{lstlisting}[caption={Issue \ac{RDF}.}]
% @prefix dcterms <http://purl.org/dc/terms/> .
% @prefix oslc_cm: <http://open-services.net/ns/cm#> .
% @prefix oslc: <http://open-services.net/ns/core#> .
% @prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
% @prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

% <issue_url> a oslc_cm:ChangeRequest ;
%     oslc_cm:status "open" ;
%     oslc:serviceProvider <githubServiceProvider_url> ;
%     dctermscontributor "admin" ;
%     dcterms:created "2021-12-10T07:07:33+00:00"^^xsd:dateTime ;
%     dctermsidentifier 1 ;
%     dcterms:modified "2021-12-10T07:07:33+00:00"^^xsd:dateTime ;
%     dcterms:title "Testing bug to issue automation"^^rdf:XMLLiteral .
% \end{lstlisting}

% % fin del worflow
% To complete the workflow, both the \events{Event} and \actions{Action} involved are exposed by the \ac{OSLC} Automation Server.
% An \auto{AutomationResult} is also exposed, pointing at both resources and the \auto{AutomationPlan} executed.
% Its \auto{verdict} property shows an \auto{passed} \ac{RDF} value, which means the \auto{AutomationPlan} it reports on was run successfully.
%     oslc_actions:action1 a oslc_actions:Action,
%         a oslc_actions:CreateChangeRequestAction,
%         ewe:Action ;
%         oslc_actions:executes <bugzillaResolveChangeRequestPotentialAction_url> ;
%         oslc_actions:binding [
%             a http:Request ;
%             http:mthd http-methods:POST ;
%             http:requestURI <githubCreation_url> ;
%             http:body [
%                 a oslc_cm:ChangeRequest
%                 dcterms:title ?title ;
%                 dcterms:contributor ?contributor ;
%                 oslc:serviceProvider <githubServiceProvider_url> ;
%                 oslc_cm:status ?status .
%             ]
%         ]        
% }.
% \end{lstlisting}

% % paso 4: se ejecuta la acción
% The triples in the first formula determine that the rule is executed when the subject is an \ewe{Event} and an \auto{AutomationRequest}.
% This event is also a \trs{Creation} and points at the newly created bug URL\@.
% The values from some properties, like title and status, are stored in variables and retrieved when generating the action.
% In the second formula, an \ewe{Action} of the type \actions{CreateChangeRequestActions} is obtained due to the inference. 
% This action uses the previously stored variables to generate the corresponding GitHub issue. 
% The \actions{binding} on the action represents the HTTP request sent to create this issue.
% The \ac{OSLC} adapter exposes the \ac{RDF} representing the issue while creating the actual issue via the GitHub API\@.

% % \todo{RDF issue example}
% \begin{lstlisting}[caption={Issue \ac{RDF}.}]
% @prefix dcterms <http://purl.org/dc/terms/> .
% @prefix oslc_cm: <http://open-services.net/ns/cm#> .
% @prefix oslc: <http://open-services.net/ns/core#> .
% @prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
% @prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

% <issue_url> a oslc_cm:ChangeRequest ;
%     oslc_cm:status "open" ;
%     oslc:serviceProvider <githubServiceProvider_url> ;
%     dctermscontributor "admin" ;
%     dcterms:created "2021-12-10T07:07:33+00:00"^^xsd:dateTime ;
%     dctermsidentifier 1 ;
%     dcterms:modified "2021-12-10T07:07:33+00:00"^^xsd:dateTime ;
%     dcterms:title "Testing bug to issue automation"^^rdf:XMLLiteral .
% \end{lstlisting}

% % fin del worflow
% To complete the workflow, both the \events{Event} and \actions{Action} involved are exposed by the \ac{OSLC} Automation Server.
% An \auto{AutomationResult} is also exposed, pointing at both resources and the \auto{AutomationPlan} executed.
% Its \auto{verdict} property shows an \auto{passed} \ac{RDF} value, which means the \auto{AutomationPlan} it reports on was run successfully.ction} of the type \actions{CreateChangeRequestActions} is obtained due to the inference. 
% This action uses the previously stored variables to generate the corresponding GitHub issue. 
% The \actions{binding} on the action represents the HTTP request sent to create this issue.
% The \ac{OSLC} adapter exposes the \ac{RDF} representing the issue while creating the actual issue via the GitHub API\@.

% % \todo{RDF issue example}
% \begin{lstlisting}[caption={Issue \ac{RDF}.}]
% @prefix dcterms <http://purl.org/dc/terms/> .
% @prefix oslc_cm: <http://open-services.net/ns/cm#> .
% @prefix oslc: <http://open-services.net/ns/core#> .
% @prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
% @prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

% <issue_url> a oslc_cm:ChangeRequest ;
%     oslc_cm:status "open" ;
%     oslc:serviceProvider <githubServiceProvider_url> ;
%     dctermscontributor "admin" ;
%     dcterms:created "2021-12-10T07:07:33+00:00"^^xsd:dateTime ;
%     dctermsidentifier 1 ;
%     dcterms:modified "2021-12-10T07:07:33+00:00"^^xsd:dateTime ;
%     dcterms:title "Testing bug to issue automation"^^rdf:XMLLiteral .
% \end{lstlisting}

% % fin del worflow
% To complete the workflow, both the \events{Event} and \actions{Action} involved are exposed by the \ac{OSLC} Automation Server.
% An \auto{AutomationResult} is also exposed, pointing at both resources and the \auto{AutomationPlan} executed.
% Its \auto{verdict} property shows an \auto{passed} \ac{RDF} value, which means the \auto{AutomationPlan} it reports on was run successfully.

