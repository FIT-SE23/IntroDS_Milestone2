\section{OSLC Extension for ECA-based Automation}\label{sec:semantic_model}

This section showcases the main contribution of the paper which is the semantic model that extends \ac*{OSLC} to support \ac*{ECA}-based automation~\citep{OSLCExtensionECAbased}. Section~\ref{sec:event_modeling} details how events are proposed to work. Section~\ref{sec:action_modeling} presents an overview of the new actions vocabulary. Finally, Section~\ref{sec:rules} explains how automation rules are defined and provides a whole overview of the propoed \ac*{ECA} model. For the state of clarity, every new concept proposed in the paper uses the \textit{oscl\_eca} prefix.

\subsection{Event modeling}\label{sec:event_modeling}

% falta eventos ext
% As previously mentioned, there is a specific \ac*{OSLC} domain for Automation.
% However, key concepts are still missing for this model to meet the requirements of the proposed architecture.
% To run an \auto{AutomationPlan}, \ac*{OSLC} Automation requires a consumer to create an \auto{AutomationRequest} by making a POST request to the Automation server.
% The ideal scenario would be to have the Automation Server listening for events generated in another service by itself.
% This is what the Event Listener component described in the architecture does.
% To model this component with \ac*{OSLC}, an extension to the Automation domain is proposed.

This section details the psoposed model for integration events in \ac{OSLC}. A diagram is shown in Figure~\ref{fig:oslc_events} with these newly defined resources.
% Listing~\ref{listing:events} shows an example of an \events{Event} and its corresponding \events{EventListener} in Notation3 language.

\begin{figure}
    \centering
    \includegraphics[width=\textwidth]{figures/ontologies/oslc-events.png}
    \caption{Diagram of classes and properties for Events - OSLC ECA proposal.}\label{fig:oslc_events}
\end{figure}

% events
The philosophy followed by the \ac*{OSLC} standard is not to make assumptions about its tools and services. Therefore, the focus has to be on the concepts enabling interoperability. In the context of events, a concept needs to be defined so consumers can discover how to listen to a service generating them. For this purpose, the \events{EventListener} resource is defined.

An \events{EventListener} resource represents a backgorund process insida the service that listens to a source of events. Consumers can create an \events{EventListener} so it notifies them when an event occur. The source of these events could be many things depending on the service and is signaled by the \events{source} property. Other properties, required or optional, can be described by an \oslc{ResourceShape}, as in any other \ac*{OSLC} resource.

However, unlike other \ac*{OSLC} resources, interacting with it using CRUD actions is not enough. Although a consumer could periodically poll the service for new events, the optimal result would be for the service to asynchronously notify consumers. There are multiple options to do this, among others: using webhooks, providing a URL to the service to make POST request with the new events; with a publish-subscriber protocol, like MQTT which has been used before in a similar context~\citep{berezovskyiImprovingLifecycleQuery2018}; or using some messaging service that can deliver the events to their intended receivers.

There are too many possiblities to standardize all of them. To solve this issue, a concept known as interacion patterns can be borrow from the \ac*{OSLC} Actions proposal~\citep{painOSLCActions2020}. The idea is to determine which protocol to use depending on the type of resource pointed by a \events{binding} property. The simplest example is with a webhook. When the \events{binding} property is supposed to point at a \textit{http:Request}, then it means the service uses webhooks. A consumer could then create an \events{EventListener} providing a description of the \textit{http:Request} that wants to receive. This leaves the door open to new interaction patterns to join the standard in the future.

The events themselves are represented by an \ac{OSLC} resource named \events{Event}. Whenever an \events{EventListener} detects an event triggered by its sources, it creates and exposes an \events{Event}. Depending on the interaction pattern used by the service, it may also send the \events{Event} asynchronously (inside POST request, for example). Besides the \ac*{OSLC} stabdard properties and typical metadata annotations (like a title or a timestamp), an \events{Event} resource can have other service specific properties. An \oslc{ResourceShape} should describe all of the possible properties the event can contain. An \events{Event} also has the \events{generatedBy} and \events{causedBy} properties pointing at the \events{EventListener} and \ac*{OSLC} resource that produced it, respectively.

There is a relation between these events and the \ac*{OSLC} Automation domain. For example, an \events{Event} could be used to trigger \auto{AutomationPlans}. Hence, there should be a relationship between \events{Events} and \auto{AutomationRequests}. An \auto{AutomationRequest} could be started when the automation service receives an \events{Event}, so a new \events{triggeredBy} property is proposed for addition.

Before going into the next secton, another interaction pattern more suitable for DevOps scenarios needs to be explored. The webhook example served to illustrate how a simple interaction pattern could be defined but is not ideal for environments where scalability is critical. Using a message broker to deliver the events to consumers is a more appropriate solution. Tools like Apache Kafka~\citep{ApacheKafka} provide this kind of service and allow for more scalable architectures. For this reason, this interaction pattern is used in the architecture and worked example presented in Section~\ref{sec:evaluation} for the evaluation of the model.

Such an interaction pattern requires the \events{binding} to point at a resource representing the broker, with properties signaling a URL for providers to POST messages and a topic for conumers to subscribe. The \textit{kafka} prefix is used to model this service. The \kafka{Broker} resource is proposed to model the broker, along with the the \kafka{providerURL} and \kafka{topic} properties.

% \begin{lstlisting}[caption={Example of an \events{Event} and its \events{EventListener}.}, label={listing:events}]
%     @prefix oslc: <http://open-services.net/ns/core#> .
%     @prefix oslc_auto: <http://open-services.net/ns/auto#> .
%     @prefix oslc_events: <http://open-services.net/ns/events#> .
%     @prefix dcterms: <http://purl.org/dc/terms/> .
%     @prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .

%     <http://example.com/Event/1> a oslc_events:Event,
%             oslc_auto:AutomationRequest,
%         oslc:serviceProvider <http://example.com/ServiceProvider/1> ;
%         oslc_events:generatedBy <http://example.com/EventListener/1> ;
%         dcterms:title "Event generated by service X"^^rdf:XMLLiteral .
    
%     <http://example.com/EventListener/1> a oslc_events:EventListener ;
%         oslc_events:source <http://example.com/source/of/events> ;
%         dcterms:title "Listener detecting events from service X"^^rdf:XMLLiteral .
% \end{lstlisting}

\subsection{Action modeling}\label{sec:action_modeling}

This section presents the proposed model for actions in \ac{OSLC}.
Figure~\ref{fig:oslc_actions} shows a diagram representing its classes and properties, relations with other \ac{OSLC} concepts.

\begin{figure}
    \centering
    \includegraphics[width=\textwidth]{figures/ontologies/oslc-actions.png}
    \caption{Diagram of classes and properties for Actions - OSLC ECA proposal.}\label{fig:oslc_actions}
\end{figure}

% oslc acciones crud
% In addition to the Event Listener, the Action Dispatcher on an \ac{OSLC} adapter also needs modeling.
% \ac{OSLC} resources already support basic CRUD actions (create, read, update and delete).
% It was already mentioned how Service Providers enable resource creation and querying.
% The resources in \ac{OSLC} can also be updated or deleted using the corresponding HTTP methods (PUT and DELETE, respectively).

% % oslc actions
% The \ac{OSLC} community has shown efforts to support the execution of more concrete Actions (\citet{painOSLCActions2020}) over resources.
% This specification allows a service to perform actions on other service resources without knowing their type and properties.
% The document is a potential candidate for a future specification.
% It even suggests ideas of introducing Actions in the \ac{OSLC} Core Specification.

% oslc actions detalle
The starting point for the action model is the \ac{OSLC} Actions proposal, previously mentioned in Section~\ref{sec:background}. According to it, resources may have an \actions{action} property advertising possible actions that can be performed on them.
This property leads to \actions{Action} resources that describe the action and provide instructions to execute it and determine its result.
The information is provided through action bindings which can support multiple interaction patterns (i.e., HTTP request or UI dialog).
This is the same method mentioned for the events model proposed in the previous section. Making each resource expose its own available actions facilitates interoperability.

% oslc actions problemas
However, in many cases, resources from the same \oslc{ServiceProvider} and same domain have the same available actions.
It would be interesting to provide a way of discovering available actions for a whole set of resources in a Service Provider, instead of having to query specific resources to find them.
Also, the binding and interaction pattern mechanisms seem overly complicated in this case, as \ac*{OSLC} already has the concept of \oslc{ResourceShape} to indicate to consumers how to work with resources like \actions{Actions}.

% oslc actions ext
A different approach is proposed to solve these issues. The \actions{ActionDispatcher} resource is defined to represent the capability of the service to execute a specific action. Inspired by the \oslc{CreationFactory} and \oslc{QueryCapabilities} concepts, an \actions{ActionDispatcher} provides a URL where consumers can send post requests to execute the action it dispatches. The \actions{execution} data property signals this URL. Actions sent for execution can be queried using another URL provided by the \actions{ActionDispatcher} through the \actions{queryActions} predicate. These URLs are represented by \textit{ldp:Container} objects, like in the \ac*{OSLC} Core specification.

\actions{ActionDispatchers} also provide an \oslc{ResourceShape} to let consumers know the necessary properties to execute its \actions{Actions}. Individual resources can still indicate which actions are available for execution by pointing with an \actions{availableAction} to the corresponding \actions{ActionDispatcher}. Furthermore, an executed \actions{Action} points at its target resource with the \actions{executedOn} property. Finally, the \actions{Actions} contain a \actions{status} and \actions{verdict} properties indicating the execution result, similar to an \auto{AutomationRequest}.

% oslc automation + actions
The standard establishes a relation between the Automation and Actions specifications. Specific \actions{Actions} can become available (or be automatically executed) when an \auto{AutomationPlan} successfully finishes running. The \actions{futureAction} property was defined to identify them. In this extended model, \actions{futureAction} points to an \actions{ActionDispatcher} instead. The corresponding \auto{AutomationResult} indicates that the \actions{Action} is available for immediate execution.


% Next section evaluates the concepts defined in the proposed model by establishing a set of architectural requirements and testing them in a worked example.
% Listing~\ref{listing:actions} shows an example of an \actions{Action} and the \actions{ActionDispatcher} that executes it in Notation3 language.

% \begin{lstlisting}[caption={Example of an \actions{Action} and its \actions{ActionDispatcher}.}, label={listing:actions}]
%     @prefix oslc: <http://open-services.net/ns/core#> .
%     @prefix oslc_actions: <http://open-services.net/ns/actions#> .
%     @prefix dcterms: <http://purl.org/dc/terms/> .
%     @prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .

%     <http://example.com/Action/1> a oslc_actions:Action,
%             oslc_actions:CustomAction,
%         oslc:serviceProvider <http://example.com/ServiceProvider/1> ;
%         oslc_actions:executedBy <http://example.com/ActionDispatcher/1> ;
%         oslc_actions:executedOn <http://example.com/OSLCResource/1> ;
%         dcterms:title "Action executed on service Y"^^rdf:XMLLiteral .

%     <http://example.com/ActionDispatcher/1> a oslc_actions:ActionDispatcher ;
%         oslc:serviceProvider <http://example.com/ServiceProvider/1> ;
%         oslc:resourceShape <http://example.com/CustomAction/resourceShape> ;
%         oslc_actions:execute <http://example.com/url/to/post/actions/to/execute> ;
%         dcterms:title "Dispatcher that exposes actions from service Y"^^rdf:XMLLiteral .
% \end{lstlisting}

\subsection{Rule modeling}\label{sec:rules}

Besides events and actions, it is necessary to have a model for automation rules to fully represent an \ac*{ECA} environment.
These rules represent the conditions that need to be met for an event to trigger an automated action.
Figure~\ref{fig:oslc_rules} shows the whole model proposed in this work.

\begin{figure}
    \centering
    \includegraphics[width=\textwidth]{figures/ontologies/oslc-rules.png}
    \caption{Diagram of classes and properties for Rules - OSLC ECA proposal.}\label{fig:oslc_rules}
\end{figure}

An \eca{Rule} represents an automation rule.
It can point to an \events{Event} with an \eca{triggeredBy} property and to an \actions{Action} with an \eca{executedBy} predicate.
The \eca{consequenceOf} property is also defined for actions to point at events that caused them to be executed.

The \eca{AssertedCondtion} resource is defined to provide a means of discovering if some evaluation of a rule was successful.
When the rule is evaluated, an \eca{AssertedCondtion} is created pointing at the specific \actions{Action} generated with the \eca{produces} property.
The \eca{asserts} predicate links it to the \eca{Rule}.
A boolean linked by the \eca{asserted} property indicates whether the evaluation was successful. 

Because \ac*{OSLC} is focus on interoperability, the proposal is not concerned with the way automation rules work internally.
Depending on the service managing the automation, rules can be evaluated in many ways.
They can even use one of the frameworks that exist for semantic rules, like SPIN~\citep{knublauch2011spin} or Notation 3 Logic~\citep{berners2005notation}.
This would mean further interoperability, as they are also Linked Data standards.
Therefore, the proposed rule modeling aims to establish a framework able to cope any rules based on the \ac{ECA} model without specifying the method applied during the inference process.
% Future work will focus on filling the gap between \ac*{OSLC} and one of these semantic rule models.
