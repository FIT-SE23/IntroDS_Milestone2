
\documentclass[runningheads]{llncs}

%\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{enumitem}

\newtheorem{assumption}{Assumption}

\input{macro}

\sloppy

\begin{document}
%
\title{Faster Verifiable Delay Function For Shorter Delay Parameter}

\titlerunning{Faster $\vdf$}

% If the paper title is too long for the running head, you can set
% an abbreviated paper title here
% 
\author{Souvik Sur
\orcidID{0000-0003-1109-8595}}
% 
% \authorrunning{XXXX et al.}
% % First names are abbreviated in the running head.
% % If there are more than two authors, 'et al.' is used.
% 
\institute{
\email{souviksur@gmail.com}}



% \author{}\institute{}

\maketitle              % typeset the header of the contribution

\begin{abstract}\label{abstract}
\hyphenpenalty=8000\exhyphenpenalty=8000\tolerance=500\pretolerance=500%
A Verifiable Delay Function ($\vdf$) is a function that takes
a specified sequential time $T$ to be evaluated, but can be verified in $\O(\log
T)$-time. For meaningful security, $T$ can be at most subexponential in the security
parameter $\lambda$ but has no lower bound.
$\vdf$s are useful in several applications ranging from randomness beacons 
to sustainable blockchains but are really rare in practice.
To the best of our knowledge, 
% there are only two sequentially hard 
% algebraic assumptions from which practical $\vdf$s have been derived.
% \noindent
% \begin{description}
% \item [RSW Puzzle \cite{Rivest1996Time}] : Squaring in $\Z_\Delta$ is sequential when
% the factorization of $\Delta$ is unknown.
% 
% \item [Isomorphism over Super-Singular Curves~\cite{Feo2019Isogenie}] : Evaluating certain group isomorphism 
% over super-singular elliptic curves is sequential.
% \end{description}
the sequential effort required for verification
in all the $\vdf$s~\cite{Pietrzak2019Simple,Wesolowski2019Efficient,Feo2019Isogenie}
known to date, is in $\Omega(\log T)$.

This paper proposes a verifiable delay function that requires only 
two sequential squaring to verify
when the delay parameter is polynomially-bounded
i.e., $T\le \poly(\lambda)$. Thus in our $\vdf$, the sequential effort required for 
verification is fixed and independent of the security parameter.


\keywords{
Verifiable Delay Functions 
\and Sequentiality 
\and Soundness
\and Time-lock Puzzle
}
\end{abstract}
\section{Introduction}\label{introduction}
 % In 1992, Dwork and Naor~\cite{Dwork1992Price} introduced the very first notion 
 % of $\vdf$ under a different nomenclature ``pricing function".
 % Basically it is a computationally hard puzzle that needs to be solved
 % to send a mail, whereas the solution of the puzzle can be verified efficiently. 
 % Later, 


 The notion of verifiable delay functions was
 introduced in~\cite{Dan2018VDF}. A verifiable delay function is a 
 function with the domain $\mathcal{X}$ and the range $\mathcal{Y}$, that takes a specified 
 number of sequential steps $T$ to be evaluated (irrespective of the amount of parallelism) and 
 can be verified efficiently (even without parallelism) and publicly. In order to avoid exponential (processors)
 adversary $T=2^{o(\lambda)}$ at most.
 
 
 
 Along with the introduction, a candidate $\vdf$ using injective rational maps has been proposed in~\cite{Dan2018VDF}.
 However, it is a weak $\vdf$. i.e.,, the prover needs a certain amount of parallelism to evaluate.
 Wesolowski~\cite{Wesolowski2019Efficient} and Pietrzak~\cite{Pietrzak2019Simple} come up with two 
 $\vdf$s separately, although based on the same hardness assumption of time-lock puzzle~\cite{Rivest1996Time}.
 Feo et al.~\cite{Feo2019Isogenie} propose a $\vdf$ based  on super-singular elliptic curves defined over finite fields.
 
 Each of these schemes has the advantages over the others, however 
 the time-lock puzzle based ones~\cite{Wesolowski2019Efficient,Pietrzak2019Simple} shine for their simplicity. 
 The basic idea is to compute $g^{2^T}$ in a multiplicative modulo group $\multgroup{T}$ of unknown order.
 Still one crucial constraint for both of these $\vdf$s is that the effort by the verifier is proportional 
 to the security parameter $\lambda$. In particular Pietrzak's $\vdf$~\cite{Pietrzak2019Simple} imposes $O(\sqrt{T}\log T)$ 
 time (as mentioned above $T=2^{o(\lambda)}$) during verification whereas Wesolowski's $\vdf$ 
 takes $\log_2 \ell$ time such that $\ell$ is at most a $2\lambda$-bits prime. In section~\ref{attack}, we show that 
 this prime should be \emph{at least} $2\lambda$-bits in order to avoid an attacker $\mathcal{A}_W$ breaking
 the soundness with the success probability $\ge 1/\ell$. This enforces Wesolowski's $\vdf$ to incur at least $2\lambda$-time
 during verification. We believe that the key reason behind this proportional verification effort is neither of these 
 two $\vdf$s can verify if $g^{2^T}$ is really the $2^T$-th power of $g$.  
 
 Thus the question is that can we have faster verification, at least in some cases? In particular, can we design 
 a $\vdf$ that takes $\delta$- sequential time for verification where $\delta$ is reasonably small and 
  independent of the security parameter $\lambda$?

\subsection{Our Technique}\label{contributions}


We propose a $\vdf$ that needs only $2$-sequential squaring for verification when $T \in \poly(\lambda)$.
In order to generalize, the following design uses a parameter $\delta$ to tune the sequential effort during verification.
We show that $\delta=2$ is necessary and sufficient to achieve soundness and faster
verification as well. Thus the verification effort $\delta$ is independent of the security parameter $\lambda$ and 
the delay parameter $T$.


% Given a security parameter $\lambda$ and the delay parameter $T$, usually $\vdf$s consist of three algorithms, 
% \begin{enumerate}
%  \item $\setup$ generates the public parameters $\pp$. 
%  \item $\eval$ sequentially maps an input statement $x$ to an output $y$ in time $T$. 
%  Also it gives a proof $\pi$, if required, using randomness. 
%  \item $\verify$ checks if $y$ is the correct mapping of $x$ using the proof $\pi$, if any.
% 
% \end{enumerate}

Briefly, our scheme works as follows. Depending upon $\lambda$ and $T$, it chooses 
a random oracle $\mathsf{H}$.
% and a modulus $T=pq$ of two safe primes (w.r.t. $\lambda$) as the public parameters. 
% Note that $\delta$ is fixed and is independent of $\lambda$ and/or $T$.

Now the prover is asked to execute the following steps. 
Given the input $x\in\mathcal{X}$ it passes through a standard random oracle 
$\RO:\mathcal{X}\rightarrow\mathbb{S}$ where $\mathbb{S}$ contains the elements 
of maximal order ${2^{T+\delta}}$ in the multiplicative group
$\multgroup{2^{T+\delta+2}}$.
% and also belong to the multiplicative group $\multgroup{T}$. 
The prover computes $g=\mathsf{H}(x)$ 
followed by $y=g^{2^T+1}\mod{2^{T+\delta+2}}$. Then (s)he announces the tuple $( x, T, y)$.


During verification, the
verifier computes $g=\mathsf{H}(x)$. Then (s)he accepts if 
$y \ne g$ and $(y \cdot g^{-1})=1\mod{2^{T+\delta+2}}$, otherwise rejects.
Hence, the verifier needs only $\delta$ squaring while the prover spends $T$ squaring.


Essentially we exploit the identity $(g^{2^T})^{2^\delta}=1\mod{2^{T+\delta+2}}$ for 
some $g$ such that $\mathsf{gcd}(g,2^{T+\delta+2})=1$ and $\delta>0$. This is the key difference between 
this proposed $\vdf$ and the existing two based on time-lock puzzle~\cite{Wesolowski2019Efficient,Pietrzak2019Simple}. 
We bind the delay parameter $T$ with the computed output by checking if $g^{2^T}$ is the $2^T$-th power of $g$. 


We show that our construction is correct, sound and sequential. 
Further, our $\vdf$ needs no proof, thus is only a one round protocol.
We summarize a bunch of other advantages and also a disadvantage 
of our $\vdf$ over the existing ones in Sect.~\ref{compare}.
   
\subsection{Organization of the Paper}
 This paper is organized as follows.
Section~\ref{literature} discusses a few existing schemes known to be  
$\vdf$. In Section~\ref{preliminaries}, we present a succinct review of
$\vdf$. We propose our $\delta$ squaring verifiable delay function in Section~\ref{VDF}.
In Section~\ref{properties} we establish the essential 
properties correctness, sequentiality and soundness of the $\vdf$.
Finally, Section~\ref{conclusion} concludes the paper with an interesting open problem.

\section{Related Work}\label{literature}
In this section, we mention some well-known schemes qualified as $\vdf$s, and summarize
their features in Table~\ref{tab : VDF} in Sect.~\ref{compare}. We categorize them by
the sequentiality assumptions.


\textbf{Squaring over $\Z_p$} The pricing function by Dwork--Naor scheme~\cite{Dwork1992Price} asks a prover,
given a prime $p\equiv3\; (\mathbf{mod}\; 4)$ and a quadratic residue $x$ modulo $p$,
to find a $y$ such that $y^2\equiv x\;(\mathbf{mod}\;p)$. The prover
has no other choice other than using the identity $y\equiv x^{\frac{(p+1)}{4}}\;(\mathbf{mod}\;p)$, 
but the verifier verifies the correctness using $y^2\equiv x\;(\mathbf{mod}\;p)$. 
The drawback of this design is that the delay parameter $T=\log p$. Thus the difference between the evaluation 
and the verification may be made up by a prover with $\poly(T)$-processors by parallelizing the field multiplications.
Moreover, it is difficult to generate the public parameters of this $\vdf$ for sufficiently large $T$
as $\setup$ needs to find a prime $p=2^T$. 
Further the massive parallelism with the prover 
violates its sequentiality. In \cite{Lenstra2017Sloth}, Lenstra and Wesolowski circumvent 
this problem by the chaining of several easier instances generated by small $p$'s having some permutation
known as sloth. As sloth lacks efficient verification it is a proof-of-sequential-work only. 

\subsubsection{Injective Rational Maps}
In 2018, Boneh et al.~\cite{Dan2018VDF} propose a $\vdf$ based on injective rational
maps of degree $T$, where the fastest possible inversion is to compute the polynomial
GCD of degree-$T$ polynomials. They conjecture that 
it achieves $(T^2,o(T))$ sequentiality using permutation polynomials as the candidate map.
However, it is a weak $\vdf$ as it needs $\mathcal{O}(T)$ processors to evaluate the output in time $T$.

\subsubsection{RSW Puzzle}\label{vdf}
Rivest, Shamir, and Wagner~\cite{Rivest1996Time} introduced the time-lock puzzle stating
that it needs at least $T$ number of sequential squaring to compute 
$y=g^{2^T}\mod{\Delta}$ when the factorization of $\Delta$ is unknown.
Therefore they proposed this encryption that can be decrypted 
only sequentially. Starting with $\Delta=pq$ such that $p,q$ are large primes,
the key $y$ is enumerated as $y=g^{2^T}\mod{\Delta}$. Then the verifier,
uses the value of $\phi(\Delta)$ to reduce the exponent to
$e=2^T\mod{\phi(\Delta)}$ and finds out $y= g^e\mod{\Delta}$.
On the contrary, without the knowledge of $\phi(\Delta)$, the only option available to the prover
is to raise $g$ to the power $2^T$ sequentially. 
As the verification stands upon a secret, the knowledge of $\phi(\Delta)$, 
it is not a $\vdf$ as verification should depend only on public parameters.

Pietrzak~\cite{Pietrzak2019Simple} and Wesolowski~\cite{Wesolowski2019Efficient} circumvent 
this issue independently. We describe both the $\vdf$s in the generic group $\mathbb{G}$
as these schemes can be instantiated over two different groups --
 the RSA group $\multgroup{\Delta}$ and the class group of imaginary quadratic
number field. Both the protocols use a common random oracle
$\RO_\mathbb{G}:\{0,1\}^*\rightarrow \mathbb{G}$ to map the input statement $x$ to the
generic group $\mathbb{G}$. We assume $g:=\RO_\mathbb{G}(x)$.

\begin{description}

\item [Pietrzak's $\vdf$]
It exploits the identity $z^ry=(g^rz)^{2^{T/2}}$
where $y=g^{2^T}$, $z=g^{2^{T/2}}$ and $r \in \Z_{2^\lambda}$ is chosen at random.
So the prover is asked to compute the output $y=g^{2^T}$ and the proof $\pi=\{u_1, u_2, \ldots, u_{\log{T}}\}$ such that 
$u_{i+1}=u_i^{r_i+{2^{T/2^i}}}$, $r_i = \RO(u_i, T/2^{i-1},v_i,u_i^{2^{T/2^{i-1}}})$ and
$v_i=u_i^{r_i\cdot{2^{T/2^i}}+2^T}$. The verifier computes the $v_i=u_i^{r_i\cdot{2^{T/2^i}}+2^T}$
and checks if $v_{\log{T}}=u_{\log T}^2$.
So the verifier performs $\sum_{1}^{\log{T}}\log{r_i}$ number of sequential
squaring. As $\RO$ samples $r_i$ uniformly from its range $\Z_{2^\lambda}$, we have
$\sum_{1}^{\log{T}}\log{r_i}=\O(\lambda \log{T}) $.
Further, as $r_{i+1}$ depends on $r_i$, $v_i$s need to be computed sequentially.
Thus parallelism in the verification does not help. The effort to generate the proof $\pi$ is in
$\O(\sqrt{T} \log{T})$.





\item [Wesolowski's $\vdf$]
It asks the prover to compute an output $y=g^{2^T}$ and
a proof $\pi=g^{\lfloor2^T/\ell\rfloor}$, where 
$\ell=\RO_{\texttt{prime}}(\texttt{bin}(g)|||\texttt{bin}(y))$ is a $2\lambda$-bit prime. 
It needs $\O(T/\log {T})$ time to do the same.
The verifier checks if $y=\pi^\ell \cdot g^{(2^T \mod{\ell})}$. 
Hence the verification needs at most $2\log \ell=4 \lambda$ squaring.
Observe that, two processors can parallelly compute $\pi^\ell$ and $g^{(2^T \mod{\ell})}$ 
in $\le 2 \ell$ time. 
However, in Sect.~\ref{attack}, we show that it should be at least $ 2 \ell$-time instead of 
at most $2 \ell$-time.




\end{description}

\subsubsection{Isogenies over Super-Singular Curves}
Feo et al.~\cite{Feo2019Isogenie} presents two $\vdf$s based on isogenies over super-singular
elliptic curves. They start with five groups $\langle G_1,G_2,G_3,G_4,G_5\rangle$
of prime order $T$ with two non-degenerate bilinear pairing maps
$e_{12}: G_1 \times G_2 \rightarrow G_5$ and $e_{34}: G_3 \times G_4 \rightarrow G_5$.
Also there are two group isomorphisms
$\phi: G_1 \rightarrow G_3$ and $\overline{\phi}: G_4 \rightarrow G_2$. 
Given all the above descriptions as the public parameters along with a generator $P\in G_1$,
the prover needs to find $\overline{\phi}(Q)$, where $Q\in G_4$, using $T$ sequential steps.
The verifier checks if $e_{12}(P,\overline{\phi}(Q))=e_{34}(\phi(P),Q)$ in
$\poly(\log{T})$ time. It runs on super-singular curves over $\mathbb{F}_p$ and $\mathbb{F}_{p^2}$ 
as two candidate groups. 
While being inherently non-interactive, there are two drawbacks as mentioned by the authors themselves.
First, it requires a trusted setup, and second, the 
setup phase may turn out to be slower than the evaluation.


Mahmoody et al. recently rule out the possibility of having a $\vdf$ out 
of random oracles only~\cite{Mahmoody2020RO}.


\section{Preliminaries}\label{preliminaries}
Now we mention the notations and terminology used in this paper.

\subsection{Notation}

We denote the security parameter with $\lambda\in\mathbb{Z}^+$.
The term $\poly(\lambda$) refers to some polynomial of $\lambda$, and
$\negl(\lambda$) represents some function $\lambda^{-\omega(1)}$.
If any randomized algorithm $\mathcal{A}$ outputs $y$ on an input $x$, 
we write $y\xleftarrow{R}\mathcal{A}(x)$. By $x\xleftarrow{\$}\mathcal{X}$,
we mean that $x$ is sampled uniformly at random from $\mathcal{X}$. For an element $x$, 
$|x|$ denotes the bit-length of $x$, whereas for any set $\mathcal{X}$, $|\mathcal{X}|$ denotes 
the cardinality of the set $\mathcal{X}$.

We consider $\mathcal{A}$ as efficient if it runs in 
probabilistic polynomial time (PPT). We assume (or believe) a problem to be hard 
if it is yet to have an efficient algorithm for that problem.
We say that an algorithm $\mathcal{A}$ runs in parallel
time $T$ with $\Gamma$ processors if it can be implemented on a PRAM machine
with $\Gamma$ parallel processors running in time $T$.

\subsection{Verifiable Delay Function}\label{VDF}
We borrow this formalization from~\cite{Dan2018VDF}.


\begin{definition}\normalfont{ \bf (Verifiable Delay Function).}\label{vdf}
A $\vdf$ is a triple of algorithms $(\setup, \eval, \verify)$ that implements
a function $\mathcal{X}\rightarrow\mathcal{Y}$.
\begin{itemize}[label=\textbullet]
\item $\setup(1^\lambda, T) \rightarrow \mathbf{pp}$
 is a randomized algorithm that takes as input a security parameter $\lambda$ 
 and a delay parameter $T$, and produces the public parameters 
 $\pp$. We require $\setup$ to run in $\poly(\lambda,\log{T})$-time.
%  For meaningful security, the target time $T$ is restricted to be sub-exponentially sized in $\lambda$.
 
 \item $\eval(\pp, x) \rightarrow (y, \pi)$ takes an input 
 $x\in\mathcal{X}$, and produces an output $y\in\mathcal{Y}$ and a (possibly empty) 
 proof $\pi$. $\eval$ may use random bits to generate the proof 
 $\pi$. For all $\mathbf{pp}$ generated 
 by $\setup(1^\lambda, T)$ and all $x\in\mathcal{X}$, the algorithm 
 $\eval(\mathbf{pp}, x)$ must run in parallel time $T$ with 
 $\poly(\lambda,\log{T}$) processors.
 
 \item $\verify(\pp, x, y, \pi) \rightarrow \{0, 1\}$ is a 
 deterministic algorithm that takes an input $x\in\mathcal{X}$, an output $y\in\mathcal{Y}$,
 and a proof $\pi$ (if any), and either accepts ($1$) or rejects ($0$). 
 The algorithm must run in $\poly(\lambda,\log{T})$ time.
\end{itemize}
\end{definition}

\begin{description}
 \item [Subexponentiality of $T$ ]\label{subexp}
As $\verify$ is efficient, the delay parameter must have the upper bound of 
$T \le 2^{o(\lambda)}$, otherwise a prover with $\poly(T)$ processors
will always be able to brute-force $2^\lambda$ possible solutions. 
The restriction $T \le 2^{o(\lambda)}$ enforces the
complexity of the brute-force approach to be $2^\lambda/2^{o(\lambda)}=2^{\Omega(\lambda)}$.

\item [Interactive $\vdf$s] Def.~\ref{vdf} uses Fiat--Shamir heuristic to generate the proof $\pi$.
It is the non-interactive version of $\vdf$s where  
the verifier does not interact with the prover.
Fiat--Shamir heuristic replaces this interaction in \emph{any} 
public coin interactive proof using a random oracle. 
The interactive versions of $\vdf$s asks the prover to compute the 
proof $\pi$ on challenges chosen by the verifier.

\end{description}
The three desirable properties of a $\vdf$ are now described.

\begin{definition}\normalfont{(\bf Correctness)}\label{def: Correctness} 
A $\vdf$ is correct,
if for all $\lambda, T$, parameters $\mathbf{pp}$, 
and $x\in\mathcal{X}$, we have
\[
\Pr\left[
\begin{array}{l}
\verify(\mathbf{pp},x,y,\pi)=1
\end{array}
\Biggm| \begin{array}{l}
\mathbf{pp}\leftarrow\setup(1^\lambda,T)\\
x\xleftarrow{\$} \mathcal{X}\\
(y,\pi)=\eval(\mathbf{pp},x)
\end{array}
\right]
=1.
\]
\end{definition}

\begin{definition}\normalfont{\bf(Soundness)}\label{def: Soundness} 
A $\vdf$ is sound if for all non-uniform algorithms $\adv$ 
that run in time $\poly(T,\lambda)$,
we have
\[
\Pr\left[
\begin{array}{l}
y\ne\eval(\mathbf{pp},x)\\
\verify(\mathbf{pp},x,y,\pi)=1
\end{array}
\Biggm| \begin{array}{l}
\mathbf{pp}\leftarrow\setup(1^\lambda,T)\\
(x,y,\pi)\leftarrow\mathcal{A}(1^\lambda,T,\mathbf{pp})
\end{array}
\right] \le \negl(\lambda).
\]
\end{definition}


% We call the $\vdf$ \emph{perfectly} sound if this probability is $0$.

\begin{definition}\normalfont{\bf (Sequentiality)}\label{def: Sequentiality}
A $\vdf$ is $(\Gamma,\sigma)$-sequential if for all 
pair of randomized algorithms $\adv_0$ with total running time
$\poly(T,\lambda)$ and $\adv_1$ which runs
in parallel time $\sigma(T)$ on at most $\Gamma$ processors, we have,
\[
\Pr\left[
\begin{array}{l}
y=\eval(\mathbf{pp},x)
\end{array}
\Biggm| \begin{array}{l}
\mathbf{pp}\leftarrow\setup(1^\lambda,T)\\
\st\leftarrow\mathcal{A}_0(1^\lambda,T,\mathbf{pp})\\
x\xleftarrow{\$}\mathcal{X}\\
y\leftarrow\mathcal{A}_1(\st,x)
\end{array}
\right]
\le \negl(\lambda).
\]

\end{definition}


Here, $\mathcal{A}_0$ is a preprocessing algorithm that precomputes some
$\st$ based only on the public parameters, and $\mathcal{A}_1$ exploits
this additional knowledge in $\eval(x,\pp)$ in parallel running
time $\sigma$ on $\Gamma$ processors.
% An almost-perfect VDF would achieve a sequentiality $\sigma=T-o(T)$.
% Even a sequentiality $\sigma=T-\epsilon T$ for small $\epsilon$ is 
% sufficient for most applications. 


\section{Attack on  Wesolowski's $\vdf$}\label{attack}
We propose a probabilistic attacker $\adv_w$ that breaks the security of Wesolowski's $\vdf$ with 
the probability $1/\ell$ where $\ell$ is the sampled prime. Later, 
we derive a parallel attacker $\adv_\Gamma$ that succeeds with probability 
$\Gamma/\ell$ using $\Gamma$ number of processors. 

% \subsubsection{Target Applications}
% $\adv'_w$ aims the applications where the delay parameter $T$ is fixed and publicly
% known. For example, Wesolowski's $\vdf$ and Pietrzak's $\vdf$ set $T=2^{40}$ in their work keeping
% the Chia blockchain in focus~\cite{Wesolowski2019Efficient,Pietrzak2019Simple}. 
% Similarly, generating randomness beacon in lotteries
% mandates all the parties to reveal their commitment within a specified time.  
% Thus, unlike $\adv_w$, $\adv'_w$ does not have the freedom to exploit $\vrf$ with arbitrary $T$.


\subsection{A Probabilistic Adversary $\adv_w$}
We begin with the serial attacker $\adv_w$ first. 

\subsubsection{Observations}
In Wesolowski's $\vdf$, 
the verifier $\vrf$ assumes that it suffices to verify the 
equivalence $y=\pi^\ell\cdot g^r$ in order to certify $y=g^{2^T}$.
So, $\vrf$ never verifies if $\pi=g^{\lfloor 2^T/\ell \rfloor}$. 

\subsubsection{Strategy}
$\adv_w$ wants to convince $\vrf$ with a tuple $(x,y,T,\pi)$, however,
spending only time $\tau \ll T$.
Thus, $\adv_w$ chooses a (small integer) $\tau \ge 2^{2\lambda+1}$
and computes $y=g^\tau$. Then $\adv_w$ samples the prime $\ell$ in order to compute 
$\pi=g^{\lfloor \tau/\ell \rfloor}$. Now he finds if 
$\tau \mod{ \ell}=2^T \mod{ \ell}$. If yes, then $\adv_w$ returns $(x,y,T,\pi)$,
otherwise he tries with $\tau+1$ and so on. 
As mentioned in the strategy for $\adv_w$, we keep $\tau \ge 2^{2\lambda+1}$ in order to
bypass $\pi=\pm 1$.
In particular, $\adv_w$ runs Alg. ~\ref{alg:wes}.

\begin{algorithm}
\caption{Probabilistic Adversary $\adv_w$ for Wesolowski's $\vdf$}\label{alg:wes}
\begin{algorithmic}[1]
 \STATE $g:= \RO_\mathbb{G}(x)$
 \STATE $\tau:= 2^{(2\lambda+1)}-1$
 \REPEAT
 \STATE $\tau:=\tau+1$
 \STATE $y:=g^{\tau}$
 \STATE $\ell:=\mathsf{H}_{\texttt{prime}}(\texttt{bin}(g)|||\texttt{bin}(y))$
 \STATE $\pi:=g^{\lfloor \tau/\ell \rfloor}$
 \UNTIL {$(\tau \mod{\ell}\ne 2^T \mod{\ell})$} 
\RETURN $(x,y,T,\pi)$
\end{algorithmic}
\end{algorithm}

$\adv_w$ announces the tuple $(x,y,\pi,T)$ to get verified.

\subsubsection{Correctness of $\adv_w$}
The verifier will find that, 

\[
\begin{split}
\pi^\ell \cdot g^{2^T \mod{\ell}} 
&= \pi^\ell \cdot g^{\tau \mod{\ell}} \\
&= (g^{\lfloor \tau/\ell \rfloor})^\ell g^{\tau \mod{\ell}} \\
&= y.
\end{split}
\]

\subsubsection{Efficiency of $\adv_w$}
For any arbitrary $\tau$, $\adv_w$ succeeds with probability,
$$\Pr[\adv_w \; \text{wins}]=\Pr[\tau \mod{\ell}=2^T \mod{\ell}]=1/\ell.$$
Thus, $\adv_w$ runs in probabilistic-polynomial-time in $\lambda$ as all the steps run in
$\poly(\lambda)$. In particular, checking $2^T \mod{\ell}$ can be computed as $2^{T \mod
{(\ell-1)}} \mod{\ell}$. 
Inclusion of $T$ in
$\ell:=\mathsf{H}_{\texttt{prime}}(\texttt{bin}(g)|||\texttt{bin}(y)|||\texttt{bin}(T))$
makes no difference as it incurs the same 
success probability $1/\ell$. Thus the expected number of iterations to find such
a $\tau$ is $\O(\ell)$. As Wesolowski's $\vdf$ keeps $\ell \le 2^{2\lambda}$, $\adv_w$ succeeds
with significantly high probability if $\ell$ is reasonably low. 
Therefore, $\adv_w$ pushes $\ell \ge 2^{\lambda}$
in order to have $\Pr[\adv_w \; \text{wins}] \le \negl(\lambda)$. 
Since, the verification in Wesolowski's $\vdf$ needs $\Omega(\log \ell)$ squaring, 
now it needs $\Omega(\lambda)$ squaring instead of $\O(\lambda)$ only.


\subsubsection{A Probabilistic Parallel Adversary $\adv_\Gamma$}
Def.~\ref{vdf} suggests that adversaries may have
$\poly(T)$-number of parallel processors.
Here we come up with an attacker $\adv_\Gamma$ with $\Gamma  \le \poly(T)$ processors
that increases the success probability from $\O(1/\ell)$ to $\O(\Gamma/\ell)$.
The key observation is that the condition $\tau \mod{\ell}\ne 2^T \mod{\ell}$ 
to terminate the do-while loop in Alg.~\ref{alg:wes}, is independent for each different $\tau$. 
Thus, $\adv_\Gamma$ may run $\Gamma$ such instances parallelly each with a different
$\tau$. In particular, the $\adv_\Gamma$ is given as follows,

\begin{algorithm}
\caption{$\adv_\Gamma$ for Wesolowski's $\vdf$}\label{alg:wesp}
\begin{algorithmic}[1]
 \STATE $g:= \RO_\mathbb{G}(x)$
 \STATE $m:=2^{2\lambda+1}-1$
 \FORALL {$\tau \in \{m+1, \ldots,  m+\Gamma\} $} 
 \STATE $y:=g^{\tau}$
 \STATE $\ell:=\mathsf{H}_{\texttt{prime}}(\texttt{bin}(g)|||\texttt{bin}(y))$
 \STATE $\pi:=g^{\lfloor \tau/\ell \rfloor}$
 	\IF {$(\tau \mod{\ell}= 2^T \mod{\ell})$} 
	\RETURN $(x,y,T,\pi)$
 	\ENDIF
 \ENDFOR
\end{algorithmic}
\end{algorithm}


The condition at step 7 is checked in parallel using $\Gamma$ number of processors. 
The processor $i < \Gamma$ gets $\tau=m+i$ and checks if 
$\tau \mod{\ell}= 2^T \mod{\ell}$. The success probability in each processor is 
$\O(1/\ell)$. So the total probability of success for $\adv_\Gamma$ is, 

$$\Pr[\adv_\Gamma \; \text{wins}]=\sum_{1}^{\Gamma}1/\ell=\Gamma/\ell.$$
Hence, in the presence of the parallel adversary $\adv_\Gamma$, Wesolowski's $\vdf$ 
needs to set $\Gamma/\ell \le \negl(\lambda)$. Earlier, the attacker $\adv_w$
asks to sample the prime $\ell \ge 2^{\lambda}$. Now, 
$\adv_\Gamma$ enforces $\ell \ge \Gamma2^{\lambda}
=\poly(T2^{\lambda})=\O(2^{\lambda+o(\lambda)})$.




% We give an attacker $\adv_w$ that breaks the soundness of the non-interactive version of 
% Wesolowski's $\vdf$ with the probability $1/\ell$ where $\ell$ is the sampled prime.
% Two important observations relevant to this attack are,
% \begin{enumerate}
%  \item The sampled prime $\ell:=\RO_{\texttt{prime}}(\texttt{bin}(g)|||\texttt{bin}(y))$
%  is independent of the delay parameter $T$. So the prover may claim that $y=g^{2^T}$ for any arbitrary values of $T$.
%  \item The equivalence $y=\pi^\ell\cdot g^r$ implies $y=g^{2^T}$ if and only if  
%  $\pi=g^{\lfloor 2^T/\ell \rfloor}$ which is never verified by the verifier.
% \end{enumerate}
% 
% Thus, $\adv_w$ chooses a small ($2\lambda+1$-bit suffices in this context) number 
% $\tau$ and computes $y=g^\tau$. Then (s)he samples the prime $\ell$ in order to compute 
% $\pi=g^{\lfloor \tau/\ell \rfloor}$. Now (s)he finds a number $T>\log_2 \tau$ such that 
% $\tau \mod{ \ell}=2^T \mod{ \ell}$. In particular $\adv_w$ runs Alg. ~\ref{alg:wes}.
% 
% \begin{algorithm}
% \caption{Serial adversary $\adv_w$ for Wesolowski's $\vdf$}\label{alg:wes}
% \begin{algorithmic}[1]
%  \STATE $g:= \RO_\mathbb{G}(x)$
%  \STATE $\tau\in_R \Z_{2^{(2\lambda+1)}}\setminus \Z_{2^\lambda}$ \hfill //
% uniformly randomly
%  \STATE $y:=g^{\tau}$
%  \STATE $\ell:=\mathsf{H}_{\texttt{prime}}(\texttt{bin}(g)|||\texttt{bin}(y))$
%  \STATE $\pi:=g^{\lfloor \tau/\ell \rfloor}$
%  \STATE $T := \lceil \log_2 \tau\rceil$
%  \WHILE {$(\tau \mod{\ell}\ne 2^T \mod{\ell})$} \STATE $T:= T+1$
%  \ENDWHILE
% \RETURN $T$
% \end{algorithmic}
% \end{algorithm}
% 
% $\adv_w$ announces the tuple $(x,G,y,\pi,T)$ to get verified.
% The verifier will find that, 
% 
% $$\pi^\ell \cdot g^{2^T \mod{\ell}}=\pi^\ell \cdot g^{\tau \mod{\ell}}=
% (g^{\lfloor \tau/\ell \rfloor})^\ell g^{\tau \mod{\ell}}=y.$$
% 
% For any arbitrary $T$, $\adv_w$ succeeds with probability,
% $$\Pr[\adv_w \; \text{wins}]=\Pr[\tau \mod{\ell}=2^T \mod{\ell}]=1/\ell.$$
% Inclusion of $T$ in $\ell:=\mathsf{H}_{\texttt{prime}}(\texttt{bin}(g)|||\texttt{bin}(y)|||\texttt{bin}(T))$ 
% requires $\adv_w$ to include only this sampling of $\ell$ within the while loop incurring the same 
% success probability $1/\ell$. Thus the expected number of iterations to find such a $T$ is $\O(\ell)$.
% Sect. 3.3 in (cf.~\cite{VDF2018Survey}) discusses a similar attack but it 
% tries to find a suitable $\ell$ by querying the random oracle $\RO_{\texttt{prime}}$ for $\O(2^{\lambda/2})$ times.
% On the contrary, $\adv_w$ finds a suitable $T$ in $\O(\ell)$-time but queries
% $\RO_{\texttt{prime}}$ only once.
% Both these attacks together suggest that we must set $\ell \ge 2^{2\lambda}$,
% in order to have $\Pr[\adv_w \; \text{wins}] \le \negl(\lambda)$. 
% Thus, Wesolowski's $\vdf$ should need $O(\log _2 \ell)\ge 2\lambda$ modulo squaring for verification.
% 
% Further, an adversary may come up with $\Gamma  \le \poly(T)$ processors.
% Such a parallel adversary, namely $\adv^\Gamma_w$ increase the success
% probability of $\adv_w$ from $\O(1/\ell)$ to $\O(\Gamma/\ell)$ just by parallelizing the
% while loop at step number 7. Notice that the condition $(\tau \mod{\ell}\ne 2^T \mod{\ell})$ 
% in that while loop is independent of each different $T$s. In particular, the
% adversary $\adv_w^\Gamma$ is given as follows,
% 
% \begin{algorithm}
% \caption{$\adv_w^\Gamma$ for Wesolowski's $\vdf$}\label{alg:wes}
% \begin{algorithmic}[1]
%  \STATE $g:= \RO_\mathbb{G}(x)$
%  \STATE $\tau\in_R \Z_{2^{(2\lambda+1)}}\setminus \Z_{2^\lambda}$ \hfill //
% uniformly randomly
%  \STATE $y:=g^{\tau}$
%  \STATE $\ell:=\mathsf{H}_{\texttt{prime}}(\texttt{bin}(g)|||\texttt{bin}(y))$
%  \STATE $\pi:=g^{\lfloor \tau/\ell \rfloor}$
%  \STATE $m:=\lceil \log_2 \tau\rceil$
%  \FORALL {$T \in \{m, m+1, \ldots,  \Gamma +m\} $} 
%  	\IF {$(\tau \mod{\ell}= 2^T \mod{\ell})$} 
% 	\RETURN $T$
%  	\ENDIF
%  \ENDFOR
% \end{algorithmic}
% \end{algorithm}
% 
% 
% The condition at step 8 is checked in parallel using $\Gamma$ number of processors. 
% The processor $i < \Gamma$ gets $T=m+i$ and checks if $(\tau \mod{\ell}= 2^T
% \mod{\ell})$. 
% The success probability in each processor is $\O(1/\ell)$. So the total probability of
% success is, 
% 
% $$\Pr[\adv_w^\Gamma \; \text{wins}]=\sum_{1}^{\Gamma}1/\ell=\Gamma/\ell.$$
% Thus, in the presence of the parallel adversary $\adv_w^\Gamma$, Wesolowski's $\vdf$ 
% needs to set $\Gamma/\ell \le \negl(\lambda)$. The other two attacks mentioned above
% already require to sample the prime $\ell \ge 2^{2\lambda}$. Now, this new parallel
% attacker $\adv_w^\Gamma$ enforces $\ell \ge \Gamma2^{2\lambda}$.


\section{$\delta$-Squaring Verifiable Delay Function}\label{LPoSW}
As before, $\lambda\in\mathbb{Z}^+$ denotes the security parameter, 
$T\in 2^{o(\lambda)}$ denotes the delay parameter.
The three algorithms that specify our $\vdf$ are,

\subsection{The $\setup(1^\lambda,T)$ Algorithm}\label{Gen}
This algorithm outputs the public parameters
$\mathbf{pp}=\langle \delta, \RO \rangle$ having
the following meanings.
\begin{enumerate}


% \item $T=pq$ where 
% \begin{enumerate}
%  \item $(p-1)/2$ and $(q-1)/2$ are primes.
%  \item $\log_2 p \approx \log_2 q$ and are small multiples of $\lambda$.
% \end{enumerate}
\item $\delta \in \Z^+$ is a parameter that tunes the sequential effort during verification. In Theorem~\ref{thm: bound} 
we show that $\delta=2$ is necessary and sufficient. Thus $\delta$ is fixed even before we run the $\setup$.
Still we mention $\delta$ in $\pp$, otherwise we had to introduce $\delta$ as another
implicit parameter like $\lambda$ and $T$ in $\eval$ and $\verify$.
\item 
We define $\mathsf{H}:\mathcal{X}\rightarrow\mathbb{S}$ to be a random oracle that maps 
$x\in\mathcal{X}$ to the set $\mathbb{S}$ where $\mathbb{S}$ is defined as follows.

Suppose $\multgroup{N}$ denotes the group of coprimes to the integer $N$ under the operation multiplication 
and $\mathsf{ord}_N(g)\stackrel{def}{=}min\{t \mid g^t=1 \mod{N} \}$. We define 
$\mathbb{S}\stackrel{def}{=}\{g\in \multgroup{2^{T+\delta+2}} \mid 
\mathsf{ord}_{2^{T+\delta+2}}(g)=2^{T+\delta}\}$. 
Here $\mathsf{ord}_{2^{T+\delta+2}}(g)=2^{T+\delta}$ is the maximal order as proved in Lemma.~\ref{order}.
 Theorem A in~\cite{Cocke2019Maximal} states that for a finite group $G$ having $k$ elements 
of maximal order $m$ holds $|G|\le \frac{mk^2}{\phi(m)}$ where $\phi()$ Euler's totient function. When $m$ is a power 
of $2$ the ratio $\frac{\phi(m)}{m}=\frac{1}{2}$ so $k\ge \sqrt{|G|/2}$.
Hence, there are at least $2^{(T+\delta)/2}$ elements
in the group $\multgroup{2^{T+\delta+2}}$ that have maximal order. So the cardinality of 
$|\mathbb{S}|=2^{(T+\delta)/2}= 2^{\poly(\lambda)}$ as we restrict $T\in \poly(\lambda)$. 

\end{enumerate}


  None of the public parameters needs to be computed. Like
~\cite{Wesolowski2019Efficient,Pietrzak2019Simple}, the map $\RO$ is realized as
a random oracle rather than an algorithm.

\subsection{The $\eval$ Algorithm}
The prover $\prv$ executes,

\begin{algorithm}
\caption{$\eval(\pp,x,T)\rightarrow y$}
\begin{algorithmic}[1]
 \STATE compute $g:=\RO(x)$.
 \STATE compute $y:=g^{(2^T+1)}\mod{2^{T+\delta+2}}$.
 \RETURN $y$
\end{algorithmic}
\end{algorithm}
 $\prv$ announces the triple $( x, T, y)$. 

\subsection{The $\verify$ Algorithm}
% During verification basically we exploit Euler's theorem.

The verifier $\vrf$ runs,

\begin{algorithm}
\caption{$\verify(\pp,x,T, y,\bot)\rightarrow \{0,1\}$}
\begin{algorithmic}[1]
 \STATE compute $g:=\RO(x)$.

 \IF {$y = g$}
	\RETURN $0$

 \ELSIF {$(y \cdot g^{-1})^{2^\delta}\ne 1\mod{(2^{T+\delta+2})}$} 
	\RETURN $0$
 \ELSE	
	\RETURN $1$
 \ENDIF	
\end{algorithmic}
\end{algorithm}

Verification needs no proof, so $\pi=\bot$.





 
% \begin{lemma}{\normalfont \textbf{(Square-freeness of $T$).}}
% Given an $T\in\mathbb{Z}^+$ if $\texttt{gcd}(T,\varphi(T))=1$ then $T$ is square-free.
% \end{lemma}
% \begin{proof}
%  We know that any integer $n=p_1^{e_1}.p_2^{e_1}\ldots p_k^{e_k}$ where $p_i\in\mathbb{P}$ and $e_i\in\mathbb{Z}^+$.
%  An integer is square-free if and only if all $e_i=1$. Suppose $m=p_1.p_2\ldots p_k^{e_k}$ where $e_k>1$. 
%  As $\varphi$ is multiplicative function to coprimes,  $\varphi(m)=\varphi(\frac{m}{p_k^{e_k}}).\varphi(p_k^{e_k})=(p_1-1)(p_2-1)\ldots p_k^{{e_k}-1}(p_k-1)$.
%  Therefore, $\texttt{gcd}(m,\varphi(m))\ge p_k^{{e_k}-1}$. So $\texttt{gcd}(m,\varphi(m))=1$ is possible only if $e_k=1$ viz. $m=p_1.p_2\ldots p_k$. 
%  However, the reverse is not true as some $p_i$ in $m$ may divide some $(p_j-1)$ in $\varphi(m)$. For example $\texttt{gcd}(21,\varphi(21))=3$.
% \end{proof}




 
 



\section{Security Analysis}\label{properties}
Here we show that the proposed $\vdf$ is correct, sound and sequential. 



\begin{lemma}{\normalfont \textbf{(Maximal Order).}}\label{order}
For all $k\in\Z^+$, $2^{k}=max\{\mathsf{ord}(g)\mid\forall g\in\multgroup{2^{k+2}}\}$
\end{lemma}
\begin{proof}
 We know that $g\in\multgroup{2^{k+2}}$ if and only if $\mathsf{gcd}(g,2^{k+2})=1$. 
 It implies $g=1+2h_0$ for some $h_0\in\Z_{2^{k+1}}$. Now we proceed by induction on $k$,

 \begin{description}
  \item [Base Case:]  For $k=1$, $$g^2=g^{2^1} =1+4h_0(1+h_0)=1+2^3h_1,  \qquad [h_1=\frac{h_0(1+h_0)}{2}\in\Z].$$
 
  \item [Inductive Steps:] 
 Suppose, for some $1<k\in\Z$,
  \begin{align*}
  g^{2^k}  &= 1+2^{k+2}h_k. \\
  \text{Then, } g^{2^{k+1}} &= 1+2^{k+3}h_k(1+2^{k+1}h_k), \\
                            &= 1+2^{k+3}h_{k+1}. \qquad [h_{k+1}=h_k(1+2^{k+1}h_k)\in\Z^+] 
 \end{align*}
 \end{description}

  
 
 Therefore, for all $k\in\Z$ and for all $g\in\multgroup{2^{k+2}}$, there exists an 
 $h_k\in\Z^+$, such that $g^{2^k}  = 1+2^{k+2}h_k = 1 \mod{2^{k+2}}$. 
 Thus, $2^{k}=max\{\mathsf{ord}(g)\mid\forall g\in\multgroup{2^{k+2}}\}$).
 \qed
\end{proof}

\subsection{Correctness}
The verifier should always accept a valid triple $(x,y,T)$.

\begin{theorem}
 The proposed $\mathsf{VDF}$ is correct.
\end{theorem}
\begin{proof}
 Since $\mathsf{H}$ is a deterministic hash function, $g$ is uniquely determined
 by the challenge $x\in\mathcal{X}$. Moreover, for any $T>0$, the prover computes 
 $y:=g^{2^T+1}\mod{2^{T+\delta+2}}$.
 The verifier $\vrf$ accepts $y$ as,

 
 \begin{align*}
 y &=g^{2^T+1}\mod{2^{T+\delta+2}}\\
   &=g^{2^T}\cdot g \mod{2^{T+\delta+2}}\\
   &\ne 1 \cdot g \mod{2^{T+\delta+2}}\qquad \text{[Putting $k=T+\delta$ in Lemma~\ref{order}]}\\
   &\ne g \mod{2^{T+\delta+2}}.
 \end{align*} 
and, 
 \begin{align*}
  (y\cdot g^{-1})^{2^\delta}\mod{2^{T+\delta+2}} 
&=(g^{2^T+1} \cdot g^{-1})^{2^\delta}\mod{2^{T+\delta+2}}\\
&=(g^{2^T})^{2^\delta}\mod{2^{T+\delta+2}}\\
&=g^{2^{T+\delta}}\mod{2^{T+\delta+2}}\\
&=1\mod{2^{T+\delta+2}} \qquad \text{[Putting $k=T+\delta$ in Lemma~\ref{order}]}.
 \end{align*} 
\qed
\end{proof}

Therefore it follows that,
\[
\Pr\left[
\begin{array}{l}
\verify(\mathbf{pp},x,T,y,\bot)=1
\end{array}
\Biggm| \begin{array}{l}
\mathbf{pp}\leftarrow\setup(1^\lambda,T)\\
x\xleftarrow{\$} \mathcal{X}\\
(y,\bot)=\eval(\mathbf{pp},x,T)
\end{array}
\right]
= 1
\]


\subsection{Soundness}
 Using an invalid proof no adversary $\adv$ having $\poly(T)$ processors should convince the verifier 
 with non-negligible probability.

\begin{definition}\normalfont{(\bf The Group of Non-trivial Quadratic Residues $\mathbb{QR}^*_\Delta$)} 
Let, the group of quadratic residues is defined as, 
$\mathbb{QR}_\Delta\stackrel{def}{=}\{g^2\mod{\Delta}\mid \forall g\in
\multgroup{\Delta}\}$. The group of non-trivial quadratic residues is defined as,
$$\mathbb{QR}^*_\Delta\stackrel{def}{=}\mathbb{QR}_\Delta\setminus\{1\}.$$   
\end{definition}

\begin{definition}\normalfont{(\bf Square Root Game $\sqrt{\mathcal{G}}_{\Delta}$)}\label{root} 
Let $\mathcal{A}$ be a party playing the game. 
The square root finding game $\sqrt{\mathcal{G}}_{\Delta}$ goes as follows: 
\begin{enumerate}
 \item $\mathcal{A}$ is given a composite integer $\Delta$.
%  the output of the $\mathsf{Setup}(\lambda,T)\rightarrow \langle \mathsf{H}, {\Delta}\rangle $.
 \item $\mathcal{A}$ is given an element $z\xleftarrow{\$}\mathbb{QR}^*_\Delta$ chosen uniformly at random.
 \item Observing $z$, $\mathcal{A}$ outputs an element
$w\in\multgroup{\Delta}\setminus\{1\}$.
\end{enumerate}
The player $\mathcal{A}$ wins the game $\sqrt{\mathcal{G}}_\Delta$ if $w^2=z\mod{\Delta}$.
\end{definition}

Now we mention two cases of $\Delta$ that are believed to be hard for $\mathcal{A}$ to win the game $\sqrt{\mathcal{G}}_\Delta$
with non-negligible probability on $\log_2 \Delta$. It becomes hard,

\begin{description}
 \item [Case 1:] when $\Delta=pq$ for two safe primes\footnote{A prime $p$ is safe if $\frac{p-1}{2}$ is a prime.}, 
 this problem can be shown as hard as (under randomized reduction) the difficulty of factoring $\Delta$ 
 for which the best known algorithms have complexity $L_{n} (1/3)$.
\item [Case 2:] when $\Delta=2^k$ for some $k>1$. If $\Delta=p^k$ for some prime $p>2$ then the solutions
are obtained using Hensel's lemma to the function
$\rho(x) = x^2 - q$, for which $\rho'(x) = 2x \ne 0\mod{p}$ with the assumption $p^k\nmid x$. However, for $p = 2$, 
Hensel's lifting from $k = 1$ to higher values fails as $\rho'(x) = 2x = 0 \mod{2}$.
\end{description}

Let us denote the the second case as $\sqrt{\mathcal{G}}_{2^k}$.
However, we need another version of the game $\sqrt{\mathcal{G}}_\Delta$ 
in order to reduce the soundness-breaking game.
Instead of sampling $z$ uniformly at random, in this 
version we compute $f^\mathsf{H} : \Z\times\X \rightarrow z\in\mathbb{QR}^*_\Delta$.

\begin{definition}\normalfont{(\bf Square Root Function Game $\sqrt{\mathcal{G}}^f_\Delta$)}\label{funcroot} 
Let $\mathcal{A}$ be a party playing the game and $f^\mathsf{H} : \Z\times\X \rightarrow \mathbb{QR}^*_\Delta$.
The Square Root Function Game $\sqrt{\mathcal{G}}^f_\Delta$ goes as follows: 
\begin{enumerate}
 \item $\mathcal{A}$ is given the output of the 
 $\mathsf{Setup}(\lambda,T)\rightarrow \langle \mathsf{H}, \Delta \rangle $.
 \item An element $x\xleftarrow{\$}\mathcal{X}$ is chosen uniformly at random.
 \item $\mathcal{A}$ is given the element $f^\mathsf{H}(\Delta,x)\rightarrow z$.
 \item Observing $z$, $\mathcal{A}$ outputs an element
$w\in\multgroup{\Delta}\setminus\{1\}$.
\end{enumerate}
The player $\mathcal{A}$ wins the game $\sqrt{\mathcal{G}}_\Delta^f$ if $w^2=z\mod{\Delta}$.
\end{definition}

Under the assumption that $\mathsf{H}$ samples elements from its range uniformly at random
the distributions of $z$ in 
 both the games $\sqrt{\mathcal{G}}_\Delta$ and $\sqrt{\mathcal{G}}^f_\Delta$ 
should be indistinguishable for $\adv$.
In fact, it holds true even without the oracle $\mathsf{H}$, as long as $f(\Delta,x)\ne \theta(x)^{2\ell}\mod{\Delta}$ 
for some deterministic function $\theta$ and some fixed $\ell\in\Z$. 

As before, there are two different cases $\Delta=pq$ and $\Delta=2^k$ of 
$\sqrt{\mathcal{G}}^f_\Delta$ when it computationally becomes hard. In particular,

% Similarly $\sqrt{\mathcal{G}}^{f}_{2^k}$ is obtained from the 
% game $\sqrt{\mathcal{G}}_{2^k}$.



\begin{assumption}\normalfont \textbf{(Square Root Function Assumption).}
 For all algorithms $\adv$ that run in time $T$ on $\poly(T)$ processors
 wins the square root function game $\sqrt{\mathcal{G}}^{f}_{\Delta}$ 
 with the probability at most negligible in the security parameter $\lambda$ if $f$ is not a even power 
 of another deterministic function.
\[
\Pr\left[
\begin{array}{l}
w^2=z
\end{array}
\Biggm| \begin{array}{l}
(\RO,\Delta)\leftarrow\setup(1^\lambda,T)\\
x \xleftarrow{\$} \X \\
z \leftarrow f^\RO(\Delta,x)\\
w \leftarrow\mathcal{A}(z,\Delta)
\end{array}
\right] \le \negl(\lambda).
\]
\end{assumption}


As before, when $\Delta=2^k$, we call it as 
$\sqrt{\mathcal{G}}^{f}_{2^k}$.




\begin{theorem}{\normalfont \textbf{(Soundness).}}\label{thm: soundness}
 Suppose $\mathcal{A}$ be a player who breaks the soundness of this proposed $\mathsf{VDF}$
 with probability $p_{win}$. Then there is a player
 $\mathcal{B}$ who wins the square root function game $\sqrt{\mathcal{G}}^f_{2^k}$ 
 with the probability $p_{win}$ where
 $f^\mathsf{H}(2^{T+\delta+2},x)=\RO(x)^{2^\delta}\mod{2^{T+\delta+2}}$.
\end{theorem}
\begin{proof}
 Run the $\mathsf{Setup}(1^\lambda,T)$ to obtain ($\mathsf{H},2^{T+\delta+2})$. 
%  Define the function $f^\mathsf{H}(T,x)=((1\mod{2^{T+\delta+2}})/\mathsf{H}(x)^4) \mod{T}$. 
 The player $\mathcal{B}$ calls $\mathcal{A}$ on the input statement $x\xleftarrow{\$}\mathcal{X}$.
 Suppose $\mathcal{A}$ outputs $y\ne\mathsf{H}(x)^{2^T+1}\in \multgroup{T}$. 
 As $\mathcal{A}$ breaks the soundness of this $\vdf$, 
 $y^{2^\delta}=((\mathsf{H}(x)^{2^\delta}\mod{2^{T+\delta+2}})=f^\RO(2^{T+\delta+2},x)$ 
 with the probability $p_{win}$. So $\mathcal{B}$ outputs $y^{2^{\delta-1}}$ in
$(\delta-1)$-time and wins the game 
 $\sqrt{\mathcal{G}}^f_T$ with probability $p_{win}$.
  
\qed
\end{proof}

\begin{theorem}\label{thm: bound}{\normalfont \textbf {(Lower Bound on $\delta$).}}
 This $\vdf$ is sound if $\delta>1$.
\end{theorem}

\begin{proof}
 Suppose $\mathcal{B}_{2^k}$ is a player who plays the square root function game $\sqrt{\mathcal{G}}^f_{2^k}$ 
 over the group $\multgroup{2^{T+\delta+2}}$ for arbitrary $\delta>0$. 
 
 In the proposed $\vdf$, 
 $y^{2^\delta}=\mathsf{H}(x)^{2^\delta}\mod{2^{T+\delta+2}}$.
 If $\delta=1$ and $\mathsf{H}(x)=1 \mod{8}$, then $y^{2}=\mathsf{H}(x)^{2}\mod{2^{T+3}}$
 has at least four solutions $y=\{\mathsf{H}(x), -\mathsf{H}(x), 2^{T+3}+\mathsf{H}(x), 2^{T+3}-\mathsf{H}(x)\}$.
 
 So we set $\delta=2$ and $f^\mathsf{H}(2^k,x)$ as one of these functions 
 $\{\mathsf{H}(x), -\mathsf{H}(x), 2^{T+3}+\mathsf{H}(x), 2^{T+3}-\mathsf{H}(x)\}$ over the group $\multgroup{2^{T+4}}$.
 When $\adv$ outputs $y$ on the input $x$, $\mathcal{B}_{2^k}$ outputs $y^2$ to win the game 
 $\sqrt{\mathcal{G}}^f_{2^k}$ with the probability,
 $$\Pr[\mathcal{B}_{2^k} \text{ wins } ]= \Pr[\adv \text{ wins } \mid \mathsf{H}(x)=1 \mod{8}]= \dfrac{p_{win}}{8}.$$
 \qed
\end{proof}




\subsection{Sequentiality}\label{Sequentiality}
The sequentiality analysis of our $\vdf$ scheme is based on 
the sequentiality of time-lock puzzle~\cite{Rivest1996Time}. 


\begin{definition}\normalfont{(\textbf {Time-lock Game $\mathcal{G}^{2^T}_{\Delta})$}}
Let $\adv=(\adv_0,\adv_1)$ be a party playing the game.  For $T\in Z^+$, the time-lock game 
$\mathcal{G}^{2^T}_{\Delta}$ goes as follows: 
\begin{enumerate}
 \item $\adv_0$ is given a composite integer $\Delta$.
 \item $\adv_0$ computes some information $\st\in \{0,1\}^*$ on the input $\Delta$.
 \item $\adv_1$ is given the information $\st$ and an element $g\xleftarrow{\$}\multgroup{\Delta}$ chosen uniformly at random.
 \item Observing $g$ and $\st$, $\adv_1$ outputs an element $h\in\multgroup{\Delta}$ in time $<T$.
\end{enumerate}
The player $\adv=(\adv_0,\adv_1)$ wins the game $\mathcal{G}^{2^T}_{\Delta}$ if $h=g^{2^T}\mod{\Delta}$.
\end{definition}

Here are two cases, where time-lock puzzles become hard.

\begin{description}
\item [Unknown Order:] The time-lock assumption states that for all algorithms $\adv=(\adv_0,\adv_1)$ running in time $<T$ 
on $\poly(T)$ number of processors, we have $\Pr[\adv \text{ wins } \mathcal{G}^{2^T}_{\Delta}] \le \negl(\lambda)$
 when the factorization of $\Delta$ is unknown~\cite{Rivest1996Time}. 

\item [Known Order:] When the factorization $\Delta$ is known, the order of group
$\multgroup{\Delta}$ can be computed efficiently as follows,

$$|\multgroup{\Delta}|=\phi(\Delta)=\Delta \prod \limits_{p \mid \Delta}(1-\frac{1}{p})$$

where $p$ are primes.
However, knowing the
order does not necessarily ease the computation always. It is because, till date, 
the only faster algorithm that we know to compute $g^e$ for any $e \in \Z^+$ is to reduce it
to $g^{e \mod {\phi(\Delta)}}$. Therefore, when $e < \phi(\Delta)$ there are only two
options we are left with. If $e\le  e-\phi(\Delta)$ then compute $g^e$, otherwise,
compute $(g^{-1})^{\phi(\Delta)-e}$.
Clearly, the knowledge of $\phi(\Delta)$ reduces the number of required squaring only if $e>
\phi (\Delta)/2$ but keeps the same when $e \le \phi(\Delta)/2$. Therefore, time-lock
puzzle holds true even when the order $\phi(\Delta)$ is known and $e \le \phi(\Delta)/2$.
The game $\mathcal{G}^{2^T}_{2^{T+\delta+2}}$ is one such example as
$\phi(2^{T+\delta+2})=2^{T+\delta+1}$ and $e=2^T$. So, computing $g^{2^T}
\mod{2^{T+\delta+2}}$ needs at
least $T$ squaring for any $\delta \ge 0$.
\end{description}



\begin{definition}\normalfont{(\textbf {Time-lock Oracle Game
$\mathcal{G}^{\mathsf{H}^{2^T}}_{\Delta})$}}\label{time} 
Let $\adv=(\adv_0,\adv_1)$ be a party playing the game.  For $T\in Z^+$, the time-lock oracle game 
$\mathcal{G}^{\mathsf{H}^{2^T}}_{\Delta}$ goes as follows: 
\begin{enumerate}
 \item $\adv_0$ is given the output of the $\setup(\lambda,T)\rightarrow \langle \mathsf{H}, T \rangle $.
%   the output of the $\mathsf{Setup}(\lambda,T)\rightarrow \langle \mathsf{H}, {\Delta}\rangle$.
 
 \item $\adv_0$ computes some information $\st\in \{0,1\}^*$ on the input $T$.
 \item An element $x \xleftarrow{\$} \X$ is chosen uniformly at random.
 \item $\adv_1$ is given the information $\st$ and an element $g\leftarrow \mathsf{H}(x)$.
 \item Observing $g$ and $\st$, $\adv_1$ outputs an element $h\in\multgroup{\Delta}$ in time $<T$.
\end{enumerate}
The player $\adv=(\adv_0,\adv_1)$ wins the game $\mathcal{G}^{2^T}_{\Delta}$ if $h=g^{2^T}\mod{\Delta}$.
\end{definition}


Under the assumption that the random oracle $\mathsf{H}$ samples strings from its range uniformly at random 
the view of the distributions of $g$ in both the games $\mathcal{G}^{{2^T}}_{\Delta}$ and $\mathcal{G}^{\mathsf{H}^{2^T}}_{\Delta}$
are identical to $\adv$.
Thus we infer that,



\begin{assumption} \normalfont {\textbf{(Time-lock Oracle Assumption).}}
 For all algorithms $\adv=(\adv_0,\adv_1)$ running in time $<T$ on $\poly(T)$ number
 of processors wins the time-lock oracle game $\mathcal{G}^{\mathsf{H}^{2^T}}_{\Delta}$ with 
 the probability at most negligible in the security parameter $\lambda$. Mathematically,
\[
\Pr\left[
\begin{array}{l}
g^{2^T}=h
\end{array}
\Biggm| \begin{array}{l}
(\RO,\Delta)\leftarrow\setup(1^\lambda,T)\\
\st \leftarrow \adv_0(1^\lambda,T,\RO,\Delta)\\
x \xleftarrow{\$} \X \\
g \leftarrow \RO(x)\\
h \leftarrow\mathcal{A}_1(g,\st)
\end{array}
\right] \le \negl(\lambda).
\]
\end{assumption}


\begin{theorem}\label{thm: sequentiality} {\normalfont \textbf{(Sequentiality).}}
Suppose $\mathcal{A}$ be a player who breaks the sequentiality of this proposed $\mathsf{VDF}$
 with probability $p_{win}$. Then there is a player $\mathcal{B}$ 
 who wins the time-lock oracle game $\mathcal{G}^{\mathsf{H}^{2^T}}_{2^{T+\delta+2}}$ with probability $p_{win}$.
\end{theorem}
\begin{proof}
 Run the $\mathsf{Setup}(1^\lambda,T)$ to obtain $(\mathsf{H},T)$. 
 $\mathcal{B}$ calls $\mathcal{A}$ on the input statement $x\xleftarrow{\$}\mathcal{X}$.
 Against $x$, $\mathcal{A}$ outputs $y\in\multgroup{\Delta}$ in time $< T$. 
 As $\mathcal{A}$ breaks the sequentiality of this $\vdf$, $y=\mathsf{H}(x)^{2^T+1} \mod{\Delta}$ 
 with the probability $p_{win}$. So $\mathcal{B}$ outputs $y \cdot \mathsf{H}(x)^{-1} \mod{\Delta}$ and wins the game 
 $\mathcal{G}^{\mathsf{H}^{2^T}}_{2^{T+\delta+2}}$ with probability $p_{win}$. \qed
\end{proof}

% \subsection{Explaining the Reduction}
% 
% Theorem~\ref{thm: sequentiality} essentially declares that our $\vdf$ is sequential as long as 
% time-lock puzzle is sequential. Still there are two groups $\multgroup{\Delta}$ and $\multgroup{2^{T+\delta+2}}$ 
% in which $g^{2^T}$ can be computed. So we must explain why does our $\vdf$ 
% stand sequential irrespective of the choice of the underlying group.
% To the best of our understanding, the adversary $\adv$ may adopt either of these strategies. 
% \begin{enumerate}
%  \item Over the group $\multgroup{\Delta}$, $\adv$ may compute $$g^{2^T}=g^{2^T\mod{\phi(T)}}=g^{2^T\mod{(p-1)(q-1)}}$$
%  only if the factorization of $T=pq$ is known. Here $\phi(T)=T\prod \limits_{p \mid T}(1-\frac{1}{p})$ is 
%  the order of the group.
%  
%  \item Over the group $\multgroup{2^{T+\delta+2}}$, $\adv$ can not do it in time $< T$ as  
%  $$g^{2^T}=g^{2^T\mod{\phi(2^{T+\delta+2})}}=g^{2^T\mod{2^{T+\delta+1}}}.$$ Even if there exists 
%  any shortcut to reach at $g^{2^T}$ over this group, it would immediately break the sequentiality 
%  of the time-lock puzzle via the identity  
% $g^{2^{T+\delta}}\mod{\Delta}=1\mod{(2^{T+\delta+2}\mod{\Delta})}$. Note that the left-hand side 
% operates only in the group $\multgroup{\Delta}$.
% 
% Further the elements 
%  in this group are $(T+\delta+2)$-bit long. Thus operations over this group are costlier than that in 
%  the group $\multgroup{T}$ as long as $T< 2^{(T+\delta+2)}$.
% \end{enumerate}
% Therefore, $\mathcal{A}_1$ must take at least $T$ sequential time even on $\poly(T)$ processors.

\section{Efficiency Analysis}\label{Efficiency}
Here we discuss the efficiencies of both the prover $\mathcal{P}$ 
and the verifier $\mathcal{V}$ in terms of number of modulo squaring 
and the memory requirement.

 \subsubsection{Proof Size} The proof size is essentially zero as the proof $\pi=\bot$ is empty. 
 The output $y$ is an element in the group $\multgroup{2^{T+\delta+2}}$. So the size of 
 the output is $(T+\delta+2)$-bits.
 
 \subsubsection{Prover's Efficiency} As already mentioned in Theorem~\ref{thm: sequentiality}, the prover
 $\mathcal{P}$ needs at least $T$ sequential time in order to compute $g^{2^T}$ such that $g=\mathsf{H}(x)$. 
 Additionally, one multiplication is needed to compute $g^{2^T+1}$.
   
\subsubsection{Verifier's Efficiency}
In this $\vdf$, verification needs $\delta$ number of modulo squaring. 
In a few lines, we show that $\delta=2$ suffices.
% We may allow this value to be subtle more to be safe. 

\subsubsection{Upper bound on $T$} As the output by the prover needs $(T+\delta+2)$-bits,
we need to restrict $T \in \poly(\lambda)$ at most. Cryptographic protocols that deal
with objects larger than the polynomial-size in their security parameter are impractical.


\subsubsection{Upper bound on $\delta$} Theorem~\ref{thm: bound} shows that $\delta>1$ is
necessary in this $\vdf$ sound. At the same time, verification needs at least $\delta$ number of
sequential squaring. Therefore, we keep $\delta$ as low as possible but greater than
$1$. So it gives us $\delta=2$.


\subsection{Performance Comparison}\label{compare}
Each of the existing $\vdf$s suffers from at least one limitation. We have already discussed them
in Sect.~\ref{literature}, however, reiterate here to show that the proposed $\vdf$ overcomes all of them.

\begin{description}
%  \item [Sequentiality] Adversary with $\poly(\lambda,T)$-parallelism breaks the 
%  sequentiality of the scheme~\cite{Dwork1992Price}. Theorem~\ref{thm: sequentiality} shows 
%  that our $\vdf$ stands sequential against any $\poly(\lambda,T)$-adversary.
 
 \item [Weak $\vdf$]  We call a $\vdf$ is a weak $\vdf$ if it demands $\poly(\lambda,T)$-parallelism to compute 
 the $\eval$ in time $T$. The $\vdf$ based on injective rational maps is a weak $\vdf$~\cite{Dan2018VDF}. 
 In our case, no parallelism is required to compute the $\vdf$ in time $T$.
 
 
 \item [Proof] The proofs in the Wesolowski's and Pietrzak's $\vdf$s consume one and $\log T$ group 
 elements~\cite{Wesolowski2019Efficient,Pietrzak2019Simple}. Moreover in Sect.~\ref{attack} we show that, 
 the proof itself in Wesolowski's $\vdf$ gave us an edge to attack it.
 Our $\vdf$ requires no proof. 
 
 % Furthermore, for the interactive versions they need $1$ and $\log T$ extra round(s) of interaction 
 % to communicate the proof~\cite{Wesolowski2019Efficient,Pietrzak2019Simple}. As the verification runs without a proof 
 % only $2$ rounds suffices to execute our $\vdf$. The prover sends the output $y$ and the verifier replies with its decision.
 
 \item [Slow $\setup$] The $\setup$ in the isogeny-based $\vdf$ may turn out to be as slow as the $\eval$ itself~\cite{Feo2019Isogenie} 
  questioning the practicality of the scheme. On the other hand, the $\setup$ in our $\vdf$ is exactly same as the 
  ones in all other time-lock based $\vdf$s~\cite{Wesolowski2019Efficient,Pietrzak2019Simple}.
  

  \item [$\Omega(\lambda)$-Verifiability]  All the existing $\vdf$s need at least $\lambda$ sequential effort for verification.
  The attack proposed in Sect.~\ref{attack} mandates at least $2 \lambda$-sequential effort for verification
  in Wesolowski's $\vdf$. 
  On the contrary, the most important advantage of our $\vdf$ is that the verification requires only $2$ modulo squaring.
  Thus the sequential effort in verification is independent of the parameters $\lambda$ and $T$. 

  \item [Largeness of $T$] A limitation of our $\vdf$ is that it works only when $T\in \poly(\lambda)$ as 
  the output size is dominated by $T$, while all the above-mentioned $\vdf$s allow $T \in 2^{o(\lambda)}$.
  
\end{description}

In Table~\ref{tab : VDF}, we summarize the above comparison. 
\begin{table}[h]
\caption{Comparison among the existing $\vdf$s. $T$ is the delay parameter, $\lambda$ is 
the security parameter and $\Gamma$ is the number of processors. All the quantities may be
subjected to $\mathcal{O}$-notation, if needed.}
\label{tab : VDF}
 \centering
 \begin{tabular}{|l@{\quad}|r@{\quad}|r@{\quad}|r@{\quad}|r@{\quad}|r@{\quad}|r@{\quad}}
    \hline
        $\vdf$s & $\eval$ & $\eval$ &  $\verify$ & $\setup$ & Proof   \\
(by authors)&  Sequential   & Parallel     &       &         &  size   \\
    \hline
    
   %  Dwork and Naor~\cite{Dwork1992Price}       & $T$   & $T^{2/3}$  &  $T^{2/3}$  & $T$ & $\textendash$ \\ 
   %  [0.3 em] \hline 
        
    Boneh et al.~\cite{Dan2018VDF}         & $T^2$ & $>T-o(T)$  &  $\log{T}$  & $\log{T}$ & $\textendash$  \\
    [0.3 em] \hline
    
    Wesolowski~\cite{Wesolowski2019Efficient} & $(1+\frac{2}{\log{T}})T$   & $(1+\frac{2}{\Gamma\log{T}})T$  &  $\lambda^{4}$  & $\lambda^{3}$ & $\lambda^{3}$ \\
    [0.3 em] \hline
    
    Pietrzak~\cite{Pietrzak2019Simple}        & $(1+\frac{2}{\sqrt{T}})T$   & $(1+\frac{2}{\Gamma\sqrt{T}})T$  &  $\sqrt{T}\log{T}$  & $\lambda^{3}$ & $\log{T}$ \\
    [0.3 em] \hline 
    
    Feo et al.~\cite{Feo2019Isogenie}         & $T$   & $T$  &  $\lambda^4$  & $T\log{\lambda}$ & $\textendash$ \\
    [0.3 em] \hline 
    
    \textbf{Our work}                         & $(1+\frac{2}{\log{T}})T$  & $(1+\frac{2}{\Gamma\log{T}})T$  &  $2$  & $\lambda^3$ & $\textendash$ \\
    [0.3 em]\hline
 \end{tabular}
\end{table}




\section{An Open Problem}\label{conclusion}
Beyond this the best that one can think of is a $\vdf$ that verifies spending only one 
sequential computation without any proof, if possible at all. In case of time-lock puzzle based 
$\vdf$s the sequential computation is modulo squaring.

\bibliographystyle{splncs04}
% \bibliography{ref}

\begin{thebibliography}{1}
\providecommand{\url}[1]{\texttt{#1}}
\providecommand{\urlprefix}{URL }
\providecommand{\doi}[1]{https://doi.org/#1}

\bibitem{Dan2018VDF}
Boneh, D., Bonneau, J., B{\"{u}}nz, B., Fisch, B.: Verifiable delay functions.
  In: Shacham, H., Boldyreva, A. (eds.) Advances in Cryptology - {CRYPTO} 2018
  - 38th Annual International Cryptology Conference, Santa Barbara, CA, USA,
      August 19-23, 2018, Proceedings, Part {I}. Lecture Notes in Computer Science,
  vol. 10991, pp. 757--788. Springer (2018).
  \doi{10.1007/978-3-319-96884-1\_25}

\bibitem{Cocke2019Maximal}
Cocke, W., Venkataraman, G.: On the number of elements of maximal order in a
  group. The American Mathematical Monthly  \textbf{126}(1),  66--69 (2019).
  \doi{10.1080/00029890.2019.1528826},
  \url{https://doi.org/10.1080/00029890.2019.1528826}

\bibitem{Dwork1992Price}
Dwork, C., Naor, M.: Pricing via processing or combatting junk mail. In:
  Brickell, E.F. (ed.) Advances in Cryptology - {CRYPTO} '92, 12th Annual
  International Cryptology Conference, Santa Barbara, California, USA, August
  16-20, 1992, Proceedings. Lecture Notes in Computer Science, vol.~740, pp.
  139--147. Springer (1992). \doi{10.1007/3-540-48071-4\_10}

\bibitem{Feo2019Isogenie}
Feo, L.D., Masson, S., Petit, C., Sanso, A.: Verifiable delay functions from
  supersingular isogenies and pairings. In: Galbraith, S.D., Moriai, S. (eds.)
  Advances in Cryptology - {ASIACRYPT} 2019 - 25th International Conference on
  the Theory and Application of Cryptology and Information Security, Kobe,
  Japan, December 8-12, 2019, Proceedings, Part {I}. Lecture Notes in Computer
  Science, vol. 11921, pp. 248--277. Springer (2019).
  \doi{10.1007/978-3-030-34578-5\_10}

\bibitem{Lenstra2017Sloth}
Lenstra, A.K., Wesolowski, B.: Trustworthy public randomness with sloth,
  unicorn, and trx. Int. J. Appl. Cryptogr.  \textbf{3}(4),  330--343 (2017).
  \doi{10.1504/IJACT.2017.10010315}

\bibitem{Mahmoody2020RO}
Mahmoody, M., Smith, C., Wu, D.J.: Can verifiable delay functions be based on
  random oracles? In: Czumaj, A., Dawar, A., Merelli, E. (eds.) 47th
  International Colloquium on Automata, Languages, and Programming, {ICALP}
  2020, July 8-11, 2020, Saarbr{\"{u}}cken, Germany (Virtual Conference).
  LIPIcs, vol.~168, pp. 83:1--83:17. Schloss Dagstuhl - Leibniz-Zentrum
  f{\"{u}}r Informatik (2020). \doi{10.4230/LIPIcs.ICALP.2020.83}

\bibitem{Pietrzak2019Simple}
Pietrzak, K.: Simple verifiable delay functions. In: Blum, A. (ed.) 10th
  Innovations in Theoretical Computer Science Conference, {ITCS} 2019, January
  10-12, 2019, San Diego, California, {USA}. LIPIcs, vol.~124, pp. 60:1--60:15.
  Schloss Dagstuhl - Leibniz-Zentrum f{\"{u}}r Informatik (2019).
  \doi{10.4230/LIPIcs.ITCS.2019.60}

\bibitem{Rivest1996Time}
Rivest, R.L., Shamir, A., Wagner, D.A.: Time-lock puzzles and timed-release
  crypto. Tech. rep., USA (1996)

\bibitem{Wesolowski2019Efficient}
Wesolowski, B.: Efficient verifiable delay functions. In: Ishai, Y., Rijmen, V.
  (eds.) Advances in Cryptology - {EUROCRYPT} 2019 - 38th Annual International
  Conference on the Theory and Applications of Cryptographic Techniques,
  Darmstadt, Germany, May 19-23, 2019, Proceedings, Part {III}. Lecture Notes
  in Computer Science, vol. 11478, pp. 379--407. Springer (2019).
  \doi{10.1007/978-3-030-17659-4\_13}

\end{thebibliography}



\end{document}


