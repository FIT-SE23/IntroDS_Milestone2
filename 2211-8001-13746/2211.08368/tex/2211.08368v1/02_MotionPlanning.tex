\chapter{Sampling-based Motion Planning}
\label{sec:motion-planning}

\begin{figure*}[h]
    \centering
    \begin{subfigure}{0.352\textwidth}
    \includegraphics[width=0.98\textwidth]{images/SBMP-CSpace.png}
    \subcaption[]{}
    \end{subfigure}
    \begin{subfigure}{0.638\textwidth}
    \begin{subfigure}{0.49\textwidth}
    \includegraphics[width=\textwidth]{images/SBMP-Sampling.png}
    \subcaption[]{}
    \end{subfigure}
    \begin{subfigure}{0.49\textwidth}
    \includegraphics[width=\textwidth]{images/SBMP-EdgeEvaluation.png}
    \subcaption[]{}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.49\textwidth}
    \includegraphics[width=\textwidth]{images/SBMP-PRM.png}
    \subcaption[]{}
    \end{subfigure}
    \begin{subfigure}{0.49\textwidth}
    \includegraphics[width=\textwidth]{images/SBMP-Search.png}
    \subcaption[]{}
    \end{subfigure}
    \end{subfigure}
    \caption{Solving a motion planning problem using a batch version of the \textit{Probabilistic Road-Map (PRM)} method. (a) The problem is transformed from the \textit{workspace} where the robot has geometry (top) to the \textit{configuration space} (bottom), where the robot is a point. (b) After \textit{sampling} the configuration space and \textit{validity checking} each sample in the workspace, valid samples (blue) are retained and invalid samples (orange) are discarded. (c) For every sample, local edges are \textit{constructed} to nearby samples and \textit{validity checked}. Valid edges (black) are retained and invalid edges (orange) are discarded. (d) Once the final roadmap is obtained, each edge is weighted by a \textit{cost} or a \textit{distance function}. (e) The final path is obtained using a graph search technique (such as A*), typically aided by an admissible \textit{heuristic function}. }
    \label{fig:sbmp-primitives}
\end{figure*}

An instance of a motion planning problem consists of a mobile object in a known environment.  The object could be a geometric shape, a rigid body, or a set of rigid bodies that are connected by joints, such as a robotic arm or articulated linkage.  The environment consists of a geometric space (called the \textit{workspace}), as well as a notion  of \emph{validity} that determines if paths within the environment are valid.  Normally this is accomplished by dividing the environment into valid (i.e. free) regions and invalid regions (i.e. obstacles).  A path is considered to be valid if it is totally contained in the free regions. For problems with constraints (e.g. dynamics constraints), the path must also satisfy these constraints.  A solution to the motion planning problem is a valid path by which the object traverses from a given start configuration to a given goal region.  

The basic version of the motion planning problem assumes that the environment is fully known and that the motions of the robot are exact.  It does not take into account uncertainty in the environment due to issues such as noise in the robot's sensors or actuators.  It also assumes that the robot's location in the environment is always known and as such does not address the problem of robot localization.

The object's motion is defined in terms of degrees of freedom, which include translational and rotational degrees of freedom as well as internal degrees of freedom (e.g. joint angles).  A \emph{configuration} consists of a setting for each of the degrees of freedom of the object and uniquely defines a \textit{state} of the robot.  The space of all possible configurations for a system is defined as the \emph{configuration space} or $\cspace$. A configuration is defined as valid or invalid based on if it satisfies a problem-specified validity condition.  This condition usually requires that there are no collisions between the object and any obstacles in the environment.  For robots that consist of multiple bodies (e.g. articulated linkages), validity conditions usually also require that there is no collisions between the bodies of the robot (i.e. self-collision).  Configurations can be tested for collision using a closed-box collision checker.

A path or a trajectory is a continuous sequence of configurations.  A path/trajectory is valid if all of the configurations along it are valid, otherwise it is invalid.  For systems with constraints (e.g. dynamics), trajectories must also adhere to these constraints of the system in order to be considered valid.  As stated previously, a solution to the motion planning problem is a valid path/trajectory between the start and goal configuration.  

For some applications, it is also important to consider path quality.  The quality of a path is indicated by a given cost function which the problem wishes to minimize (e.g. distance traveled or energy expended by the robot).  A cost function takes as input a path and returns a real number indicating the cost associated with the path.  



%Sampling based motion planning methods search for paths by constructing a \emph{roadmap} that consists of a set of sampled states (nodes) that are connected by a path/trajectory that is defined by a reproducible function (e.g. straight-line interpolation).  These paths/trajectories are referred to as local plans. Local plans can be tested for validity by stepping through the path/trajectory at a small interval and testing configurations for validity.

%A path or trajectory is said to be valid if all the configurations over it are valid.  For systems with constraints (e.g. dynamics), trajectories must also adhere to the dynamic constraints of the system in order to be considered valid. \troy{The wording in this paragraph is a bit clunky and needs to be edited}

%If such cases a valid path must also avoid collisions between the bodies of the robots (i.e. self-collisions).  

%In the classical motion planning problem paths are considered valid if the object does not collide with itself (self-collisions) or with any obstacles in the environment.  

%For problems with dynamic constraints, the path must also satisfy the differential constraints of the system and thus it must be possible to produce a sequence of feasible controls that form a solution path.

%\section{Sampling-based Motion Planning}
%\aravind{Need to define a few terms like $\mathbb{C}_{free}, \mathbb{C}_{obs}$ etc. since I use them in the figures.}\troy{added definition in section 2}
The complexity of motion planning in $\cspace$ grows exponentially with respect to the number of degrees of freedom, which make modeling $\cspace$ directly computationally challenging.  This has led to the development of sampling-based methods, such as the PRM \citep{KSLO-1996}, RRT \citep{L-1998} and RRT* \citep{KF-2011}, which construct an abstract representation of $\cspace$ via sampling. The sampled configurations are classified as valid (free) or invalid (obstacle) using a validity checker that tests if the sample is in the valid portion of $\cspace$.  Valid samples provide a representation of the free portion of $\cspace$ ($\mathbb{C}_{free}$) and the invalid samples provide a representation of the invalid portion ($\mathbb{C}_{obs}$).  \sbmps \ have been applied to a wide variety of problems including in mobile robot navigation, robotic manipulation, molecular simulations and animation. 

Sampling-based motion planning methods search for paths by constructing a \emph{roadmap} or a \emph{tree} that consists of a set of sampled states (nodes) that are connected by a path/trajectory that is defined by a reproducible function (e.g. straight-line interpolation).  These paths / trajectories are referred to as local plans. Local plans can be tested for validity by stepping through the path/trajectory at a small interval and testing configurations for validity.

% Sampling-based methods represent the connectivity of $\mathbb{C}_{obs}$ by either using a graph (also called a \textit{roadmap}) or a tree, where the nodes correspond to valid samples an free $\cspace$.  Edges are added between nodes if they can be connected by a path/trajectory that is defined by a reproducible function (e.g. straight-line interpolation in $\cspace$).  These paths/trajectories are referred to as local plans. Local plans can be tested for validity by stepping through the path/trajectory at a small interval and testing configurations for validity.
%and edges between nodes indicate that there exists a local path between the corresponding samples. Local paths are a simple path between two samples (such as a straight line is $\cspace$) and they can be tested for validity by using the collision detector to test configurations along the local path.  

The PRM algorithm \citep{KSLO-1996} constructs a roadmap by randomly sampling configurations across $\cspace$.  It then tests the samples for validity using a validity checker (e.g., a collision detector) and removes any samples that are invalid.  It then constructs a roadmap in which there is a node for each valid sample.  It then attempts to connect each sample to its $k$ nearest neighbors according to a distance metric (e.g. Euclidean distance).  If the connection is successful, it adds an edge between the nodes of the roadmap that correspond to the sample and the neighbor.  This roadmap can then be queried by inserting a given start and goal node into the roadmap and using a search procedure like Dijkstra's algorithm to find a path from the start node to the goal node. An illustration of this procedure is provided in Figure~\ref{fig:sbmp-primitives}.

The RRT algorithm \citep{L-1998} builds a tree by incrementally expanding existing nodes.  This method initializes the tree to contain the specified start node.  It then incrementally expands the tree by randomly sampling in $\cspace$, locating the node in the tree that is closest to the sample according to some distance metric and expanding that node by $\epsilon$ in the direction of the sample.  If the local path between the nearest node and the expanded node is valid then the expanded node is added to the tree. The algorithm then tests if the local path terminates in the goal region.  If so, it extracts a path from the start to the goal by backtracking.

%In recent years there has been a focus on methods that locate good quality paths.  To quantify path quality these methods require a cost function, which is a function that takes as input a path or a trajectory and returns a real number indicating the cost associated with the path/trajectory. This cost could indicates the distance traveled along the path/trajectory, or the energy required to traverse the path or some other metric that we wish to minimize. Normally the cost metric is additive so that the

Recently there has been a great deal of focus on developing methods that produce good quality paths and in particular on methods that are guaranteed to converge to a good quality path.  This has lead to the advent of  asymptotically optimal motion planners planner RRT*, PRM* \citep{KF-2011}, RRT-\# \citep{arslan2013use}, Stable Sparse RRT \citep{li2014asymptotically}, RRT-Blossom \citep{KP-2006}, Fast Marching Trees (FMT*) \citep{fmt}, AO-X \citep{Hauser_2016},  Dominance-Informed Region Trees (DIRT) \citep{LB-DIRT}, AO-RRT2 \citep{kleinbort2019refined}, and Batch-Informed Trees (BIT*) \citep{GBS-2020}. 
Asymptotically optimal methods are guaranteed to converge to an optimal solution as the number of samples approaches infinity (see related reviews on the subject: \cite{Bekris2020,gammell2021asymptotically}).

RRT* \citep{KF-2011} is an incremental approach that constructs a tree rooted at the start configuration, similar to RRT. At every iteration, the nearest tree node from a sample is used to \textit{steer} towards the sample to generate a node to add. For each such new node, the best parent is selected from a valid \textit{neighborhood} and steering is again used to connect the best parent to the new node. The best parent is decided in terms of the cost from the root of the tree to the new node via the candidate parent. The neighborhood is also \textit{rewired} by checking connections from the new node to existing nodes inside the neighborhood. This ensures that the algorithm maintains the \textit{optimal tree} in terms of cost from the start for the set of generated nodes. The solution can be returned by tracing the tree backwards from a node inside the goal to the root.