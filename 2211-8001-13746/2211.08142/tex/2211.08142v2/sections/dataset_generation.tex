\section{Equivalent Expressions Dataset}
\label{sec:datagen}
Training our model requires a dataset of mathematically equivalent expression \textit{pairs}. Working off a known collection of simple mathematical expressions, we use SymPy \citep{meurer2017sympy} to create the \textit{Equivalent Expressions Dataset} consisting of $\sim$4.6M equivalent expression pairs. This dataset is available publicly on our project page.

%In this work, we generate a dataset of equivalent mathematical expressions that we 
%refer to as the Equivalent Expressions Dataset. We discuss the dataset generation process in this section and present the dataset details in section \ref{sec:datasets}.
%For training, we require a set of mathematical expressions for \expemba{} and a set of equivalent expression pairs for \expembe{}. 
%Our dataset generation process consists of two steps. We first generate a set of valid mathematical expressions. For these expressions, we then generate mathematically equivalent expressions. For validation and testing, we only require a set of expressions for both \expemba{} and \expembe{}. This is because the decoder generates an equivalent expression in the case of \expembe{}. As there are multiple valid outputs in this case, we use SymPy to check validity of an output expression rather than fixing one output for every input expression.

\paragraph{Generation.}
To generate valid mathematical expressions, we refer to the work of \citet{lampleDeepLearningSymbolic2019}. We take expressions from their publicly available datasets and perform pre-processing to remove the parts that are not necessary for our use case. This process gives us a set of valid mathematical expressions. For these expressions, we use SymPy to generate mathematically equivalent but visually different counterparts (see Appendix \ref{appendix:eq_exp_generation} for details). For each pair of equivalent expressions $\mathbf{x}_1$ and $\mathbf{x}_2$, we add two examples $(\mathbf{x}_1, \mathbf{x}_2)$ and $(\mathbf{x}_2, \mathbf{x}_1)$ to the dataset. In our data generation process, we encounter expressions that result in NaN (Not a Number) when parsed using SymPy. We exclude examples that contain such expressions.

%Similar to \citet{lampleDeepLearningSymbolic2019}, we use the prefix (Polish) notation to represent expressions in our dataset. It is a parenthesis-free notation in which operators precede the operands.\footnote{\href{https://en.wikipedia.org/wiki/Polish_notation}{https://en.wikipedia.org/wiki/Polish\_notation}} For example, an expression $\sin(x) + 2 *\cos(x)$ is written as $+ \; \sin \; x \; * \; 2 \; \cos \; x$ in the prefix notation.

\paragraph{Dataset.}
Our training set has 4,662,300 input-output \textit{pairs} comprised of 2,744,824 unique expressions. Note that the number of equivalent expression pairs per unique expression is not straightforward to compute because some expressions result in more equivalent expressions than others. All expressions are univariate and consist of the following operators:
\begin{itemize}
    \itemsep0em
    \item Arithmetic: $+$, $-$, $\times$, $/$, $\mathrm{abs}$, $\mathrm{pow}$, $\mathrm{sqrt}$
    \item Trigonometric: $\sin$, $\cos$, $\tan$, $\cot$, $\sec$, $\csc$, $\sin^{-1}$, $\cos^{-1}$, $\tan^{-1}$
    \item Hyperbolic: $\sinh$, $\cosh$, $\tanh$, $\coth$, $\sinh^{-1}$, $\cosh^{-1}$, $\tanh^{-1}$
    \item Logarithmic/Exponential: $\ln$, $\exp$
\end{itemize}
The variable in the expressions is considered to be positive and real. For embedding analysis, this work only considers simple polynomial and transcendental mathematical expressions, and as such, we limit the input and output expressions to have a maximum of five operators. Table \ref{tab:no_expr_vs_ops} shows the number of expressions containing a particular type of operator. Note that one expression can contain multiple types of operators. Table \ref{tab:equiv_exp_dataset_stats} shows the number of operators in the training, validation, and test sets and corresponding sequence lengths.

Our validation and test sets contain a single expression per example instead of a pair. This is because there are multiple possible correct equivalent expressions for a given input expression. At inference, we use SymPy to determine if an output expression is equivalent to the input, instead of fixing one or multiple outputs for an input. The validation and test sets contain 2,000 and 5,000 expressions, respectively.

Note that an expression will only be present in one set but an equivalent expression may be present in another set. For example, if $\sin(x)$ is present in the training set as either input or output, it will not be present in the validation and test sets. But $\cos(x - \frac{\pi}{2})$ may be present in either validation or test set, but not both.

\begin{table}[]
    \caption{The number of expressions containing a type of operator in the Equivalent Expressions Dataset.}
    \label{tab:no_expr_vs_ops}
    % \vskip 0.15in
    \begin{center}
    \begin{small}
    \begin{sc}
    \begin{tabular}{lr}
    \toprule
    Operator Type &  \# Expressions \\
    \midrule
    Arithmetic & 1,423,972 \\
    Trigonometric & 341,805 \\
    Hyperbolic & 214,731 \\
    Logarithmic/Exponential & 901,460 \\
    \bottomrule
    \end{tabular}
    \end{sc}
    \end{small}
    \end{center}
    % \vskip -0.1in
\end{table}

\begin{table}[]
    \caption{The number of operators and sequence lengths of training, validation, and test sets of the Equivalent Expressions Dataset.}
    \label{tab:equiv_exp_dataset_stats}
    % \vskip 0.15in
    \begin{center}
    \begin{small}
    \begin{sc}
    \begin{tabular}{lrr}
    \toprule
    Set & \# Operators & Sequence Length \\
    \midrule
    Training & $5.68 \pm 1.32$ & $16.19 \pm 6.28$ \\
    Validation & $5.60 \pm 1.29$ & $15.03 \pm 4.31$ \\
    Test & $5.98 \pm 1.22$ & $16.20 \pm 4.13$ \\
    \bottomrule
    \end{tabular}
    \end{sc}
    \end{small}
    \end{center}
    % \vskip -0.1in
\end{table}