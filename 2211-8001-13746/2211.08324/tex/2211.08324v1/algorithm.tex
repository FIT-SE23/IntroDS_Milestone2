\section{Rounding Algorithm for the Augmentation Problem}
\label{sec:algo}

\newcommand{\LG}{\textnormal{LARGE}}
\newcommand{\SM}{\textnormal{SMALL}}
\newcommand{\lpopt}{\text{OPT}_{\text{LP}}} We adapt the algorithm and
analysis in~\cite{ChenLLZ22} to Flex-SNDP.  Let $\beta$ be the
expected congestion given by Theorem~\ref{thm:racke}.  Consider an
instance of $(p,q+1)$-Flex-SNDP specified by a graph $G$ and a set of
pairs $(s_i,t_i)$, $i \in [k]$. Assume that we have a partial solution
$H$ in which each $(s_i,t_i)$ is $(p,q)$-flex-connected. We augment
$H$ to ensure that each $(s_i,t_i)$ is $(p,q+1)$-flex-connected.

We start by obtaining a solution $\{x_e\}_{e \in E \setminus H}$ for
the LP relaxation to the augmentation problem, {\bf Augment-LP},
described in Section~\ref{sec:prelim}. Let $E' = E \setminus H$.  We
define $\LG = \{e \in E': x_e \geq \frac 1 {4(p+q)\beta}\}$, and
$\textnormal{SMALL} = \{e \in E: x_e < \frac 1 {4(p+q)\beta}\}$.  The
LP has paid for each $e \in \LG$ a cost of $c(e)/(4(p+q)\beta)$, hence
adding all of them to $H$ will cost $O((p+q)\beta \cdot \lpopt)$.  If
$\LG \cup H$ is a feasible solution to the augmentation problem, then
we are done since we obtain a solution of cost $O((p+q)\log n \cdot
\lpopt)$.  Thus, the interesting case is when $\LG \cup H$ is \emph{not} a
feasible solution.  In effect, we can assume that $\LG =
\emptyset$. One can assume this situation without loss of generality
by creating sufficiently many parallel edges for each $e$ and
splitting the $x(e)$ amongst them.

Following \cite{ChenLLZ22} we employ a \racke tree based rounding.
A crucial step is to set up a capacitated graph appropriately.  We can
assume, with a negligible increase in the fractional cost, that for
each edge $e \in E \setminus H$, $x(e) = 0$ or $x(e) \ge
\frac{1}{n^3}$; this can be ensured by rounding down to $0$ the
fractional value of any edge with very small value, and compensating
for this loss by scaling up the fractional value of the other edges by
a factor of $(1+1/n)$. It is easy to check that the new solution
satisfies the cut covering constraints, and we have only increased the
cost of the fractional solution by a $(1+1/n)$-factor. In the
subsequent steps we can ignore edges with $x_e = 0$ and assume that
there are no such edges.

Consider the original graph $G=(V,E)$ where we set a capacity for each
$e \in E$ as follows. If $e \in \LG \cup H$ we set $\tilde x_e = \frac
1 {4(p+q)\beta}$. Otherwise we set $\tilde x_e = x_e$.  Since the
ratio of the largest to smallest capacity is $O(n^3)$, the height of
any \racke tree for $G$ with capacities $\tilde x$ is at most
$O(\log n)$.  Then, we repeatedly sample \racke trees. For each
tree, we sample edges by the rounding algorithm given by Chalermsook
et al in~\cite{CGL15} (see Section~\ref{sec:prelim} for details).  A
formal description of the algorithm is provided below where $t'$ and
$t$ are two parameters that control the number of trees sampled and
the number of times we run the tree rounding algorithm in each sampled
tree.  We will analyze the algorithm by setting both $t$ and $t'$ to $\Theta((p+q)\log n)$.

\begin{algorithm}[H]
\caption{Augmentation from $(p,q)$ to $(p, q+1)$-flex-connectivity}
\label{augmentation_algo}
\begin{algorithmic}
    \State $H \gets$ partial solution satisfying $(p,q)$-flex-connectivity for given instance
    \State $\{x\}_{e \in E} \gets$ fractional solution to \textbf{Augment-LP}
    \State $\textnormal{LARGE} \gets \{e \in E: x_e \geq \frac 1 {4(p+q)\beta}\}$
    \State $\textnormal{SMALL} \gets \{e \in E: x_e < \frac 1 {4(p+q)\beta}\}$
    \State $H \gets H \cup \textnormal{LARGE}$
    \If{$H$ is a feasible solution to $(p, q+1)$-Flex-SNDP}
        \Return $H$
    \Else 
        \State $\tilde x_e \gets \begin{cases}
            \frac 1 {4(p+q)\beta} & e \in H \\
            0 & x_e < \frac 1 {n^3} \\
            x_e & \text{otherwise}
            \end{cases}$
    \EndIf
    \State $\calD \gets $ \racke tree distribution for $(G, \tilde x)$
    \For{$i = 1, \dots t'$}
        \State Sample a tree $(\calT, \calM, y) \sim \calD$
        \For{$j = 1, \dots, t$}
            \State $K \gets $ output of oblivious TreeRounding algorithm on $(G, \calT)$
            \State $H \gets H \cup \calM(K)$
        \EndFor
    \EndFor \\
    \Return H
\end{algorithmic}
\end{algorithm}
