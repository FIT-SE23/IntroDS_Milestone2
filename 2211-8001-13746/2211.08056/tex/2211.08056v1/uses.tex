\section{Use Case: Microservices and Service Meshes}

\archshort improves the efficiency of cloud workloads. These workloads benefit
from the efficient resource sharing, specialization at the OS-level or
efficiently bypassing the OS.

Several cloud services are implemented as microservices, a set of functionally
independent, but highly connected components. These components are deployed via
an orchestration framework and connected via a service mesh governing access
between different components and allowing to observe the behavior of the
service. Existing frameworks deploy such workloads via containers and virtual
machines completely isolating each component from each other. In addition,
service meshes~\cite{istio} deploy proxies like envoy~\cite{envoy}, intercepting
all network communication in a co-located container. As a result network
messages have to be copied between containers and OS multiple times and objects
marshaled.

To avoid this overhead, \archshort deploys service mesh proxies and components
in the same address space allowing them to communicate and invoke each other via
shared interfaces. In addition, if components are co-located their communication
can be short-circuit as well, and a service mesh proxy could even eliminate
itself from the communication path. As a result, we copy network messages less
and marshalling/unmarshalling may not be necessary. Netbricks~\cite{netbricks}
suggests similar optimizations for network functions.

\if 0

\subsection{Optimizing Virtual Memory for Machine Learning}

Large virtual memory allocations suffer from high cost of page tables and OS
data structures tracking the allocated memory~\cite{rebootingmemory}. This not
only wastes memory space, but also becomes a problem from CPU address
translation buffers (TLBs) and caches, since their size is highly limited, and
bandwidth could be used otherwise.

Memory-safe runtimes such as Wasm deploy a different memory model that the
execution and \archshort can take advantage of. In particular, the abstraction
of a linear memory helps to represent the memory of a machine learning
application. An implementation of \archshort can take advantage and limit its data
structures to the start and end of memory while the CPU relies on a small static
mapping between virtual and physical addresses. As a result, we could optimize
internal structures such as page tables, page miss handlers, TLB to make more
die space available to, e.g., increase CPU caches or register files and in turn
improve performance.

\fi