\if 0
% discussion with Mona

* Hardware section - do not perscribe solution - reimagine HW for this
* What is memory-safe software and what protections does it provide
* bounded memory accesses
* control-flow integrity
* Basic security guarantees
* Use control-flow for security
* Secure Isolation - fine-grained
    * privileged instructions
    * change CPU behavior
    * access privileged memroy
    * privileged memroy
    * define as privileged (privileged allocates)
* Today
    * Supervisor modes/userspace
* What is the split between software and hardware to implement these?
* How does this combine with recent CC/CHERI suggestions? (software relaxed) vs. software only approach which doesn't need more in the hardware.

\fi

\section{\arch}

In this section we provide an understanding of how memory-safe languages and
runtimes help building a novel software runtime environment and what hardware
optimizations and features improve performance.

\subsection{Isolating Services}

\archshort relies on memory-safe languages and runtimes to isolate memory of
services, build independent fault domains~\cite{multics}, and enable sharing to
allow efficient use of services within the system. The goal is to build these
abstractions without relying on traditional CPU capabilities such as address
space identifiers, rings, supervisor mode or privileged instructions.

To isolate memory accesses of services, \archshort relies on Software Fault
Isolation (SFI)~\cite{sfi} techniques in compilers or interpreters, or
compiler-enforced object-granular memory-safety. Since memory safety guarantees
vary between languages and runtimes, their capabilities have to be analyzed,
understood and measures taken to ensure that each service is isolated. Recent
work~\cite{isolationinrust} analyzes the memory safety properties of Rust for
isolating services.

We suggest researching a unifying abstraction layer building a foundation across
languages and runtimes providing different memory-safety properties. The
difference between Rust and Wasm, for example, lies in the ability of Rust to
enforce memory safety on a per object level as long as the type system is
respected, whereas Wasm enforces memory safety at a coarse granularity limiting
memory to the entire Wasm virtual machine memory space. Rust's type system helps
when two Rust implementations exchange data. In contrast, sharing data across
two independent Wasm modules requires new techniques to make the same memory
available to both modules at the same time. Ideally, hardware and software
mechanisms enable sharing and isolation across different languages and runtimes
allowing for efficient software-only sharing when possible and using hardware to
enforce sharing when the software mechanisms do not enforce fine-grained memory
safety.

A unified memory-safe service isolation provides the basis for private memory
in each service. In case these techniques allow unsafe execution (no memory
safety properties during the execution), the compiler needs to either prevent
their execution or further restrict access by deploying runtime bounds checks.
To avoid control flow vulnerabilities bypassing the memory-safety measures, the
compiler additionally needs to restrict and control jump and call targets to the
set of potential landing targets. Both, Rust and Wasm, achieve these goals with
no or minor changes.

\subsection{\archshort~OS or library OS}

We discuss two alternatives to realize \archshort, a memory-safe OS and a
multi-service memory-safe library OS. Our analysis considers existing work on
building Rust-based OSes~\cite{buildingrustos, caseforrustos, tockrustkernel,
redox}. Building a new OS provides the greatest possible flexibility and avoids
some of the existing inherent overheads that traditional OSes bring. Its
downside is the additional implementation overhead and a long path towards
adoption. Alternatively, a library OS implementation allows adoption in an
existing environment such as Linux. Due to the dependence on a host OS, not all
of the hardware, abstraction and scheduling optimizations can be implemented
with a library OS limiting the possible performance gain.

The main difference between the two alternatives, is how the \archshort OS
handles interrupts, timers, and other low-level traditional OS functionality by
itself, whereas the library OS needs to communicate with the hosting OS to
achieve these behaviors. A prominent example is the control over page tables
which is impossible without changes to a traditional OS from the userspace. Page
table-based optimizations will be much harder with a library OS-based approach and
their efficient setup or modification could limit performance benefits.

\paragraph{System Calls and interactions}

Traditionally, an application accesses and shares information with the host or
network-connected services via the system call interface. Our goal is to provide
an extensive interface resembling dynamic library loading rather than fixed
system calls. To allow memory-safe services to exchange information, the memory
access capabilities have to be transferred. When two Rust services communicate,
they could agree on the same underlying type system of the exchanged memory and
continue to adhere to the memory safety properties. Similarly, Rust's ownership
model lends itself to this architecture to borrow the output of one service to
another. To keep track of this borrowing, a runtime service has to keep track of
the most recent owner to ensure proper destruction of the memory once it is no
longer in use.

Today memory-safe languages do not support sharing types systems across
service domains. Each language would have to be extended to support this
type system. With languages like Wasm, such cross-service communication is
not protected by the memory safety properties and even breaks the memory access
model of Wasm virtual machines which assume a bounded memory size.

To overcome these limitations, we suggest a software-only based technique which
offers proxy access. A proxy access allows a service to switch to a function
with access to the shared memory object (e.g., via a list of proxy functions
accessible to the function) while not switching the service's context. As a
result, access to the shared memory is as quick as a function call, and such
capabilities can be arbitrarily granted by generating the according proxy access
function. A proxy-aware compiler could generate proxy functions and
translate memory accesses into proxy functions calls to transparently switch
between the two.

\paragraph{Common Services}

Both alternatives have to provide common OS functionalities such as a file
system, network connections, and per service specific metadata such as file
descriptors. To allow specialization for workloads, only a minimal
substrate should be provided, and dependencies should be selected by each
service. The initially needed building blocks are a service loader to enable
execution of services, and an interface for each service to discover
other services providing certain functionality. In this regard, discovering
a service is possible by name and leads to loading a function pointer table into
the execution of the service. Any subsequent communication happens via this
function table instead of calling into the OS via system call. As a result, a
system call becomes a function call instead. All the service switching
mechanics, if needed, are hidden within the function call pointers as prepared
by the only real system call to discover other services. This design offers
the most flexibility, like microkernels~\cite{microkernel, microkernel2},
and offers the ability to build an abstraction layer for legacy applications
mapping the new interface to previous interfaces when needed.

As part of the discovery service, the system negotiates between different memory
safety properties, take advantage of fine-grained properties, or rely on
hardware-provided capabilities to allow efficient access. For instance, assuming
all services and services were built in Rust and the supply chain would
provide evidence of this fact, the system could rely on Rust's internal type
system to protect access capabilities when services exchange information.

\subsection{Hardware implications}

As discussed in previous sections, some of the traditional hardware
functionalities can alternatively be provided by relying on memory safety
instead. Consequently, \archshort offers several avenues to further optimize
hardware for improved performance and security.

\paragraph{Address translation and caches}

Traditional address translation in CPUs relies on page tables and caches within
the CPU to reduce the number of page walks. The translation lookaside buffer
(TLB) caches recent translations between virtual and physical memory. In case a
miss occurs, the page miss handler (PMH) walks the actual page table to find a
possible mapping. This takes several hundred cycles to complete and requires
memory bandwidth to receive the page table entries from memory. Services
with high memory bandwidth demands particularly suffer when frequent page walks
occur which reduce the memory bandwidth~\cite{rebootingmemory}.

Wasm simplifies the memory model in its virtual machine specification to a
linearly growing memory area. For cloud services, the required memory size is
typically known before launch and described in deployment files. This simplified
memory layout with its allocations and mappings can be coalesced into larger
regions and ideally mapped such that their address translation can be performed
statically. Such a static mapping removes entries from the TLB lowering the
pressure for most memory accesses and avoids any page table walks, since the
mapping is statically configured. To avoid fragmentation, different power of 2
buckets could be created in physical space to allocate different maximum memory
sizes. Additional research is needed to adopt these optimizations to
memory-safe-only environments and further improve the efficiency and performance
of hardware mechanisms.

\paragraph{Hardware-support for efficient memory sharing}

In \archshort memory-safe languages restrict memory accesses of a service and do
not allow arbitrary sharing between services limiting the efficiency of
communication. To overcome this restriction, hardware and software techniques
can provide efficient ways to communicate. Traditional OSes solve this problem
via shared memory, but \archshort shares all virtual memory automatically. As a
result, only the memory-safety guarantees restrict accesses to arbitrary memory.
We can ideally design techniques to safely open this restrictive design while
maintaining the performance and security guarantees that memory-safe languages
provide.

Hardware can assist the memory safe language by providing low level access
capabilities to allow sharing of memory when the memory safe language does not
allow such fine-grained access permissions like Wasm or in case of Rust when the
type system is not known at compilation time.

Existing work on process-based isolation~\cite{codoms, dipc, coffer}, provides a
capability-based system based on page tables. In these systems, fine grained
memory sharing is enabled via specially crafted memory capabilities allowing
multiple processes to share access to memory with other processes.

To achieve similar sharing within the same virtual address space,
CHERI~\cite{cheri} or Cryptographic Computing~\cite{cryptocompute} provide the
ability to set capabilities from within the same virtual address space without
involvement of the OS.

\paragraph{Constraining legacy applications}

\archshort adoption is limited by implementing new or reimplementing existing
services for this architecture. Translating existing services automatically
allow faster adoption, but requires them to become memory safe. The service
needs to be restricted to the service' memory and control flow boundaries.

Wasm can be used as compilation target in common compilers today and transform
existing applications to a virtual machine definition limiting access of the
application into a 4GB memory and providing a well-structured control flow
sufficiently restricting the application to be used in \archshort system.
Unfortunately, Wasm degrades performance compared to native and requires access
to source code.

In contrast to such a software-only approach, are hardware-based
techniques~\cite{erim, hodor, donky, secage, endokernel, galeed} (mostly \intel
MPK-based) which rely on CPU features to restrict memory accesses.
Unfortunately, these systems require elaborate security
monitors~\cite{endokernel} and the hardware features may not be readily
available. As a result, novel architecture extensions could help translate
legacy applications into \archshort.

\if 0

In contrast to such a software-only approach, are hardware-based
techniques~\cite{erim, hodor, donky, secage, endokernel, galeed} (mostly \intel
MPK-based) which rely on CPU features to restrict memory accesses. These systems
provide coarse-grain control flow allowing execution to jump anywhere as long as
they stay within the same application. This could leak confidential code present
during the run of such an application. In order to use these techniques for
legacy applications, these techniques would need to be combined with hardware
mechanisms to restrict control flow such as \intel CET or use a software-based
approach like code-pointer integrity~\cite{cpi}.

To aid adoption, \archshort should consider providing a POSIX API. This allows
existing applications to be ported with minimal or no changes. Instead of the
suggested service discovery interface, an independent abstraction layer would
translate the POSIX API to the underlying services. Such abstraction could be
implemented within libc and translate system calls into service calls instead.
Additionally, such a system dynamically translates \texttt{sysenter}
instructions in the binary code to avoid side stepping the libc abstraction
layer.

\paragraph{Zero-cost transitions}

While \archshort cuts down transition times between applications, it still
requires switching context information such as registers, memory layout, stacks
and a like. Kolosick et al.~\cite{zerocostswitch} describe the requirements for
memory-safe languages, and Wasm in particular, to avoid most of such context
switch cost. Future hardware and software techniques should support these
zero-cost conditions and allow even lighter weight contexts switches. For
instance, a hardware mechanism providing memory isolation is flexible enough to
allow the runtime to not save and restore callee-save registers when the
underlying binary implementation adheres to the standard calling convention.


\paragraph{Transient Execution Attacks.}

Today's common memory-safe languages and runtimes do not limit recent transient
execution attacks~\cite{}. Some of these attacks are prevented in recent
hardware~\cite{}. To further improve the security, research such as
Swivel~\cite{} is needed. At the moment, limiting these attacks via
software-only techniques results in runtime overheads. So far the \archshort
cannot relay the layout and interaction of components to the hardware, since the
architecture does not offer ways to name components within the same address
space. Speculatively CPUs consider processes as the unit protection. Recent
capability machine proposals such as CHERI~\cite{} and Cryptographic
Computing~\cite{} suggest considering finer grained units of protection and
offer a potential path to limit the exposure to these types of attacks.
Generally, we need additional research into efficient single address space
hardware abstractions which may improve the security of \archshort.

\fi