\section{Background}

\paragraph{Modern Cloud Deployments}
Server applications increasingly replicate functionality traditionally found in
operating systems. Their intent is to improve performance by specializing
functionality to the workload, and provide a portable environment across
operating systems and hardware. In case of Fastly and
Cloudflare~\cite{fastly-wasm,cloudflare-workers} most functionality is executed
in userspace reducing context switch overheads and infrastructure tax. These
providers achieve this goal by executing functions in the services together with
a userspace scheduler, memory management, and dedicated userspace network
stacks. Library OS~\cite{demikernel, graphene, ix, arrakis} similarly improve
performance of applications via reducing system calls and bypassing the kernel
for network and storage requests with specialized libraries~\cite{dpdk}.
Figure~\ref{fig:mssa_comparison} shows common software and hardware
architectures of CSP deployments.

\if 0
The main purpose of replicating functionality in the user space is to gain
control, adapt functionality to the workloads needs and improve performance by
avoiding the OS. For example, control over scheduling allows applications to
better specialize their execution sequence of the workload, quality of service,
and client requirements. At the same time, handling the application's needs
within the userspace reduces the amount of time that is spent in context
switches, copying from/to the userspace which improves performance~\cite{ix,
demikernel}.
\fi

The trend to replicate functionality in the userspace has two main drawbacks.
First, applications require specialized implementations of functionality that
has a standard OS interface hindering the reuse of specialized implementations.
Second, due to the added features, a larger code base offers more opportunities
to be exploited, thereby increasing the need to isolate fault domains.

\paragraph{Memory-Safe Languages}
Memory-safe languages and runtimes~\cite{wasm, nacl, rust} improve the developer
productivity and application security by eliminating memory-safety violations
such as buffer overflows~\cite{projectzero2021report}. While memory safety
guarantees vary, memory safe languages generally limit any memory access of an
application to a subset of the entire address space, and can be combined control
flow integrity to avoid bypassing or altering runtime security checks. The most
common forms are object-based memory safety which enforces an access granularity
on an object-level, whereas virtual machine-based memory safety only limits
access to the memory area defined by the virtual machine.

Recently, Rust~\cite{rust} and Webassembly (Wasm)~\cite{wasm} innovated the
state of the art in two different directions. Throughout this paper we refer to
Rust and Wasm as a representative for their class of memory-safe language. Rust
is a compiler-enforced memory-safe language and instead of relying on garbage
collection, relies on the model of borrowing and ownership of memory objects.
Recent work focuses on proving security for these unsafe
environments~\cite{rustbelt}, providing secure environments limiting the
capabilities of unsafe code~\cite{pkru-safe}, or isolating
components~\cite{isolationinrust}. The Wasm specification describes both, a byte
code and a virtual machine executing the byte code, providing security
guarantees regarding the control flow and memory boundaries. Recent work
recognizes the importance of memory-safe languages and suggests their use in a
moonshot project to build a novel software architecture with supporting
hardware~\cite{cybersecuritymoonshot}.

\paragraph{Single Address Space OS (SASOS)}

Before CPUs supported multiple address spaces and page tables, OSes were built
assuming a single address space. These SASOS relied on capability
systems~\cite{opal} and software fault isolation~\cite{singularity} to isolate
multiple applications and OS components. Most recently, Microsoft with the
Midori and Singularity OS~\cite{midori, singularity} tried to build a SASOS to
improve the execution of distributed workloads and formally verify security
guarantees of the toolchain and system. Additionally, CSPs more and more rely on
unikernels~\cite{mirageos, unikraft, graphene} to improve performance. The
efficiency of these systems lies in the near-zero cost of sharing memory and
low-cost context switching.

\paragraph{Memory-safe Library OS}

Demikernel~\cite{demikernel}, Occlum~\cite{occlum}, FaaSm~\cite{faasm}, or
cubicleOS~\cite{cubicleOS} are library OSes (library OS) reling on memory-safe
languages to reduce the attack surface of the library OS and FaaS runtimes like
FaaSm~\cite{faasm} additionally isolate functionality using Wasm. These efforts
hint towards an environment in which most software executes within a memory-safe
environment, either by being written in a memory-safe language (e.g., Rust) or
being compiled to Wasm which offers sandbox isolation guarantees.