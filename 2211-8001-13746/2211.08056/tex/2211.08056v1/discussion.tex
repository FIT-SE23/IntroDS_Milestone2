\section{Discussion}

\archshort relies on memory-safe languages instead of traditional hardware
functionality and as a result, offers several avenues to optimize hardware for
improved performance and security. This direction reduces the reliance on
long-used and battle-proven isolation techniques. Memory-safe languages and
runtimes provide certain security properties, but their capabilities are limited
with respect to hardware-based attacks and protecting against them may incur
about 2x runtime overhead~\cite{narayan2021swivel}. CHERI~\cite{cheri} and
Cryptographic Computing~\cite{cryptocompute} offer capability-based replacements
that \archshort could rely on to strengthen the security properties.
Alternative, and more light-weight approaches should be considered like bringing
back 32-bit segmentation or the RISC-V J extension~\cite{riscvj}. Recently,
hardware-based light-weight subprocess isolation has been an active area of
research with promising techniques like Donky~\cite{donky} suggesting a RISC-V
extension similar to \intel MPK or research using \intel MPK for
isolation~\cite{erim, hodor, endokernel}. Additional exploration and research in
this hardware and software co-design can bridge the gap and overcome today's
performance and security limitations.

The security foundation of \archshort depends on the memory-safe compilation
tool chain and a small, but important runtime component. The runtime component
needs to load services within the single address space while respecting the
security requirements of the memory-safe language's toolchain. Each toolchain
may have different requirements regarding the memory layout (e.g., Wasm requires
an 8 GB space around each module's heap). Some toolchains, e.g. Webassembly,
lends itself to runtime verification allowing to check binary code for memory
safety guarantees before starting to execute it~\cite{veriwasm}. Another path to
establish trust in each toolchain is to vet and certify it, and securely record
the supply chain of the service. Before starting a service the runtime would
authenticate the trusted toolchain and the metadata of a
service~\cite{marcelasecureorch}. Alternatively,
proof-carrying-code~\cite{necula1997proof} can establish trust in the binary of
a service. To further strengthen the security and reduce the dependencies,
future research should explore formal verification and trusted supply chains.

Several research prototypes~\cite{faasm,lwc, erim, narayan2021swivel} run
services in the same address space to improve communication overhead.
Fastlane~\cite{fastlane} is the first to automatically combine multiple services
running inside containers to be combined into a single container. Their
prototype efficiently combines Python-based services and carefully parallelizes
service invocations to improve performance. While Fastlane proposes an
interesting direction to improve the current environment, it is limited to a
single language, weaker hardware isolation with limited security guarantees. In
contrast, \archshort focuses on the use of memory-safe languages and leveraging
hardware optimizations for optimal performance and security tradeoff between
hardware and software.