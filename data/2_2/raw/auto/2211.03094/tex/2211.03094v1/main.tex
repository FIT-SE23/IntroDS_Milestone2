\documentclass[%
reprint,
superscriptaddress,
%groupedaddress,
%unsortedaddress,
%runinaddress,
%frontmatterverbose, 
%preprint,
%showpacs,preprintnumbers,
%nofootinbib,
%nobibnotes,
%bibnotes,
 amsmath,amssymb,
 aps,
 pra,
%prb,
%rmp,
%prstab,
%prstper,
%floatfix,
]{revtex4-1}


\usepackage{graphicx}% Include figure files
\usepackage{dcolumn}% Align table columns on decimal point
\usepackage{bm}

%\usepackage{cmap} 
%\usepackage[T2A]{fontenc} 
\usepackage[utf8]{inputenc} 

\frenchspacing  
\usepackage{multirow}
\usepackage[warn]{mathtext}
\usepackage{amssymb}



\usepackage{textcomp} 
\usepackage{indentfirst} 
\usepackage{amsmath} 
\usepackage{graphicx}
\DeclareGraphicsExtensions{.pdf,.png,.jpg}
\usepackage{pgfplots}
\pgfplotsset{compat=1.13}

%\usepackage{times}

\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=black,      
    urlcolor=black,
    citecolor= violet
}

\usepackage{algpseudocode}

\renewcommand{\bibname}{References}

%Includes "References" in the table of contents
\usepackage[nottoc]{tocbibind}


% \usepackage{xcolor}
% \definecolor{darkblue}{rgb}{0,0,.5}
% \definecolor{darkviolet}{rgb}{0.58, 0.0, 0.83}

\newcommand{\ilya}[1]{\textcolor{blue}{#1}}
\newcommand{\ilyarm}[1]{\textcolor{red}{#1}}

\pagestyle{myheadings}
\begin{document}

\makeatletter
\newcommand{\settitle}{\maketitle}
\makeatother


\title{Scalable quantum error correction code on a ring topology of qubits}
% \title{Resource-sparing quantum error correction code}

\author{Ilya. A. Simakov}
\email{simakov.ia@phystech.edu}
\affiliation{Russian Quantum Center, 143025 Skolkovo, Moscow, Russia}
\affiliation{National University of Science and Technology ``MISIS'', 119049 Moscow, Russia}
\affiliation{Moscow Institute of Physics and Technology, 141701 Dolgoprudny, Russia}
\author{Ilya. S. Besedin}
\thanks{Present address: Department of Physics, ETH Zurich, Zurich, Switzerland}
\affiliation{Russian Quantum Center, 143025 Skolkovo, Moscow, Russia}
\affiliation{National University of Science and Technology ``MISIS'', 119049 Moscow, Russia}
% \affiliation{Present address: Department of Physics, ETH Zurich, Zurich, Switzerland}
% \author{A. V. Ustinov}
% \affiliation{Russian Quantum Center, 143025 Skolkovo, Moscow, Russia}
% \affiliation{National University of Science and Technology ``MISIS'', 119049 Moscow, Russia}
% \affiliation{Physikalisches Institut, Karlsruhe Institute of Technology, 76131 Karlsruhe, Germany}

\date{\today}

\begin{abstract}
Quantum error correction is an important ingredient for scalable quantum computing. Stabilizer codes are one of the most promising and straightforward ways to correct quantum errors, since they do not require excessive complexity of physical qubits, are convenient for logical operations, and improve performance with increasing the involved qubits number. Here, we propose a linear scalable code of the permutative stabilizers for small distances on the ring architecture, which takes into account the topological features of the superconducting platform. We present the way to construct the quantum circuit of the code and provide numerical simulation that demonstrate the exponential logical error rate suppression.

\end{abstract}




\settitle


\section{Introduction}

Large error rates of about $10^{-3}$ \cite{PhysRevLett.125.120504, PhysRevLett.123.120502, Huang_2019, PhysRevLett.127.180501, Moskalenko_2022} are a major obstacle towards practical application of quantum computing. Therefore, quantum error correction (QEC) is expected to be a significant and unavoidable part of a fault-tolerant quantum computer \cite{PhysRevA.32.3266, PhysRevA.52.R2493, Calderbank_1996, knill1996threshold}. One of the most promising methods for correcting quantum errors is considered to be stabilizer codes, for which logical qubits are encoded in an entangled state of a large number of physical qubits. By measuring $X$ or $Z$ parity operators (syndromes) one can identify the occurrence of errors in the underlying physical qubits \cite{DiVincenzoShor, SteaneQEC, GottesmanPhd}. A variety of such codes has been developed and simulated under plausible error conditions \cite{LowDistanceSurfaceCodes, Trout_2018, Muyuan2017, XZZXSurfaceCode, Bravyi2018, OBrien2017, AWScatcode, Yalecatcode}. 

Experimental implementation of correction codes is a difficult task that requires a larger number of qubits and high-precision operations on them. At the same time, especially in large devices, the topology of the code should map onto the underlying qubits and their connections, so that the amount of operations per code size remains low. For example, for superconducting systems, high-fidelity two-qubit gates can be typically realized only between adjacent qubits. When choosing a correction code, this aspect should be necessarily taken into account. Among the recent experimental demonstrations we highlight the repetition code \cite{googleRepetitveCode}, surface code \cite{acharya2022suppressing, DiCarlo2021logical, PhysRevLett.129.030501, andersen2020repeated}, and color code \cite{PhysRevX.11.041058} implemented on various platforms.

Yet another important property of the correction codes is scalability, here meaning the ability to correct more physical errors by increasing the number of involved data qubits \cite{NielsenChuang}. The milestone experiments demonstrating the error suppression are presented in works \cite{googleRepetitveCode, acharya2022suppressing}. 

The smallest possible code that corrects an arbitrary single-qubit error is the perfect five-qubit code \cite{PhysRevLett.77.198}. Its stabilizers can be generated as cyclic permutation of a basic stabilizer $XZZXI$. The five-qubit code implementation with the iSWAP gates on a ring topology was proposed in \cite{schuch2003natural} and thoroughly simulated in \cite{chain10, Antipov_2022}. Furthermore, there is the tailored $XZZX$ code \cite{Xu_2022, Kovalev_2012}, that can be considered as a scaling of the five-qubit code. 
 

In this paper, we describe a set of linear scalable low-distance QEC codes, for which the stabilizers are generated by  cyclic permutations of the basic stabilizer, similar to the five-qubit code. For a practical implementation, we propose a quantum circuit consisting of alternating ancillary and data qubits forming a ring, with natural two-qubit iSWAP and SWAP gates available between any neighboring qubits. We study the efficiency of the code with the respect to the errors occurring during and between correction cycles and compare them with the tailored $XZZX$ code. The proposed code required reasonably low hardware overhead and is affordable in near-term demonstration experiments.

\section{Code construction}

\begin{figure*}[t]
    \center{\includegraphics[width=\linewidth]{chain26.pdf}}
    \caption{The schematic layout of the 13-qubit code on the ring topology and a part of the quantum circuit. The red and aquamarine circles mark data and ancillary qubits correspondingly. The full quantum circuit can be reconstructed by translation of the shown segment. The major part of the scheme are the six series of the two-qubit gates applied to the neighboring qubits. We highlight the path of the computational state of the first ancillary qubit and show the data qubits with which it interacts during the correction cycle. Also, we stress that in the end of the cycle the computational states of data qubits are shifted.}
    \label{fig:chain26}
\end{figure*}

% In this section, we provide the key principle of the proposed linear scalable codes and describe the quantum circuit of error correction cycles. Also, we give details of the selected noise model and error decoding method.


A correction code encoding one logical qubit into $n$ physical qubits can be described by $n-1$ syndrome generators. Below we give the basic syndrome for the codes with distances $3,$ $5,$ $7$, $9$ and $11$, respectively:
\begin{equation}
    \begin{aligned}
        &d=3, \; n=5 : \; g_0 = ZXXZI \\
        &d=5, \; n=13 : \; g_0 = ZIXXIZ\underbrace{I...I}_{7} \\
        &d=7, \; n=21 : \;  g_0 = ZIIXXXXIIZ\underbrace{I...I}_{11} \\
        &d=9, \; n=29 : \;  g_0 = ZXXIIXIIXIIXXZ\underbrace{I...I}_{15}, \\
        &d=11, \; n=37 : \;  g_0 = ZXXXIIIXIIXIIIXXXZ\underbrace{I...I}_{19},
    \end{aligned}
\end{equation}
where $X$, $Y$, $Z$, $I$ are the Pauli operators, and we assume tensor product sign $\otimes$ between each of them. The remaining $n-2$ generators can be obtained from $g_0$ by sequentially rolling beyond the last position and re-introducing at the first. The logical operators of the codes can be written by the following single-qubit operators:
\begin{equation}
    X_L = X^{\otimes n}, \; Y_L = Y^{\otimes n}, \; Z_L = Z^{\otimes n}.
\end{equation}


% \begin{table}[h!]
%     \begin{center}
%         \begin{tabular}{|c|c|c|}
%             \hline
%             \hline
%             Distance & Qubit number & Generator \\
%             \hline
%             \hline
%             3 & 5 & $ZXXZI$\\
%             \hline
%             5 & 13 & $ZIXXIZ\underbrace{I...I}_{7}$\\
%             \hline
%             7 & 21 & $ZIIXXXXIIZ\underbrace{I...I}_{11}$\\
%             \hline
%             9 & 29 & $ZXXIIXIIXIIXXZ\underbrace{I...I}_{15}$\\
%             \hline
%             11 & 37 & $ZXXXIIIXIIXIIIXXXZ\underbrace{I...I}_{19}$\\
%             \hline
%             \hline
%         \end{tabular}
%     \end{center}
%     \caption{Linear-scalable low-distant QEC codes.}
%     \label{chain_syndromes}
% \end{table}

Measurement of the syndromes can be efficiently realized on a ring of alternating $n$ ancillary and $n$ data qubits. Assuming single-qubit gates, initialization procedure and single-shot readout available for an arbitrary qubit, we propose a quantum circuit for QEC cycle with only iSWAP and SWAP two-qubit gates between the neighboring qubits. We note, that the scheme contains one extra ancilla, which corresponds to a syndrome that is not independent, but a product of the other syndrome generators.

The code with $d=3$ is well-known as the perfect five-qubit code. Its behavior under a realistic noise model in the ring topology of 10 series-connected superconducting qubits has been researched in detail in \cite{chain10}. Here, we focus on the codes with higher distances and explain their main concept with the 13-qubit code example. The quantum circuit of the correction cycle is presented in Fig.~\ref{fig:chain26}. It requires 26 physical qubits, half of which keep the encoded logical state, and the rest are used to extract syndrome data that gives information about possible errors that may have occurred during the previous cycles. Every correction cycle starts and finishes with initialization in the ground state and single-shot readout of all ancillary qubits. During the correction cycle each ancilla is affected by six two-qubit gates and as a result entangles with four data qubits in the way it is highlighted for the first ancilla in Fig.~\ref{fig:chain26}. 

It should be noted, that in a such circuit the computational states of ancillary and data qubits move towards each other clockwise and counterclockwise. The transition from the standard ``fixed'' ancilla $ZZ$ and $XX$ entanglement method to the ``sliding'' ancilla is shown in Fig.~\ref{fig:syndromeconstruction}. This approach might be helpful in quantum circuits, when it is substantial for one qubit to interact with several non-neighboring qubits.

The quantum circuits of the other codes with higher distances are constructed by analogy.



\begin{figure*}[t]
    \center{\includegraphics[width=\linewidth]{xx_zz.pdf}}
    \caption{Transforming the conventional quantum circuit of $ZZ$ (top) and $XX$ (bottom) stabilizer measurements to a scheme with iSWAP gates and ``sliding'' ancillary qubit. The diagram has the same notations as the Fig~\ref{fig:chain26}.}
    \label{fig:syndromeconstruction}
\end{figure*}


\section{Methods}

To characterize the efficiency of the correction codes, we focus on the performance of the logical qubit as a quantum memory. In order to simulate a state preservation experiment we need to suggest a relevant error model and a decoding algorithm.

For the error model we choose an independent and identically distributed standard depolarizing channel:
\begin{equation}
    \mathcal{E}(\rho) = (1-p)\rho + p_x X\rho X + p_y Y\rho Y^\dagger + p_z Z\rho Z,
\end{equation}
where $p=p_x+p_y+p_z$ is the error probability, and $p_x$, $p_y$, and $p_z$ are probabilities of $X$, $Y$, and $Z$ errors, respectively. 

In order to observe the dynamics of an open quantum system properly, one need to simulate time evolution of the density matrix as it is done in the works \cite{LowDistanceSurfaceCodes, OBrien2017} for Surface-17 and in \cite{chain10} for perfect five-qubit code. However, such simulations become intractable due to the exponentially growing Hilbert space size, and approximate models which correspond to the experiment are generally used\cite{Srivastava_2022, Bravyi2018}. For the current research we propose the following noise model. We consider that an independent single-qubit $X$, $Y$, or $Z$ error might occur to any data qubit during the correction cycle and between them. The probability of such error is proportional to the duration of the correction cycle or measurement and initialization procedures. The errors accumulate from cycle to cycle and affect both the syndromes of subsequent correction cycles and the final logical state of the system. The errors that happen between and during correction cycles differ in that the former may not change the values of the proper syndromes in the current cycle and fully affect only the subsequent measurement cycles.

In practice, we generate $2n$ sequences, half of which correspond to  errors during the correction cycles with probability $p_d$, and the rest are for the errors between cycles with probability $p_b$. With these errors we determine the logical state of the system after each series of syndrome measurement. Also, we generate the relevant results of the syndrome measurements. Finally, we randomly with probability $1/2$ change measurement results of all ancillas that interact during the correction cycle via iSWAP or SWAP gate with a data qubit affected by an error that happened during the current cycle. 

For the decoding algorithm we choose an improved version of a lookup table decoder for its clarity and simplicity. First, we detect all the syndrome changes $s_{i,j}$:
\begin{equation}
    s^i_j= 
    \begin{cases}
    0, & \text{if } j = 1\\
    s^i_{j} = m^i_{j} - m^i_{j-1} \pmod 2,& \text{otherwise,}
    \end{cases}
\end{equation}
where $m^i_j$ is the result of $i=1,...,n$ ancillary qubit measurement after cycle $j=1,...,m$, and takes the values $0$ or $1$.
If there are errors in two consecutive syndromes after the $j$ and $j+1$ cycles, we translate all measurement results from $j$ to $j+1$ cycle and neglect the changes of the $j$ syndrome:
\begin{algorithmic}
    \For {$j < m$}
        \If {$\sum_i s^i_j \neq 0 \ \mathbf{and} \ \sum_i s^i_{j+1} \neq 0$} 
            \For {$i \leq n$}
            \State $s^i_{j+1} \gets s^i_j + s^i_{j+1} \pmod 2$
            \State $s^i_{j} \gets 0$
            \EndFor
        \EndIf
    \EndFor
\end{algorithmic}
% \begin{algorithmic}
%     \FOR {$j < m$}
%         \IF {$\sum_i s^i_j \neq 0 \ \mathbf{and} \ \sum_i s^i_{j+1} \neq 0$} 
%             \FOR {$i \leq n$}
%             \STATE $s^i_{j+1} \gets s^i_j + s^i_{j+1} \pmod 2$
%             \STATE $s^i_{j} \gets 0$
%             \EndFor
%         \EndIf
%     \EndFor
% \end{algorithmic}

This approach allows to detect errors that happened during the correction cycle after the next cycle. Next, we match the obtained syndromes to the logical qubit error as it is done in the classical lookup table decoding algorithm, and finally, we get a correction sequence of logical operations.


\section{Results}

To estimate the efficiency of the code performance, we compare the logical failure rate $\epsilon_L$ of different codes as a function of single-qubit error rate $p$. The relation between these parameters is expected to be described by a power low: $\epsilon_L \sim p^r$. As a QEC code with distance $d$ detects up to the $(d-1)/2$ independent single-qubit errors, then the probability of an uncorrectable error is proportional to $p^{(d+1)/2}$. Thus, for an effective code we require a linear dependence of power $r$ on distance $d$.

We simulate the state preservation experiment for the six cardinal qubit states with different single-qubit error rate. The error model is described in the methods section. Firstly, we choose a symmetric depolarization channel: $p_x=p_y=p_z=p/3$. Secondly, as the relation between $p_d$ and $p_b$ probabilities depends on the duration of the correction cycles for codes with different distances, we need to estimate characteristic times of single-qubit, two-qubit gates, readout and reset procedures. Here we base on time scales obtained in recent experiment \cite{googleRepetitveCode} and choose the duration of Hadamard gate $T_{g1}=14$ ns, iSWAP and SWAP gates $T_{g1}=26$ ns, measurement and initialization $T_{m}=880$ ns, $S$ and $Z$ gates are supposed to be virtual. The relation between $p_d$ and $p_b$ can be written as $p_d/p_b = 2(n_{Q1}T_{g1} + n_{Q2}T_{g2})/T_m$, where $n_{Q1}$ and $n_{Q2}$ are the numbers of Hadamard and two-qubit gates and the factor $2$ takes into account that during the cycle the errors happen with $2n$ qubits.

We run the state preservation experiment with $50$ cycles $10^6$ times per each chosen value of $p_b$, and calculate the fidelity of the recovered states. The obtained points we approximate with the function \begin{equation}
    F(t) = \frac{1}{2} + \frac{1}{2} (1 - 2\epsilon_L)^{t-t_0},
    \label{fid_approx}
\end{equation}
where $\epsilon_L$ is the logical error rate per $1 \, \mu$s, $t$ is the time in $\mu$s. The parameters $\epsilon_L$ and $t_0$ are obtained by the least squares method fit. We repeat the simulation for different single-qubit error probabilities $p_b$ (remind that $p_d$ is a function of $p_b)$ and present the obtained dependence of the logical error rate in a logarithmic scale in Fig~\ref{fig:result}. We fit this data with a linear function and plot the slope $r$ for different distances in Fig~\ref{fig:lin_result}. We observe good agreement between parameter $r$ and code distances, that shows that the proposed codes correct the required number of errors.

\begin{figure}[t]
    \center{\includegraphics[width=\linewidth]{result.pdf}}
    \caption{Logical error rate plotted as a function of the physical error probability between correction cycles $p_b$. The lines show the linear fit of the simulated data in the logarithmic scale. The slope $r$ of each code distance is given in the legend description and the errors are calculated as a standard deviation. The crosses and dashed line refer to the cyclic code with distance $d=7$ implemented on the ring architecture, that is provided for comparison.}
    \label{fig:result}
\end{figure}


\section{Discussion}

The key result of our study presented above is a quantum circuit that scales the perfect five-qubit code linearly. The number of total qubits required for the code is close to the Hamming bound. Today, when state-of-the-art superconducting quantum processor generally consists of several dozens physical qubits, the small footprint of the correction code is a significant advantage, that allows to examine QEC experimentally. Nevertheless, we mention, the code is not scalable in the conventional sense of the term. The maximum number of non-identity single-qubit operators or, in other words, the weight of the code syndromes increases with code distance. This is the main reason why it is excessive to scale this code for higher distances. 

Yet another point of the research is the comparison of the proposed code with cyclic code $[[n,1,d]]$, that quadratically scales: $n = (d^2+1)/2$ \cite{Xu_2022}. Its syndromes are generated with the cyclic permutation of the base syndrome $g_0 = ZI^{\otimes(t-1)}XXI^{\otimes(t-1)}ZI^{\otimes{(n-2t-2)}}$, where $t=(d-1)/2$. For distances 3 and 5 the both codes are identical. Thus, we simulate cyclic code with $d=7$ on the same ring architecture with $50$ qubits and present the obtained dependence of the logical failure rate on the physical error rate with the dashed line in Fig.~\ref{fig:result}. Even though the cyclic code has the shorter correction cycle, as its quantum circuit requires $8$ series of the two-qubit gates against $10$, the 
linear scalable code shows better performance because it uses less physical qubits. 

Finally, we highlight the decoding problem. In the current paper we use a slightly modified lookup table decoder that is foolproof and fast. The proposed code is not a Calderbank-Shor-Steane code \cite{Calderbank_1996, SteaneQEC}, thus we cannot analyze $X$ and $Z$ errors separately and use common minimum-weight perfect matching decoding algorithm \cite{edmonds_1965, pymatching}. However, there are other alternative promising decoding methods, that for example use neural network approach \cite{Krastanov_2017, chain10} or approximate matrix product state simulations \cite{PhysRevA.90.032326}, but they are usually time and memory consuming. So, the problem of finding the optimal real-time scalable decoding is relevant and urgent for future research.

\begin{figure}[t]
    \center{\includegraphics[width=\linewidth]{lin_result.pdf}}
    \caption{The linear slope $r$ of the logarithmic logical failure rate $\epsilon_L \sim p^r$ plotted as a function of the code distance. We observe exponential error suppression with the code scaling and good agreement with the linear fit (dashed line). The colors and markers of the dots corresponds to the data in the Fig~\ref{fig:result}.}
    \label{fig:lin_result}
\end{figure}

\section{Conclusion}

In conclusion, we propose a family of linear scaling codes for small distances on a realistic superconducting circuit topology. The corresponding quantum circuit is defined on a ring of $2n$ superconducting qubits with natural two-qubit iSWAP and SWAP gates available between each pair of neighboring qubits. The amount of qubits required for the realization of these codes is within the reach of current generation hardware even for larger code distances. Furthermore, we have studied the logical fidelity of the proposed linear code assuming the model of independent and identically distributed error during and between correction cycles and decoding, based on the intuitive lookup table algorithm. Despite the inseparable by $X$ and $Z$ syndromes, the simplicity of the decoder and an increased duration of the correction cycle, we observe exponential reduction of the logical failure rate with the code distance. 
The key challenge for further advancing these codes is the development of a decoder suitable for more accurate error models.

\section*{Acknowledgments}

The authors acknowledge Alexey Ustinov for helpful discussions and comments on the manuscript. We acknowledge partial support from the Ministry of Education and Science of the Russian Federation in the framework of the Program of Strategic Academic Leadership “Priority 2030”.

\renewcommand{\bibname}{Reference}
\bibliographystyle{unsrtnat}
\bibliography{main}
    
% \renewcommand{\bibname}{Reference}
% \bibliographystyle{unsrt}
% \bibliography{main.bib}
 
 
% \newpage
% \newpage
% \clearpage



% \appendix

% \section{Density-matrix simulation details}

% In order to estimate

\end{document}