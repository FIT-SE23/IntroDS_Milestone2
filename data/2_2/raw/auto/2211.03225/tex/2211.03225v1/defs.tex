% random maths
\newcommand{\downsquigarrow}{\mathbin{\text{\rotatebox[origin=c]{270}{\(\rightsquigarrow\)}}}}
\makeatletter
  \newcommand{\xRightarrow}[2][]{\ext@arrow 0359\Rightarrowfill@{#1}{#2}}
  \newcommand{\xleftrightarrow}[2][]{\ext@arrow 0359\leftrightarrowfill@{#1}{#2}}
\makeatother
\newcommand{\eqdef}{\triangleq}
\renewcommand{\iff}{\mbox{\textit{iff}}\xspace}
\newcommand{\eint}[2]{\llbracket #1,#2\rrbracket}
\newcommand{\N}{\mathbb N}
\newcommand{\R}{\mathcal R}
% \newcommand{\Z}{\mathbb Z}
\let\oldemptyset\emptyset
\let\emptyset\varnothing
\let\oldepsilon\epsilon
\let\epsilon\varepsilon
\let\oldrho\rho
\let\rho\varrho


% complexity
\newcommand\complexityfont{\small \sffamily}
\newcommand\nexp{{\complexityfont NEXP}\xspace}
\newcommand\np{{\complexityfont NP}\xspace}
\newcommand\logspace{{\complexityfont LOGSPACE}\xspace}
\newcommand\nlogspace{{\complexityfont NLOGSPACE}\xspace}
\newcommand\pspace{{\complexityfont PSPACE}\xspace}
\newcommand\ptime{{\complexityfont PTIME}\xspace}
\newcommand\ctime{{\complexityfont TIME}\xspace}
\newcommand\cspace{{\complexityfont SPACE}\xspace}
\newcommand\polyh[1]{\(\Pi_{#1}\)\xspace}

\newcommand\problemfont{\small \scshape}
\newcommand\hornsat{{\problemfont HornSAT}\xspace}
\newcommand\sat{{\problemfont SAT}\xspace}
\newcommand\sucsat{{\problemfont SuccinctSAT}\xspace}
\newcommand\qbf[1][]{{\problemfont QBF}\(_{#1}\)\xspace}
\newcommand\Deducibility{{\problemfont Deducibility}\xspace}
\newcommand\Secrecy{{\problemfont Secrecy}\xspace}
\newcommand\StaticEquiv{{\problemfont StatEq}\xspace}
\newcommand\TraceEquiv{{\problemfont TraceEq}\xspace}
\newcommand\TraceInclus{{\problemfont TraceIncl}\xspace}
% \newcommand\DiffEquiv{{\problemfont DiffEq}\xspace}
% \newcommand\SessEquiv{{\problemfont SessEq}\xspace}
\newcommand\Bisimilarity{{\problemfont Bisimilarity}\xspace}
\newcommand\Similarity{{\problemfont Similarity}\xspace}
\newcommand\Simulation{{\problemfont Simulation}\xspace}
\newcommand\Succinctsat{{\problemfont Succint 3SAT}\xspace}
\newcommand\indcpa{{\problemfont Ind-CPA}}


% tools
\newcommand\toolfont{\scshape}
\newcommand\proverif{{\toolfont ProVerif}\xspace}
\newcommand\tamarin{{\toolfont Tamarin}\xspace}
\newcommand\deepsec{{\toolfont DeepSec}\xspace}
\newcommand\akiss{{\toolfont Akiss}\xspace}
\newcommand\spec{{\toolfont Spec}\xspace}
\newcommand\satequiv{{\toolfont SatEquiv}\xspace}
\newcommand\apte{{\toolfont Apte}\xspace}
\newcommand\avispa{{\toolfont AVISPA}\xspace}
\newcommand\scyther{{\toolfont Scyther}\xspace}
\newcommand\maude{{\toolfont Maude-NPA}\xspace}
\newcommand\ukano{{\toolfont Ukano}\xspace}


% pi calculus: function symbols
\newcommand\senc{\mathsf{senc}}
\newcommand\sdec{\mathsf{sdec}}
\newcommand\aenc{\mathsf{aenc}}
\newcommand\adec{\mathsf{adec}}
\newcommand\testaenc{\mathsf{test\_aenc}}
\newcommand\getkey{\mathsf{get\_key}}
\newcommand\rsenc{\mathsf{rsenc}}
\newcommand\rsdec{\mathsf{rsdec}}
\newcommand\raenc{\mathsf{raenc}}
\newcommand\radec{\mathsf{radec}}
\newcommand\pk{\mathsf{pk}}
\newcommand\pks{\mathit{pk}}
\newcommand\sk{\mathit{sk}}
\newcommand\sks{\mathit{sk}}
\newcommand\vpk{\mathsf{vpk}}
\newcommand\sign{\mathsf{sign}}
\newcommand\checksign{\mathsf{verify}}
\newcommand\zkp{\mathsf{zkp}}
\newcommand\checkzkp{\mathsf{verify}}
\newcommand\fst{\mathsf {fst}}
\newcommand\snd{\mathsf {snd}}
\newcommand\okfun{\mathsf{ok}}
\newcommand\kofun{\mathsf{ko}}
\newcommand\0{\mathsf 0}
\newcommand\1{\mathsf 1}
\newcommand\ffun{\mathsf{f}}
\newcommand\gfun{\mathsf{g}}
\newcommand\hfun{\mathsf{h}}
\newcommand\truefun{\mathsf{true}}
\newcommand\falsefun{\mathsf{false}}
\newcommand\otherfun{\mathsf{getOther}}

\newcommand\args[2]{\overrightarrow{#1}^{#2}}
\newcommand\call[1]{{\tt Goto}\left\langle#1\right\rangle}
\newcommand\getEnv[1]{{\tt GetEnv}\left\langle#1\right\rangle}

% pi calculus: model
\newcommand{\msg}{\mathsf {msg}}
\newcommand\norm{\!\!\downarrow}
\newcommand\ax{\mathsf{ax}}
\newcommand\InP[2]{{#1}(#2)}
\newcommand\OutP[2]{\overline {#1}\langle #2 \rangle}
\newcommand\LetP{\mathsf{let}}
\newcommand\LetInP{\mathsf{in}}
\newcommand\IfP{\mathsf{if}}
\newcommand\ThenP{\mathsf{then}}
\newcommand\ElseP{\mathsf{else}}
\newcommand\TestP[1]{\left[#1\right]}
\newcommand\NewP{\mathsf{\color{red} new}\ }
\newcommand\BangP[1][]{!^{\scriptscriptstyle #1}}
\newcommand\BangCh{!^{\mathit{ch}}\,}
\newcommand\multi[1]{\{\!\!\{ #1\}\!\!\}}
\newcommand\pair[1]{\langle #1\rangle}
\newcommand\sig{\mathcal {F}}
\newcommand\sigc{\sig_{\mathsf {c}}}
\newcommand\sigd{\sig_{\mathsf {d}}}
\newcommand\termset{\mathcal T}
\newcommand\recipeset{\termset^2}
\newcommand\Nall{\mathcal N}
\newcommand\Npub{\mathcal N_{\mathsf{pub}}}
\newcommand\Npriv{\mathcal N_{\mathsf{priv}}}
\renewcommand\P{\mathcal P}
\newcommand\Q{\mathcal Q}
\newcommand\X[1][]{\mathcal X^{#1}}
\newcommand\Xfst{\X[1]}
\newcommand\Xsnd{\X[2]}
\newcommand\Xsndi[2][\leqslant]{\X[2]_{\raisebox{1pt}{\(\scriptscriptstyle #1\)} #2}}
\newcommand\AX{\mathcal {AX}}
\newcommand\dom{\mathit{dom}}
\newcommand\im{\mathit{img}}
\newcommand\id{\mathit{id}}
\newcommand\rootf{\mathit{root}}
\newcommand\ptree{\mathsf{PTree}}
\newcommand\poslab{\mathsf{pos}}
\newcommand\neglab{\mathsf{neg}}
\newcommand\witness{\mathsf{w}}
\newcommand\fsol{f_{\mathsf{sol}}}
\newcommand\inp{\mathsf{in}}
\newcommand\outp{\mathsf{out}}
\newcommand\process[2]{(#1,#2)}
\newcommand\frameh[1]{\Phi_{#1}}
\newcommand\frameb[1]{\Phi_{#1}^\B}
\newcommand\framen[1]{\Phi_{#1}^{\mathsf N}}

\newcommand\tsize[1]{\left|#1\right|}
\newcommand\dagsize[1]{\left|#1\right|_{\mathsf{dag}}}
\newcommand\subterms[1][]{\mathit{st}^{#1}}
\newcommand\strsubterms[1][]{\mathit{sst}^{#1}}
% \newcommand\subtermsfst{\subterms[1]}
% \newcommand\subtermssnd{\subterms[2]}
% \newcommand\strsubtermsfst{\strsubterms[1]}
% \newcommand\strsubtermssnd{\strsubterms[2]}
\newcommand\vars[1][]{\mathit{vars}^{#1}}
\newcommand\varsfst{\vars[1]}
\newcommand\varssnd{\vars[2]}
\newcommand\bvars{\mathit{bvars}}
\newcommand\bvarsfst{\bvars^1}
\newcommand\bvarssnd{\bvars^2}
\newcommand\axioms{\mathit{axioms}}
\newcommand\names{\mathit{names}}
\newcommand\termsetsnd{\termset^2}
\newcommand\simpStep[1]{\mathrel{\xrightarrow{#1}\!\!\simplnorm}}
\newcommand\SimpStep[1]{\mathrel{\xRightarrow{#1}\!\!\simplnorm}}
\newcommand\Vnorm{\mathord{\rotatebox[origin=c]{270}{\mbox{$\rightsquigarrow$\hspace{1pt}}}}}


% semantics
\newcommand\cstep[1]{\xrightarrow{#1}}
\newcommand\Cstep[1]{\xRightarrow{#1}}
\newcommand\silentstep\rightsquigarrow
\newcommand\silent{\overset\star\rightsquigarrow}
\newcommand\silentrev{\overset\star\leftsquigarrow}
\newcommand\silentpistep{\silentstep_{\mathsf{pi}}}
\newcommand\silentpi{\overset\star\silentstep_{\mathsf{pi}}}
\newcommand\procnorm[1]{{#1}_{\downarrow_{\mathsf{pi}}}}
\newcommand\actions{\mathit{actions}}
\newcommand\tr{\mathsf {tr}}
\newcommand\StatEq{\sim}
\newcommand\DiffEq{\approx_d}
\newcommand\LabBis{\approx_b}
\newcommand\Simu{\sqsubseteq_s}
\newcommand\Simuinv{\sqsupseteq_s}
\newcommand\Simi{\approx_s}
\newcommand\TraceEq{\approx_t}
\newcommand\TraceIncl{\sqsubseteq_t}
\newcommand\A{\mathcal A}
\newcommand\simpl\rightsquigarrow
\newcommand\simplnorm{\mbox{\scalebox{0.9}{$\downsquigarrow$}}}



% reductions
\newcommand\val{\mathsf{val}}
\newcommand\TestNode{\mathsf{TestNode}}
\newcommand\TestBool{\mathsf{TestBool}}
\newcommand\Node{\mathsf{Node}}
\newcommand\gNode{\gfun_{\mathsf{N}}}
\newcommand\gBool{\gfun_{\mathbb{B}}}
\newcommand\hNode{\hfun_{\mathsf{N}}}
\newcommand\hBool{\hfun_{\mathbb{B}}}
\newcommand\invN{\mathsf{Test_N}}
\newcommand\invB{\mathsf{Test_B}}
\newcommand\recpos[2]{{#1}_{|#2}}
\newcommand\CheckTree[1]{\mbox{\texttt{CheckTree}}(#1)}
\newcommand\CheckSat[1]{\mbox{\texttt{CheckSat}}(#1)}
\newcommand\guessBinary[1]{{\tt Choose}(#1)}
\newcommand\evalFormula[2]{#1 \leftarrow #2}
\newcommand\initlab{\mathit{Init}}
\newcommand\veriflab{\mathit{CheckSat}}
\newcommand\veriftreelab{\mathit{CheckTree}}
\newcommand\verifsatlab{\mathit{CheckSat}}
\newcommand\printlab{\mathit{Print}}
\newcommand\decrlab{\mathit{Decr}}
\newcommand\evallab{\mathit{Eval}}
\newcommand\reslab{\mathit{Res}}
\newcommand\vallab{\mathit{val}}
\newcommand\dummylab{\mathit{dummy}}
\newcommand\finallab{\mathit{Final}}
\newcommand\extractlab{\mathit{Extract}}
\newcommand\choicelab{\mathit{Choice}}
\newcommand\choice{\mathsf{Choose}}
\newcommand\extrlab{\mathit{Extr}}
\newcommand\dummyextrlab{\mathit{DummyExtr}}
\newcommand\getchoicelab{\mathit{ComputeChoices}}
\newcommand\inlab{\mathit{in}}
\newcommand\outlab{\mathit{out}}
\newcommand\banglab{\mathsf{bang}}
\newcommand\parlab{\mathsf{par}}
\newcommand\rewardlab{\mathit{reward}}
\newcommand\newsess{\mathit {sess}}
\newcommand\treetype[1]{\tau_{\mathsf{BT}}^{#1}}
\newcommand\iosize[1]{||\mathsf{io}_{#1}||}

% \newcommand\choice{\mathsf{Choose}}
\newcommand\sem[1]{\left\llbracket #1\right\rrbracket}
\newcommand\B{\mathbb B}




% constraint solving
\newcommand\C{\mathcal C}
\newcommand\D{\mathcal D}
\newcommand\Set{\mathcal S}
\newcommand\dedfact{\vdash^{\scriptscriptstyle ?}}
\newcommand\ndedfact{\nvdash^{\scriptscriptstyle ?}}
\newcommand\eqfact{=^?}
\newcommand\neqfact{\neq^?}
\newcommand\eqs{=^?} % for recipes equations
\newcommand\neqs{\neq^?}
\newcommand\eqf{=^?_f}
\newcommand\neqf{\neq^?_f}
\newcommand\arityrestr[2]{\left|#1\right| \leqslant #2}
\newcommand\negarityrestr[2]{\left|#1\right| > #2}
\newcommand\subsformula[1]{\llbracket #1 \rrbracket}
\newcommand\arity{\mathit{ar}}
\newcommand\maxarity[1]{\#(#1)}
\newcommand\bigo{\mathcal O}
% \newcommand\Fmgu{\alpha}
\newcommand\mgu{\mathit{mgu}}
\newcommand\mguR[1][\R]{\mgu_{#1}}
\newcommand\eqnset{\mathcal E}
\newcommand{\replacepos}[3]{#1[#3]_{#2}}

\newcommand\syn[1][\R]{\ensuremath{\mathit{syn}_{#1}}}

\newcommand\Df{\mathsf{D}}
\newcommand\Eq{\mathsf{E}}
\newcommand\Eqn[1][]{\Eq^{#1}}
\newcommand\Eqfst{\Eqn[1]}
\newcommand\Eqsnd{\Eqn[2]}
\newcommand\Solved{\mathsf{K}}
\newcommand\USolved{\mathsf{F}}
% \newcommand\Equni{\mathsf{E}^{\mathit{uf}}}
\newcommand\equality[1]{#1_{=}}
\newcommand\disequality[1]{#1_{|\neq}}

\newcommand\bisim{\mathrel{\mathcal{R}}}
\newcommand\disim{\mathrel{\mathcal{S}}}
\newcommand\cs{Constraint Solving}

% partition tree
\newcommand\PartitionTree{\mathsf{PTree}}
\newcommand\mgs[1][]{\mathit{mgs}^{#1}}
\newcommand\Sol[1][]{\mathit{Sol}^{#1}}
\newcommand\rootlab{\mathit{root}}
% \newcommand\inlab{\mathit{in}}
% \newcommand\outlab{\mathit{out}}
\newcommand\freshlab{\mathit{fresh}}
\newcommand\sstep[1]{\xrightarrow{#1}_{\mathsf{s}}}
\newcommand\Sstep[1]{\xRightarrow{#1}_{\mathsf{s}}}
\newcommand\tstep[1]{\xrightarrow{#1}_{T}}
\newcommand\Tstep[1]{\xRightarrow{#1}_{T}}
\renewcommand\S{\mathbb {S}}
% \newcommand\clause[3]{\forall #1.\ #2 \Leftarrow #3}
\newcommand\clause[3][]{
  \ifthenelse{\isempty{#1}}
    {#2 \Leftarrow #3}
    {\forall #1.\ #2 \Leftarrow #3}
}
\newcommand\conseq{\mathsf{Conseq}}
\newcommand\stc{\mathit{st}_{\mathsf{c}}}
\newcommand\getpos[2]{{#1}_{|#2}}
\newcommand\recipes{\mathsf{R}} % previously "\InitInput"
\newcommand\quanti[2]{#1\text{:}#2}
% \newcommand\infrecipe{\preccurlyeq_{\mathsf{rcp}}}
% \newcommand\infrecipestrict{\prec_{\mathsf{rcp}}}
\newcommand\FApply[3]{#2\text{:}(#1,#3)}
\newcommand\CApply[2]{#2\text{:}#1}
% \newcommand\FRestr[2]{{#1|^{\mathsf{hyp}(#2)}}}
\newcommand\Fhyp{\mathsf{hyp}}
\newcommand\CRestr[2]{{#1}_{|\termsetsnd_{#2}}}
\newcommand\receq{\simeq_{\mathsf{r}}}
\newcommand\RewF[3]{\mathsf{RewF}(#1,#2,#3)}
\newcommand\Skel[2]{\mathsf{Skel}(#1,#2)}

\newcommand\measure[2]{\mu_{gen}(#1,#2)}
% \newcommand\measureNC{\mathcal{M}}
% \newcommand\pt{\mathit{PT}}
% \newcommand\measureNbRule{\mathcal{M}_{rules}}
% \newcommand\CompatibleSubs{\mathsf{CompSub}}
% \newcommand\setRew{\mathsf{set}_{\mathsf{Rew}}}
% \newcommand\setEq{\mathsf{set}_{\mathsf{Eq}}}
% \newcommand\setSDF{\mathsf{set}_{\Solved}}

\newcommand\measureNC{\mathit{unused}^1}
\newcommand\terms[1][]{T^{#1}}
% \newcommand\recipes{\mathit{used}^2}
\newcommand\compon[1][]{\mathit{M}_{#1}}
\newcommand\setSDF{\mathsf{set}_{\Solved}}
\newcommand\setRew{\mathsf{set}_{\textsc{Rew}}}
\newcommand\setEq{\mathsf{set}_{\textsc{Eq}}}
\newcommand\defcomp[2]{%
	\[\tag{Meas. #1}
	\compon[#1](\Gamma) = #2\]
}
\newcommand\CompatibleSubs{\mathsf{CompatSubs}}

% invariants
\newcommand\predlab{\mathsf{Inv}}
\newcommand\PredAll{\predlab_{\mathit{all}}}
\newcommand\PredWellFormed{\predlab_{\mathit{wf}}}
\newcommand\PredCorrectFormula{\predlab_{\mathit{sound}}}
\newcommand\PredCompleteFormula{\predlab_{\mathit{comp}}}
\newcommand\PredConseq{\predlab_{\mathit{satur}}}
% \newcommand\PredVector{\predlab_{\mathit{split}}}
\newcommand\PredSymb{\predlab_{\mathit{sol}}}
\newcommand\PredStruct{\predlab_{\mathit{str}}}

\newcommand\simplifstep{\overset {\mathsf{simpl}} \simpl}
\newcommand\normstep{\overset {\mathsf{norm}} \simpl}
\newcommand\vectstep{\overset {\mathsf{vect}} \simpl}
\newcommand\satstep{\xrightarrow{\ref{rule:satisfiable}}}
\newcommand\eqstep{\xrightarrow{\ref{rule:equality}}}
\newcommand\rewstep{\xrightarrow{\ref{rule:rewrite}}}
% \newcommand\chanstep{\xrightarrow{\ref{rule:channel}}}


% algorithm keywords
\SetKwProg{Def}{\textbf{Procedure}}{ =}{\textbf{End}}
\SetKwProg{If}{\textbf{if}}{\ \textbf{then}}{}
\SetKwProg{Else}{\textbf{else}}{}{}
\SetKwProg{ElseIf}{\textbf{else if}}{\ \textbf{then}}{}
\SetKwProg{For}{\textbf{for}}{\ \textbf{do}}{\textbf{done}}
\SetKwProg{While}{\textbf{while}}{\ \textbf{do}}{\textbf{done}}
\newcommand\returnkw{\mathsf{return}}
\newcommand\algocomment[1]{{\color{gray}\textsf{/\!/\ #1}}}


% misc
\newcommand\displaymsg[3][]{\textcolor{#2}{\textbf{#3}. #1}}
\newcommand\todos[1][]{\displaymsg[#1]{red}{todo}}
\newcommand\checkme[1]{{\color{blue} #1}}
\newcommand\warn[1][]{\displaymsg[#1]{orange}{warning}}
\newcommand\broken[1][]{\displaymsg[#1]{purple}{broken}}
\newcommand{\caseitem}[1]{\begin{itemize}
  \item[\(\triangleright\)] #1 
\end{itemize}}

\definecolor{greenpigment}{rgb}{0.0,0.65,0.31}
\definecolor{cadiumred}{rgb}{0.89,0.0,0.13}
\definecolor{cadiumorange}{rgb}{0.93,0.53,0.18}
\definecolor{camouflagegreen}{rgb}{0.47,0.53,0.42}
\definecolor{ceruleanblue}{rgb}{0.16, 0.32, 0.75}
\newcommand\warningsign{{\color{ceruleanblue} \raisebox{-1pt}{\scalebox{1.2}{\Lightning}}}}
\newcommand{\outoftime}{\raisebox{-2pt}{\scalebox{0.8}{\StopWatchEnd}}}
\newcommand{\outofmemory}{\raisebox{-1pt}{\scalebox{0.35}{%
	\tikz[baseline=-2ex]{
	\node[color=cadiumred,fill = white, shape=regular polygon, minimum size = 1cm, regular polygon sides=8, inner sep=0pt, draw, thick] at (0,0) {};
	\node[color=cadiumred,shape=regular polygon, text = cadiumred, regular polygon sides=8, inner sep=0pt, draw, thick] at (0,0) {\small\textbf{OM}};
	}}}}

\newcommand{\attacksimple}{\warningsign}
\newcommand{\unable}{{\color{cadiumred}\ding{55}}}
\newcommand{\verified}{{\color{greenpigment}\ding{51}}}


\newenvironment{bigproof}[1][\proofname]
  {\begin{proof}[#1]~

  \noindent}
  {\end{proof}}

\makeatletter
\providecommand{\leftsquigarrow}{%
\mathrel{\mathpalette\reflect@squig\relax}%
}
\newcommand{\reflect@squig}[2]{%
\reflectbox{$\m@th#1\rightsquigarrow$}%
}
\makeatother

\newcommand\smallrightarrow{\scalebox{0.8}{\(\Rightarrow\)}}
\newcommand\smallleftarrow{\scalebox{0.8}{\(\Leftarrow\)}}
\newcommand\step[2][]{{\noindent{#2} {#1}:\xspace}}
\newcommand\case[2][]{\step[#1]{\bf case #2}}
\newcommand{\sbt}{\,\begin{picture}(-1,1)(-1,-2.5)\circle*{2.5}\end{picture}\ \ }
