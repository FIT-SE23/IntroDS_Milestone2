\section{Proofs of complexity lower bounds}
\subsection{Advanced winning strategies}
\label{app:strategies}

  Before starting the proofs, we present some characterizations of observational (in)equivalence in order to make the incoming proofs easier to handle.
  % It somehow formalizes the intuition that observational equivalence is a bisimulation game (see Section \ref{sec:lower bounds pure obs}).

  \begin{remark}
    The results of this section (\ref{app:strategies}) also apply to the extended semantics of Section \ref{sec:tools encoding}.
  \end{remark}


  \paragraph{For the defender}
  \label{app:strategies def}

  The transitions of the semantics which are deterministic and silent are not essential to equivalence proofs as they do not interfere substantially with them. We introduce below a refined proof technique to rule them out.

  \begin{definition}[simplification]
    \label{def:simplification}
    A multiset of closed plain processes \(\S\) is silent in an extended process \(\process \P \Phi\) when for all transitions \(\process {\P \cup \S} \Phi \cstep \alpha \process \Q {\Phi'}\),
    it holds that \(\Q = \P' \cup \S\) with \(\process \P \Phi \cstep \alpha \process {\P'} {\Phi'}\) and \(\S\) silent in \(\process {\P'} {\Phi'}\). Then we define \(\silentstep\) (simplification relation) the relation on extended processes defined by the following inference rules:
    \begin{mathpar}
      \inferrule
        {\mbox{\(\S\) silent in \(\process \P \Phi\)}}
        {\process {\P \cup \S} \Phi \silentstep \process \P \Phi}[(S-sil)]\label{rule:s-sil}

      \inferrule
        {c \in \Nall \\ \msg t \\ c \notin \names{\P, \Phi}}
        {\process {\P \cup \multi {\OutP c t.P, \InP c x.Q}} \Phi \silentstep \process {\P \cup \multi {P, Q\{x \mapsto t\}}} \Phi}[(S-comm)]\label{rule:s-comm2}

      \inferrule
        {A \cstep \tau B ~ \mbox{by rules \textsc{Null}, \textsc{Par}, \textsc{Then}, \textsc{Else}}}
        {A \silentstep B}[(S-npte)]\label{rule:s-npte}
    \end{mathpar}
  \end{definition}

  In other words, we write \(A \silentstep B\) when \(B\) is obtained from \(A\) by removing some silent process or applying a deterministic (in the sense of the confluence lemma below) instance of the transition relation \(\cstep \tau\). We call \(\silentpistep\) the restriction of \(\silentstep\) to the rule \nameref{rule:s-npte}. Their reflexive transitive closures are denoted \(\silent\) and \(\silentpi\) respectively as usual.

  \begin{lemma}
    \label{lem:silent strong confluence}
    If \(A \silentstep B\) (by some rule \(\rho_{\mathsf{sil}}\) of the definition of \(\silentstep\)) and \(A \cstep \alpha C\) (by some rule \(\rho_{\mathsf c}\) of the semantics), then either \(B = C\) and \(\alpha = \silent\), or there exists \(D\) such that \(C \silentstep D\) (by rule \(\rho_{\mathsf{sil}}\)) and \(B \cstep \alpha D\) (by rule \(\rho_{\mathsf c}\)).
  \end{lemma}

  \begin{proof}
    We make a case analysis on the rule used to obtain the reduction \(A \silentstep B\):

    \begin{itemize}
      \item \case[: by rule \nameref{rule:s-sil}] 1

      Then we write \(A = \process {\P \cup \S} \Phi\), \(B = \process \P \Phi\).
      By definition of silent processes, the reduction \(A \cstep \alpha C\) hence gives \(C = \process {\P' \cup \S} {\Phi'}\) where \(\process \P \Phi \cstep \alpha \process {\P'} {\Phi'} = D\) and \(\S\) silent in \(D\). In particular \(D\) gives the expected conclusion.

      \item \case[: by rule \nameref{rule:s-comm2} or \nameref{rule:s-npte}] 2

      Then either \(B = C\) and the conclusion is immediate, or \(B \neq C\) and a quick analysis of the rules of the semantics gives \(\P,Q_B,Q_B',Q_C,Q_C',\Phi,\Phi'\) such that:
      \begin{align*}
        A & = \process {\multi {Q_B,Q_C} \cup \P} \Phi &
        B & = \process {\multi {Q_B',Q_C} \cup \P} \Phi &
        C & = \process {\multi {Q_B,Q_C'} \cup \P} {\Phi'} \\
        & & \mathrm{}~& \process {\multi {Q_B}} \Phi \silentstep \process {\multi {Q_B'}} \Phi &
        \mathrm{}~& \process {\multi {Q_C}} \Phi \cstep \alpha \process {\multi {Q_C'}} {\Phi'}
      \end{align*}
      and we conclude by choosing \(D = \process {\multi {Q_B',Q_C'} \cup \P} {\Phi'}\). \qedhere
    \end{itemize}
  \end{proof}

  \begin{corollary}
    \label{cor:silent confluence}
    If \(A \silent B\) and \(A \cstep \alpha C\) then either \(B \silent C\) and \(\alpha = \silent\), or there exists \(D\) such that \(C \silent D\) and \(B \cstep \alpha D\).
  \end{corollary}

  \begin{proof}
    By a straightforward induction on the number of steps of the reduction \(A \silent B\).
  \end{proof}

  \begin{corollary}
    \label{cor:npte convergence}
    \(\silentpistep\) is convergent.
  \end{corollary}

  \begin{proof}
    The termination of \(\silentpistep\) follows from the termination of the whole calculus. As for the local confluence (which sufficies by Newmann's lemma), we observe that by Lemma \ref{lem:silent strong confluence}, if \(A \silentpistep B\) and \(A \silentpistep C\) then either \(B = C\), or there is \(D\) such that \(B \silentpistep D\) and \(C \silentpistep D\): in particular, \(B \silentpi E\) and \(C \silentpi E\) for some \(E \in \{C,D\}\).
  \end{proof}

  In particular, all extended processes \(A\) have a unique normal form w.r.t. \(\silentpistep\) which will be written \(\procnorm A\). This notation is lifted to multiset of processes, writing \(\procnorm {\P}\) (which is consistent since \(\silentpistep\) does not modify the frame). With all of this, we eventually gathered all the ingredients to introduce our characterization of bisimilarity:

  \begin{definition}[bisimulation up to \(\silentstep\)]
    A symmetric relation \(\bisim\) on extended processes is then said to be bisimulation up to \(\silentstep\), or a bisimulation up to simplification, when:
    \begin{itemize}
      \item \(\bisim~\subseteq~\StatEq\);
      \item for all extended processes \(A,B\) such that \(A\bisim B\), and for all transitions \(A\cstep\alpha A'\), there exists \(B\Cstep\alpha B'\) such that \(A' \silent \bisim \silentrev B'\).
    \end{itemize}
  \end{definition}

  \begin{proposition}
    \label{prop:bisim up to}
    For all extended processes \(A\) and \(B\), \(A\LabBis B\) \textit{iff} there exists a bisimulation up to simplification \(\bisim\) such that \(A \silent \bisim \silentrev B\).
  \end{proposition}

  \begin{proof}
    The forward implication follows from the fact that \(\LabBis\) is a bisimulation up to simplification (by reflexivity of \(\silent\)). For the converse, let us consider \(\bisim\) a bisimulation up to \(\silentstep\) and prove that it is contained in \(\LabBis\). In order to do that, it sufficies to show that:
    \begin{itemize}
      \item \(\silent \bisim \silentrev\) is symmetric;
      \item \((\silent \bisim \silentrev)~ \subseteq~ \StatEq\);
      \item for all extended processes \(A,B\) such that \(A \silent \bisim \silentrev B\), if \(A\cstep\alpha A'\) then there exists \(B\Cstep\alpha B'\) such that \(A' \silent \bisim \silentrev B'\).
    \end{itemize}
    These three properties indeed justify that \((\silent \bisim \silentrev)~ \subseteq~ \LabBis\) by definition, hence the expected conclusion as \(\bisim \subseteq \silent \bisim \silentrev\) by reflexivity of \(\silent\). Yet it appears that the first two points directly follows from the properties of \(\bisim\) and the reflexivity of \(\silent\), and we thus only need to prove the third point. Let us therefore consider the following hypotheses and notations:
    \begin{align*}
      A \silent C & ~\bisim~ D \silentrev B &
      A & \cstep \alpha A'
    \end{align*}
    and let us exhibit \(B'\) such that \(B \Cstep \alpha B'\) and \(A' \silent \bisim \silentrev B'\). Let us consider the two cases induced by the application of Corollary \ref{cor:silent confluence}:

    \begin{itemize}
      \item \case 1 \(A' \silent C\) and \(\alpha = \silent\)

      Then we can choose \(B' = B\).

      \item \case 2 there exists \(C'\) such that \(A' \silent C'\) and \(C \cstep \alpha C'\)

      Consequently, since \(\bisim\) is a bisimulation up to simplification, there is \(D'\) such that \(D \Cstep \alpha D'\) and \(C' \silent \bisim \silentrev D'\). Then we remark that for all extended processes \(B_1, B_2, B_3\):
      \begin{itemize}
        \item a transition \(B_1 \silentstep B_2\) with rules \nameref{rule:s-npte} or \nameref{rule:s-comm2} implies \(B_1 \cstep \tau B_2\);
        \item if \(B_1 \silentstep B_2\) with rule \nameref{rule:s-sil} and \(B_2 \cstep \beta B_3\), then \(B_1 \cstep \beta \silentstep B_3\).
      \end{itemize}
      In particular since \(B \silent D \Cstep \alpha D'\), we have \(B \Cstep \alpha D'' \silent D'\) for some \(D''\). Hence the conclusion by choosing \(B' = D''\). \qedhere
    \end{itemize}
  \end{proof}


  \paragraph{For the attacker}
  \label{app:strategies atk}
  When taking the negation of labelled bisimilarity, we essentially obtain a set of rules for a game whose states are pairs of processes \((A,B)\): an attacker selects a transition and a defender answers by selecting a equivalently-labelled sequence of transitions in the other process.

  \begin{definition}[labelled attack]
    \label{def:labelled attack}
    A relation \(\disim\) on extended processes is called a labelled attack when for all \(A,B\) such that \(A\disim B\), it holds that:
    \begin{enumerate}
      \item either: \(A\not\StatEq B\)
      \item or: \(\exists A\cstep\alpha\Cstep\tr A',~\forall B\Cstep{\alpha.\tr} B',~A'\disim B'\)
      \item or: \(\exists B\cstep\alpha\Cstep\tr B',~\forall A\Cstep{\alpha.\tr} A',~A'\disim B'\)
    \end{enumerate}
  \end{definition}

  Note that labelled attacks are not the direct translation of the above intuition since they allow the attacker to choose several transitions in a row; this intuitively entails no loss of generality since it is equivalent to the attacker selecting some transitions non-adaptatively (i.e. independently of the answer of the defender). Here is the formal statement of correctness:

  \begin{proposition}
    \label{prop:eqobs labelled disim}
    For all extended processes \(A\) and \(B\), \(A\not\LabBis B\) \textit{iff} there exists a labelled attack \(\disim\) such that \(A\disim B\).
  \end{proposition}

  \begin{proof}
    The forward implication is immediate since \(\not\LabBis\) is a labelled attack (we can even choose \(\tr=\epsilon\) everytime). Let then \(\disim\) be a labelled attack such that \(A\disim B\) and let us prove that \(\disim\subseteq~\not\LabBis\). More precisely, we prove that \(\disim \subseteq ~ \disim' \subseteq ~ \not\LabBis\) for some relation \(\disim'\). We will construct \(\disim'\) in such a way that for all \(A,B\) extended processes, \(A\disim'B\) entails:
    \begin{itemize}
      \item[\((i)\)] either: \(A\not\StatEq B\);
      \item[\((ii)\)] or: \(\exists A\cstep\alpha A',~\forall B\Cstep\alpha B',~A'\disim B'\);
      \item[\((iii)\)] or: \(\exists B\cstep\alpha B',~\forall A\Cstep\alpha A',~A'\disim B'\)
    \end{itemize}
    The inclusion \(\disim'\subseteq~\not\LabBis\) is indeed clear if this property is verified, hence the expected conclusion provided such a relation \(\disim'\). We concretely define it as the smallest relation on extended processes saturated by the following inference rules:
    \begin{mathpar}
      \inferrule
      {A\disim B}
      {A\disim' B}[(Axiom)]\label{rule:axiom}

      \inferrule
      {A\disim'B\\A\cstep\alpha A'\cstep{\alpha'}\Cstep\tr A''\\\forall B\Cstep{\alpha.\alpha'.\tr}B'',A''\disim'B''\\B\Cstep\alpha B'}
      {A'\disim'B'}[(Dec-L)]\label{rule:split-l}

      \inferrule
      {A\disim'B\\B\cstep\alpha B'\cstep{\alpha'}\Cstep\tr B''\\\forall A\Cstep{\alpha.\alpha'.\tr}A'',A''\disim'B''\\A\Cstep\alpha A'}
      {A'\disim'B'}[(Dec-R)]\label{rule:split-r}
    \end{mathpar}
    In particular, note that \(\disim\subseteq\disim'\) thanks to the rule \nameref{rule:axiom}.
    As for the two other rules \nameref{rule:split-l} and \nameref{rule:split-r}, they intuitively decompose sequences \(\cstep\alpha\Cstep\tr\) into atomic transitions in order to switch from points {\it 2.} or {\it 3.} of Definition \ref{def:labelled attack} to points \((ii)\) or \((iii)\).

    Let then \(A\) and \(B\) be two extended processes such that \(A\disim'B\). We consider a proof-tree of \(A\disim'B\) in the inference system above and perform a case analysis on the rule at its root:

    \begin{itemize}

      \item \case[\nameref{rule:axiom}] 1 \(A\disim B\).

      As \(\disim\) is a labelled attack, we apply the case analysis of Definition \ref{def:labelled attack}:

      \begin{itemize}
        \item \case {1.a} \(A\not\StatEq B\).

        Then \((i)\) is satisfied.

        \item \case {1.b} there exists \(A\cstep{\alpha}A'\Cstep\tr A''\) such that \(A''\disim B''\) for all \(B\Cstep{\alpha.\tr}B''\).

        In particular, keeping in mind that \(\disim\subseteq\disim'\) due to the rule \nameref{rule:axiom}, we have \(A''\disim'B''\) for all \(B\Cstep{\alpha.\tr}B''\). Let us then show that the transition \(A\cstep{\alpha}A'\) satisfies \((ii)\).
        We therefore have to show that \(A'\disim'B'\) for all \(B\Cstep\alpha B'\). If \(A'=A''\) then the result follows from the hypothesis.
        Otherwise let us write \(A\cstep{\alpha}A'\cstep{\alpha'}\Cstep{\tr'}A''\) where \(\alpha'.{\tr'}=\tr\) and the rule \nameref{rule:split-l} justifies that \(A'\disim'B'\) for all \(B\Cstep{\alpha}B'\).

        \item \case {1.c} there exists \(B\cstep{\alpha}B'\Cstep\tr B''\) such that \(B''\disim A''\) for all \(A\Cstep{\alpha.\tr}A''\).

        Analogous, targeting \((iii)\) instead of \((ii)\) and replacing \nameref{rule:split-l} by \nameref{rule:split-r}.
      \end{itemize}

      \item \case[\nameref{rule:split-l}] 2 there are \(A_0\), \(A_1\), \(A_2\), \(B_0\), \(B_2\), \(\alpha\), \(\alpha'\), \(\tr\), such that \(A_0\disim'B_0\), \(B_0\Cstep\alpha B\),
      \(A_0\cstep\alpha A\cstep{\alpha'}A_1\Cstep\tr A_2\), and \(\forall~B_0\Cstep{\alpha.\alpha'.\tr}B_2,A_2\disim'B_2\).

      Let us show that the transition \(A\cstep{\alpha'}A_1\) satisfies \((ii)\). We therefore have to show that \(A_1\disim'B_1\) for all \(B\Cstep{\alpha'} B_1\). If \(A_1=A_2\) then the result follows from the hypothesis.
      Otherwise we write \(A\cstep{\alpha'}A_1\cstep{\alpha''}\Cstep{\tr'}A_2\) where \(\alpha''.\tr'=\tr\) and the rule \nameref{rule:split-l} justifies that \(A_1\disim'B_1\) for all \(B\Cstep\alpha B_1\).

      \item \case[\nameref{rule:split-r}] 3 Analogous to case 2.\qedhere
    \end{itemize}
  \end{proof}

\subsection{Correctness of the encodings (Section \ref{sec:tools encoding})}
\label{app:tools encoding}

  Now we prove that the translation \(\sem\cdot\) of the extended semantics is correct:

  \begin{lemma}
    \label{lem:encodings correct}
    Let \(\TraceEq^+\) and \(\LabBis^+\) be the notions of trace equivalence and labelled bisimilarity over the extended calculus (the flag \(^+\) being omitted outside of this lemma). For all extended processes \(A = \process \P \Phi\), the translation \(\sem A = \process {\sem \P} \Phi = \process{ \multi {\sem P \mid P \in \P} }\Phi\) can be computed in polynomial time, \(A\TraceEq^+\sem A\) and \(A\LabBis^+\sem A\).
  \end{lemma}

  But first of all, a (trivial) observation about the free variables of a translated process:

  \begin{lemma}
    For all plain processes \(P\) and all first-order substitution \(\sigma\), \(\sem{P\sigma}=\sem P\sigma\).
  \end{lemma}

  % \begin{proof}
  %   By a straightforward induction on the structure of plain processes.
  % \end{proof}

  We will use this lemma implicitly in the remaining of this section. Besides, as we have the inclusion of relations \(\LabBis~\subseteq~\TraceEq\), we only need to prove the observational-equivalence statement of Lemma \ref{lem:encodings correct}. We recall that we use notations \(\procnorm A\) and \(\procnorm \P\) to refer to normal forms w.r.t. \(\silentpistep\) (see Corollary \ref{cor:npte convergence}).

  \begin{proposition}
    We consider \(\bisim\) the symmetric closure of:
    \[\{ (C, \procnorm {\sem C}) ~|~ \mbox{\(C\) extended process such that \(C = \procnorm C\)} \}\]
    \(\bisim\) is a bisimulation up to simplification.
  \end{proposition}

  \begin{proof}
    \(\bisim\) is symmetric by definition and is trivially included in \(\StatEq\). Let then \((A,B) \in \bisim\) and \(A \cstep \alpha A'\) and let us exhibit \(B'\) such that \(B \Cstep \alpha B'\) and \(A' \bisim B'\). We perform a case analysis on the rule triggerring the transition \(A \cstep \alpha A'\):

    \begin{itemize}
      \item \case[(rules \textsc{Null}, \textsc{Par}, \textsc{Then}, \textsc{Else})] 1

      This case cannot arise as \(A\) is in normal form w.r.t. \(\silentpistep\) by definition of \(\bisim\).

      \item \case[(rule \textsc{In})] 2 \(\alpha = \InP \xi \zeta\) for some \(\xi, \zeta \in \termset(\sig, \sig_0 \cup \dom \Phi)\) and:
      \begin{align*}
        A & = \process {\P \cup \multi {\InP u x.P}} \Phi  & & \mbox{with \(\msg u\), \(\msg {\xi \Phi}\) and \(\xi \Phi \norm = u \norm\)}\\
        A' & = \process {\P \cup \multi {P\{ x \mapsto \zeta \Phi \norm \}}} \Phi & & \mbox{with \(\msg {\zeta \Phi}\)}
      \end{align*}
      Then, by a case analysis on the hypothesis \(A \bisim B\):
      \begin{itemize}
        \item \case {2.a} \(B = \procnorm {\sem A}\)

        Then we can write:
        \begin{align*}
          B & = \process {\procnorm {\sem \P} \cup \multi {\InP u x.\sem P}} \Phi
        \end{align*}
        and we conclude by remarking that \(B \cstep {\InP \xi \zeta} B' = \process {\procnorm {\sem \P} \cup \multi {\sem P\{ x \mapsto \zeta \Phi \norm \}}} \Phi\) and:
        \[A' \silent \procnorm {A'} ~\bisim~ \procnorm {\sem {\procnorm {A'}}}
        = \procnorm {\sem {A'}} = \process {\procnorm {\sem \P} \cup \procnorm {\multi {\sem P\{ x \mapsto \zeta \Phi \norm \}}}} \Phi \silentrev B'\]

        \item \case {2.b} \(A = \procnorm {\sem B}\) (and \(B = \procnorm B\))

        Note that \(u = \xi \Phi \norm\) cannot be one of the names introduced by the translation \(\sem \cdot\): these names can indeed not appear in \(\Phi\) since they are chosen private and fresh and since the semantics cannot introduce new private names. In particular we can write:
        \begin{align*}
          B & = \process {\Q \cup \multi {\InP u x.Q}} \Phi  & & \mbox{with \(\sem Q = P\) and \(\procnorm {\sem \Q} = \P\)}
        \end{align*}
        and we conclude by writing \(B \cstep {\InP \xi \zeta} B' = \process {\Q \cup \multi {Q\{ x \mapsto \zeta \Phi \norm \}}} \Phi\) and:
        \[ A' \silent \process {\procnorm {\sem \Q} \cup \procnorm {\multi {\sem Q \{ x \mapsto \zeta \Phi \norm \}}}} \Phi = \procnorm {\sem {B'}} = \procnorm{\sem {\procnorm {B'}}} ~\bisim~ \procnorm {B'} \silentrev B'\]
      \end{itemize}

      \item \case[(rule \textsc{Out})] 3 \(\alpha = \OutP \xi {\ax_n}\) for some \(\xi, \in \termset(\sig, \sig_0 \cup \dom \Phi)\), \(\ax_n \in \AX\) and:
      \begin{align*}
        A & = \process {\P \cup \multi {\OutP u t.P}} \Phi  & & \mbox{with \(\msg u\), \(\msg t\), \(\msg {\xi \Phi}\) and \(\xi \Phi \norm = u \norm\)}\\
        A' & = \process {\P \cup \multi P} {\Phi'} & & \mbox{where \(\Phi' = \Phi \cup \{ \ax_n \mapsto t \norm\}\) and \(n = |\Phi| + 1\)}
      \end{align*}
      Then, by a case analysis on the hypothesis \(A \bisim B\):
      \begin{itemize}
        \item \case {3.a} \(B = \procnorm {\sem A}\)

        Then we can write:
        \begin{align*}
          B & = \process {\procnorm {\sem \P} \cup \multi {\OutP u t.\sem P}} \Phi
        \end{align*}
        and we conclude by remarking that \(B \cstep {\OutP \xi {\ax_n}} B' = \process {\procnorm {\sem \P} \cup \multi {\sem P}} \Phi\) and:
        \[A' \silent \procnorm {A'} ~\bisim~ \procnorm {\sem {\procnorm {A'}}}  = \procnorm {\sem {A'}} = \process {\procnorm {\sem \P} \cup \procnorm {\multi {\sem P}}} \Phi \silentrev B'\]

        \item \case {3.b} \(A = \procnorm {\sem B}\) (and \(B = \procnorm B\))

        For the same reason as in case 2.b, we can write:
        \begin{align*}
          B & = \process {\Q \cup \multi {\OutP u t.Q}} \Phi  & & \mbox{with \(\sem Q = P\) and \(\procnorm {\sem \Q} = \P\)}
        \end{align*}
        and we conclude by writing \(B \cstep {\OutP \xi {\ax_n}} B' = \process {\Q \cup \multi Q} \Phi\) and:
        \[ A' \silent \process {\procnorm {\sem \Q} \cup \procnorm {\multi {\sem Q}}} \Phi = \procnorm {\sem {B'}} = \procnorm{\sem {\procnorm {B'}}} ~\bisim~ \procnorm {B'} \silentrev B'\]
      \end{itemize}

      \item \case[(rule (\textsc{Comm}))] 4 \(\alpha = \silent\) and:
      \begin{align*}
        A & = \process {\P \cup \multi {\OutP u t.P, \InP v x.Q}} \Phi & & \mbox{with \(\msg u\), \(\msg v\), \(\msg t\) and \(u \norm = v \norm\)}\\
        A' & = \process {\P \cup \multi {P,Q\{ x \mapsto t \}}} \Phi
      \end{align*}
      Then, by a case analysis on the hypothesis \(A \bisim B\):
      \begin{itemize}
        \item \case {4.a} \(B = \procnorm {\sem A}\)

        Then we can write:
        \begin{align*}
          B & = \process {\procnorm {\sem \P} \cup \multi {\OutP u t.\sem P, \InP v x.\sem Q}} \Phi
        \end{align*}
        and we conclude by remarking that \(B \cstep \tau B' = \process {\procnorm {\sem \P} \cup \multi {\sem P, \sem Q\{ x \mapsto t\}}} \Phi\) and:
        \[A' \silent \procnorm {A'} ~\bisim~ \procnorm {\sem {\procnorm {A'}}}  = \procnorm {\sem {A'}} =
        \process {\procnorm {\sem \P} \cup \multi {\procnorm {\sem P}, \procnorm {\sem Q\{ x \mapsto t\}}}} \Phi \silentrev B'\]

        \item \case {4.b} \(A = \procnorm {\sem B}\) (and \(B = \procnorm B\)) and a term \(w\) such that \(w \norm = u \norm\) appears in \(B\) (syntactically)

        In particular \(\norm u\) is not a fresh name introduced by the translation \(\sem \cdot\) and we can therefore write:
        \begin{align*}
          B & = \process {\P' \cup \multi {\OutP u t.P', \InP v x.Q'}} \Phi & & \mbox{with \(\procnorm {\sem {\P'}} = \P\), \(\sem {P'} = P\) and \(\sem {Q'} = Q\)}
        \end{align*}
        and we conclude by writing \(B \cstep \tau B' = \process {\P' \cup \multi {P', Q'\{ x \mapsto t\}}} \Phi\) and:
        \[A' \silent \process {\procnorm {\sem {\P'}} \cup \multi {\procnorm {\sem {P'}}, \procnorm {\sem {Q'}\{ x \mapsto t\}}}} \Phi =
        \procnorm {\sem {B'}} = \procnorm{\sem {\procnorm {B'}}} ~\bisim~ \procnorm {B'} \silentrev B'\]

        \item \case {4.c} \(A = \procnorm {\sem B}\) (and \(B = \procnorm B\)) and there exists no term \(w\) appearing in \(B\) such that \(w \norm = u \norm\) (syntactically)

        Then \(u\) is a fresh name introduced by \(\sem \cdot\). We consider the two disjoint cases where it was introduced for the translation of a sum or a circuit:

        \begin{itemize}
          \item If \(u \in \Nall\) is a fresh name generated in order to translate a sum of \(B\), or rephrased more formally:
          \begin{align*}
            B & = \process {\Q \cup \multi {P' + Q'}} \Phi\\
            A & = \process {\procnorm {\sem \Q} \cup \multi {\OutP u u, \InP u x.\sem {P'}, \InP u x.\sem {Q'}}} \Phi & & \mbox{where \(x \in \X[1]\) but \(x \notin \vars {P',Q'}\)}\\
            A' & = \process {\procnorm {\sem \Q} \cup \multi {\sem R, \InP u x.\sem S}} \Phi & & \mbox{where \(R,S \in \multi {P', Q'}\), \(R \neq S\)}
          \end{align*}
          We let \(B' = \process {\Q \cup \multi R} \Phi\) and remark that \(B \cstep \tau B'\) by the rule \ref{rule:choice} (if \(R = P'\) and \(S = Q'\), or \(R = Q'\) and \(S = P'\)).
          Besides, let us observe that the name \(u\) does not appear in \(\procnorm {\sem \Q}\), \(\sem R\) nor \(\Phi\) by construction of \(\sem \cdot\) and that \(\InP u x.\sem S\) is therefore easily seen to be silent in \(A'' = \process {\procnorm {\sem \Q} \cup \multi {\sem R}} \Phi\).
          In particular it entails that \(A' \silentstep A''\) by the rule \nameref{rule:s-sil} which gives the conclusion:
          \[A' \silentstep A'' \silent \process {\procnorm {\sem \Q} \cup \procnorm {\multi {\sem R}}} \Phi = \procnorm {\sem {B'}} = \procnorm {\sem {\procnorm {B'}}} ~\bisim~ \procnorm {B'} \silentrev B'\]

          \item \(u \in \Nall\) is a fresh name generated in order to translate a \(\guessBinary x\): this case can be handle analogously to the previous one.

          \item If \(u \in \Nall\) is a fresh name generated in order to translate a circuit of \(B\), or formally:
          \begin{align*}
            B & = \process {\Q \cup \multi {\evalFormula {\vec x} {\Gamma(\vec b)}. P'}} \Phi\\
            A & = \process {\procnorm {\sem \Q} \cup \multi {\sem {\evalFormula {\vec x} {\Gamma(\vec b)}.P'}}} \Phi
          \end{align*}
          We call \((c_i)_i\) the private fresh names introduced by the translation \(\sem {\evalFormula {\vec x} {\Gamma(\vec b)}.P'}\), stressing that none of them appears in \(\procnorm {\sem \Q}\), \(\sem {P'}\) nor \(\Phi\). Here \(u \in \{c_i\}_i\) and we can therefore write:
          \begin{align*}
            A' & = \process {\procnorm {\sem \Q} \cup \multi {Q'}} \Phi & &
            & \mbox{where \(\process {\multi {\sem {\evalFormula {\vec x} {\Gamma(\vec b)}.P'}}} \Phi \cstep \alpha \process {\multi {Q'}} \Phi\)}
          \end{align*}
          If the sequence \(\vec b\) contains a term which is not a message or does not reduce to a boolean, then one easily obtain that \(\process {\multi {Q'}} \Phi \silentpi \process \S \Phi\) where \(\S\) is silent in \(\process {\procnorm {\sem \Q}} \Phi\) (for that we assume, w.l.o.g. that each input of \(\Gamma\) goes through at least one gate).
          Hence since \(\multi {\evalFormula {\vec x} {\Gamma(\vec b)}. P'}\) is also silent in \(\process \Q \Phi\), we conclude with \(B' = \process \Q \Phi\).

          Otherwise assume that \(\msg {\vec b}\) and \(\vec b \norm \subseteq \B\). Then one easily obtain by induction on the number of gates of \(\Gamma\) that \(\process {\multi {Q'}} \Phi \silentpi \process {\multi {\sem {P'}\{\vec x \mapsto \Gamma(\vec b)\}}} \Phi\) and we conclude by choosing
          \(B' = \process {\Q \cup \multi {P'\{\vec x \mapsto \Gamma(\vec b)\}}} \Phi\).
        \end{itemize}

        \item \case[(rules \ref{rule:choice}, \ref{rule:choose-0}, \ref{rule:choose-1} or \ref{rule:valuate})] 5

        The arguments of each of these cases are analogous to priorly-met subcases. \qedhere
      \end{itemize}
    \end{itemize}
  \end{proof}

  In particular note that \(A \silent \procnorm A ~\bisim~ \procnorm{ \sem {\procnorm A}} = \procnorm{\sem A} \silentrev \sem A\) for all extended processes \(A\), hence Lemma \ref{lem:encodings correct}.


  \subsection{Reductions in the pure calculus} \label{app:lower-pure}

    We now formalise and prove the correctness of the reductions intuited in Section~\ref{sec:lower-pure}.

    \paragraph{For trace equivalence}
    We define the processes \(P(t)\), \(A\) and \(B\) as follows.
    \begin{align*}
      P(t) & \eqdef \InP c{\vec x}.~\guessBinary{\vec{y}}.~\evalFormula{v}{\varphi(\vec x ,\vec y)}.~\OutP c t\\
      A & \eqdef P(v)+P(\1)\\
      B & \eqdef P(\0)+P(\1)
    \end{align*}

    \begin{proposition}[Reduction for trace equivalence]
      \(A \TraceEq B\) \textit{iff} \(\forall \vec{x}.\exists \vec{y}. \varphi(\vec x,\vec y) = \0\).
    \end{proposition}

    \begin{proof}
      We do the proof by double implication.
      \begin{itemize}
        \item[\(\Rightarrow\)] Suppose that \(A \not \TraceEq B\). By a quick case analysis, we obtain \(B \cstep \epsilon \process {\multi {P(0)}} \emptyset \Cstep \tr \process \emptyset {\{\ax_1 \mapsto \0\}}\)
        where \(\tr = \InP c {\vec t}. \OutP c {\ax_1}\) for some messages \(\vec t\), such that for all reduction \(A \Cstep \tr \process \C \Phi\) the frames \({\{\ax_1 \mapsto \0\}}\) and \(\Phi\) are not statically equivalent. In particular, for all \(\vec y \subseteq \B\),
        by choosing \(\Phi = \{\ax_1 \mapsto \varphi(\vec t,\vec y)\}\) reachable from \(A\), we obtain \(\varphi(\vec t, \vec y) \neq \0\), hence the result.
    
        \item[\(\Leftarrow\)] Conversely, suppose that exists exists \(\vec x \subseteq \B\) such that \(\varphi(\vec x, \vec y) = \1\) for all \(\vec y \subseteq \B\). Then the trace \(B \Cstep \epsilon \process \emptyset {\{\ax_1 \mapsto \0\}}\) cannot be matched in \(A\) and therefore \(A \not \TraceEq B\). \qedhere
      \end{itemize}
    \end{proof}

    \paragraph{For simulations}
    We recall that a graphical depiction of the processes has been provided in Section~\ref{sec:lower-pure}.
    We fix a family of private channels \((c_P)_P\subseteq\Nall\) indexed by processes \(P\) which will be used to simulate instructions \(\call P\). We use a shortcut \(\OutP d {\args t p}\) for an indexed sequence of terms \((t_i)_i\) to denote the sequence of outputs:
    \[\OutP d {\args t p}\eqdef\OutP d{t_1}\ldots\OutP d{t_p}\]
    and a similar notation for sequences of inputs. Then the {\tt Goto} feature is implemented as follows, allowing for passing and receiving program states through parallel processes:
    \begin{align*}
      \call{A_i}\eqdef~ &\OutP{c_{A_i}}{\args x i,\args y i} &
      \call{B_i}\eqdef~ &\OutP{c_{B_i}}{\args x i,\args y i} \\
      \getEnv{A_i}.P\eqdef~ &\InP{c_{A_i}}{\args x i,\args y i} &
      \getEnv{B_i}.P\eqdef~ &\InP{c_{B_i}}{\args x i,\args y i} \\
    \end{align*}


    Formally the processes \(A_i\), \(B_i\) and \(D_i\) are defined below. We stress out that \(A\) and \(B\) are closed (as required) but that \(A_i\), \(B_i\) and \(D_i\) are not in general. Fixing a public channel \(c\in\sig_0\), we write:
    \begin{align*}
      \forall i\leqslant n,~A_i\eqdef~&\InP c {x_i}.~\evalFormula{x_i}{x_i}.~D_i\\
      \forall i\leqslant n,~B_i\eqdef~&\InP c {x_i}.~\evalFormula{x_i}{x_i}.~(D_i+(\InP c {y_i}.~\evalFormula{y_i}{y_i}.~\call{B_{i+1}}))\\
      A_{n+1}\eqdef~&\evalFormula v {\varphi(\vec x,\vec y)}.~\OutP c v\\
      B_{n+1}\eqdef~&\OutP c \0\\
      D_i \eqdef~& \guessBinary{z_i}.~\InP c {y_i}.~\evalFormula{r_i}{(y_i=z_i)}.\\
      & ((\IfP~r_i=1~\ThenP~\call{A_{i+1}})\\
      & \quad\mid(\IfP~r_i=0~\ThenP~\InP c {y_i}.~\evalFormula{y_i}{y_i}.~\call{B_{i+1}}))
    \end{align*}

    As in the reduction for trace equivalence, the \(\guessBinary\alpha\) simulates non-deterministic choice among \(\B\); the construction \(\evalFormula\alpha\alpha\), which may seem useless, encodes the test \(\alpha \in \B\). Finally, we define \(A\) and \(B\) by putting the auxiliary processes in parallel and connecting the {\tt Goto}'s to the {\tt getEnv}'s: 
    \begin{align*}
      A \eqdef~& A_1\mid C & B\eqdef~&B_1\mid C & C\eqdef~&\displaystyle\prod_{i=2}^{n+1}(\getEnv{A_i}.A_i)~\mid~\prod_{i=2}^{n+1}(\getEnv{B_i}.B_i)
    \end{align*}
    \(A\) and \(B\) can be computed in time \(\mathcal O(n^2+|\varphi|)\) in a straightforward way.
    The formal proof of the reduction is detailed below.

    \begin{proposition}[Correctness of the reduction]
      The following statements are equivalent:
      \begin{enumerate}
        \item \label{it:lower-pure-bisim} \(A \LabBis B\)
        \item \label{it:lower-pure-simil} \(A \Simi B\)
        \item \label{it:lower-pure-formula} \(\forall x_1 \exists y_1 \ldots \forall x_n \exists y_n.~\varphi(x_1,\ldots, x_n,y_1,\ldots, y_n) = \0\)
      \end{enumerate}
    \end{proposition}

    \begin{proof}
      We recall that, again, our proof uses the advanced winning strategy framework presented in Section~\ref{app:strategies}.
      \begin{itemize}
        \item[\ref{it:lower-pure-bisim}\(\Rightarrow\)\ref{it:lower-pure-simil}]
        Follows from the inclusion \({\LabBis} \subset {\Simi}\).
        \item[\ref{it:lower-pure-formula}\(\Rightarrow\)\ref{it:lower-pure-bisim}]
        Suppose that \(\forall x_1\exists y_1 \ldots \forall x_n \exists y_n.~\varphi(x_1,\ldots, x_n,y_1,\ldots, y_n) = \1\). For convinience we use a notation for subprocess extraction: is \(\ell\) is a position of a process \(C\), then the subprocess of \(C\) at position \(\ell\) (which may not be closed) is denoted by \(C_{|\ell}\). Then writing in addition:
        \[
          C_i = \prod_{j = i + 1}^{n+1} (\getEnv {A_j}. A_j) \mid \prod_{j = i + 1}^{n+1} (\getEnv {B_j}.B_j)
        \]
        we define \(\bisim\) the smallest reflexive symmetric relation on closed extended processes such that:
        \begin{enumerate}[label=\emph{\arabic*.}]
          \item \({(A_i \mid C_i)}(\args x {i-1}, \args y {i - 1}) \bisim {(B_i \mid C_i)}(\args x {i-1}, \args y {i - 1})\)

          if
          \(\forall x_i \exists y_i \ldots \forall x_n \exists y_n, \varphi(\vec x, \vec y)\).

          \item \(({A_i}_{|\ell} \mid C_i)(\args x i, \args y {i - 1}) \bisim ({B_i}_{|\ell} \mid C_i)(\args x {i-1}, \args y {i - 1})\)

          if \(\ell \in \{\0,\0.\0\}\) and
          \(\exists y_i \ldots \forall x_n \exists y_n, \varphi(\vec x, \vec y)\).

          \item \(({B_i}_{|\0.\0.\1.\ell} \mid C_i)(\args x i, \args y i) \bisim ({D_i}_{|\0.\ell} \mid C_i)(\args x i, \args y i)\)

          if \(\ell \in \{\epsilon,\0\}\) and \(\forall x_{i+1} \exists y_{i+1} \ldots \forall x_n \exists y_n, \varphi(\vec x, \vec y)\).
        \end{enumerate}
        Then one can verify that \(\bisim\) is a bisimulation up to \(\silentstep\), and \(A \bisim B\) by hypothesis, hence the \(A \LabBis B\).
        % 
        \item[\ref{it:lower-pure-simil}\(\Rightarrow\)\ref{it:lower-pure-formula}]
        By contraposition, if we suppose that \(\exists x_1\forall y_1\ldots\exists x_n \forall y_n.~\varphi(x_1,\ldots, x_n,y_1,\ldots, y_n) = \1\), then one can define a labelled attack \(\disim\) (valid against simulation) such that \(B \disim A\).
        We omit the concrete construction as it is analogous to that of \(\bisim\) above; 
        all in all this gives the conclusion \(A \not \Simi B\). \qedhere
      \end{itemize}
    \end{proof}

  \subsection{Reduction in the full calculus}
  Before concretely proving the pending lemmas, let us introduce some notations and prove intermediary results about static equivalence.
  % Sticking to the notations of Section \ref{sec:lower bounds applied tr obs} (in particular we fix a private nonce \(s\in\Nall\)), we define the following frames given a protocol term \(t\):
  We fix a private nonce \(s\in\Nall\) and define the following frames given a protocol term \(t\):
  \begin{align*}
    \frameh t=~&\{\ax_1\mapsto\hfun(t,s),~\ax_2\mapsto\hfun(\1,s)\}\\
    \framen t=~&\{\ax_1\mapsto\hNode(t,s),~\ax_2\mapsto\hfun(\1,s)\}\\
    \frameb t=~&\{\ax_1\mapsto\hBool(t,s),~\ax_2\mapsto\hfun(\1,s)\}
  \end{align*}

  One shall observe that the whole deal with our reduction is about which instances of these three frames are reachable in which conditions. Hence first we prove a lemma investigating the static equivalence between some of them:

  \begin{lemma}
    \label{lem:nexp st-equiv}
    Let \(t\) be a message in normal form (\(t=t\norm\)). The following properties hold:
    \begin{itemize}
      \item[\((i)\)] \(\frameh t\StatEq\frameh\0\) \textit{iff} \(t\neq\1\)
      \item[\((ii)\)] \(\framen t\StatEq\frameh\0\) \textit{iff} \(\rootf(t)\neq\Node\)
      \item[\((iii)\)] \(\frameb t\StatEq\frameh\0\) \textit{iff} \(t\notin\B\)
    \end{itemize}
  \end{lemma}

  \begin{proof}
    We prove the three equivalences together by double implication.
    \begin{itemize}
      \item[(\(\Rightarrow\))] We prove the three properties by contraposition. We naturally proceed by exhibiting ground recipes \(\xi,\zeta\) witnessing the non-static-equivalence goal:

      \item[\sbt] \((i)\) We assume \(t=\1\) and we choose \(\xi=\ax_1\) and \(\zeta=\ax_2\): the conclusion follows from \(\xi\frameh t\norm=\hfun(\1,s)=\zeta\frameh t\norm\) and \(\xi\frameh\0\norm=\hfun(\0,s)\neq\hfun(\1,s)=\zeta\frameh\0\norm\).
      \item[\sbt] \((ii)\) We assume \(t=\Node(t_1,t_2)\) and we choose \(\xi = \TestNode (\ax_1)\): the conclusion follows from \(\msg{\xi\framen t}\) and \(\neg\msg{\xi\framen\0}\).
      \item[\sbt] \((iii)\) We assume \(t\in\{\0,\1\}\) and we choose \(\xi=\TestBool (\ax_1)\): the conclusion follows from \(\msg{\xi\frameb t}\) and \(\neg\msg{\xi\frameb\0}\).

      \item[(\(\Leftarrow\))] The key point is an observation about rewriting critical pairs (not specific to \(\R\)):
      \begin{itemize}
        \item[if:] \(u\) is a term;
        \item[if:] \(\sigma\) is a substitution such that for any \(m\in\im(\sigma)\) there exists no rule \(\ell\rightarrow r\) of \(\R\) such that \(m\) is unifiable with a subterm \(u\in\subterms\ell-\X\);
        \item[then:] for any rewriting sequence \(u\sigma\rightarrow^\star s\), it holds that \(s=u'\sigma\) for some \(u\rightarrow^\star u'\) (where \(u'\) is in normal form \textit{iff} \(s\) is in normal form. In particular \((u\sigma)\norm=(u\norm)\sigma\)).
      \end{itemize}

      One shall note that any frame \(\Phi\) investigated by the lemma (\(\frameh t\) when \(t\neq\1\),
      \(\framen t\) when \(\rootf t\neq\Node\) and \(\frameb t\) when \(t\notin\B\)) verifies the second hypothesis.
      As a consequence, if \(\xi\) is a ground recipe such that \(\axioms\xi\subseteq\dom(\Phi)\), then \(\msg{\xi\Phi}\) \textit{iff} \(\msg{\xi\frameh\0}\)
      (\textit{iff} \(\forall \zeta\in\subterms\xi,~\zeta\norm\in\termset(\sigc,\sig_0\cup\AX)\)). This settles the first item of the definition of static equivalence. As for the second item, let us fix two ground recipes \(\xi,\zeta\) such that \(\msg{\xi\Phi}\) and \(\msg{\xi\frameh\0}\).
      Let us then prove that \(\xi\Phi\norm= \zeta\Phi\norm\) \textit{iff} \(\xi\frameh\0\norm= \zeta\frameh\0\norm\) by induction on \((\xi\norm,\zeta\norm)\). Note that we will intensively (and implicitly) use the fact that \(\xi\Phi\norm=(\xi\norm)\Phi\) (same for \(\zeta\) and/or \(\frameh\0\)).

      \item[\sbt] \case 1 \(\xi\norm=f(\xi_1,\ldots,\xi_n)\) and \(\zeta\norm=f(\zeta_1,\ldots,\zeta_p)\) with \(f,g\in\sigc\).

      If \(f=g\) then the result follows from induction hypothesis and if \(f\neq g\) the conclusion is immediate (\(\xi\Phi\norm\neq\zeta\Phi\norm\) and \(\xi\frameh\0\norm\neq\zeta\frameh\0\norm\)).

      \item[\sbt] \case 2 \(\xi\norm\in\AX\) and \(\zeta\norm\in\AX\).

      If \(\xi=\zeta\) the conclusion is immediate and so is it when \(\xi\neq\zeta\) since \(\Phi(\ax_1)\neq\Phi(\ax_2)\) and \(\frameh\0(\ax_1)\neq\frameh\0(\ax_2)\).

      \item[\sbt] \case 3 \(\xi\norm\in\AX\) and \(\zeta\norm=f(\zeta_1,\ldots,\zeta_p)\) with \(f\in\sigc\).

      We argue that \(\xi\Phi\norm\neq\zeta\Phi\norm\) and \(\xi\frameh\0\norm\neq\zeta\frameh\0\norm\). Either of the two equalities being verified would indeed imply that \(s\in\{\zeta_2\Phi,\zeta_2\frameh\0\}\): this is impossible as \(\zeta_2\) is a ground recipe in normal form and \(s\in\Nall\) (one easily shows that \(\zeta_2\Phi\) and \(\zeta_2\frameh\0\) are either public names, constants, or termes of height 1 or more).

      As \(\msg{\xi\Phi}\) and \(\msg{\xi\frameh\0}\), the preliminary observation justifies that \(\xi\norm\) and \(\zeta\norm\) function symbols are all constructor. In particular no other cases than the three above need to be considered, which concludes the proof.\qedhere
    \end{itemize}
  \end{proof}

  % \vspace{5mm}
  With this lemma in mind, the proofs of Propositions \ref{prop:correctness checktree} and \ref{prop:correctness checksat} become quite straightforward:

  \propCorrectnessChecktree*

  \begin{proof}
    Let \(x\) be a message which is not a complete binary tree of height \(n\) whose leaves are booleans.

    \begin{itemize}[leftmargin=*]
      \item[] \case 1 there exists a position \(\vec\pi\in\B^\star\) such that \(|\vec \pi|=i\in\eint 0 {n-1}\) and \(\rootf{\recpos x{\vec\pi}}\neq\Node\).

      The result follows from Lemma \ref{lem:nexp st-equiv} after writing the following sequence of transitions:
      \begin{align*}
        \CheckTree x & \Cstep\epsilon \guessBinary{p_1,\ldots,p_i}.~\OutP c {\hNode(\recpos x{p_1\cdots p_i},s)}.~\OutP c {\hfun(\1,s)}\\
        & \Cstep\epsilon \OutP c {\hNode(\recpos x{\vec \pi},s)}.~\OutP c {\hfun(\1,s)}
      \end{align*}

      \item[] \case 2 there exists a position \(\vec\pi\in\B^n\) such that \(\recpos x{\vec\pi}\notin\B\).

      The result follows from Lemma \ref{lem:nexp st-equiv} after writing the following sequence of transitions:
      \begin{align*}
        \CheckTree x & \Cstep\epsilon \guessBinary{p_1,\ldots,p_n}.~\OutP c {\hNode(\recpos x{p_1\cdots p_n},s)}.~\OutP c {\hfun(\1,s)}\\
        & \Cstep\epsilon \OutP c {\hBool(\recpos x{\vec \pi},s)}.~\OutP c {\hfun(\1,s)} \qedhere
      \end{align*}
    \end{itemize}
  \end{proof}

  \propCorrectnessChacksat*

  \begin{proof}
    Let \(x\) be a complete binary tree of height \(n\) whose leaves are booleans, that is to say, a message such that \(\recpos x{\vec p}\in\B\) for all \(\vec p\in\B^n\). Naming \(x_0,\ldots,x_{2^n-1}\) the variables of \(\sem\Gamma_\varphi\) in this order, \(\val_x\) refers to the valuation mapping \(x_i\) to \(\recpos x {\vec p}\) where \(\vec p\) is the binary representation of \(i\) (of size \(n\) with padding head 0's).

    Let us now assume that \(\val_x\) does not satisfy \(\sem\Gamma_\varphi\). In particular there exists a clause of \(\sem\Gamma_\varphi\), say the \(i\)\textsuperscript{th} clause with \(i=\sum_{k=1}^m\pi_k2^{k-1}\), which is falsified by \(\val_x\). In particular, if the three variable of this clause are called \(x_1\), \(x_2\), \(x_3\) with respective negation bits \(b_1\), \(b_2\), \(b_3\), the following formula is evaluated to false (i.e. \(\0\)):
    \[\bigvee_{i=1}^3(~b_j=\val_x(x_j)~)\]
    Therefore, by choosing the sequence \(\pi_1,\ldots,\pi_m\) to instanciate the initial \(\guessBinary{p_1,\ldots,p_m}\) of \(\CheckSat x\), we obtain the following sequence of transitions, which concludes the proof:
    \begin{align*}
      \CheckSat x & \Cstep\epsilon \OutP c {\hfun(\0,s)}.~\OutP c {\hfun(\1,s)} \qedhere
    \end{align*}
  \end{proof}

  % \vspace{5mm}

  We finally gathered all the ingredients needed to prove the main lemma:

  \propCorrectnessCheckall*

  \begin{proof}
    We prove the result by double implication.
    \begin{itemize}[leftmargin=*]
      \item[\(\Rightarrow\)]
      Let us consider a valuation satisfying \(\varphi\) and let \(t\) be a message such that \(\val_t\) is equal to this valuation. 
      Then since the trace \(B \Cstep {\InP c t. \OutP c {\ax_1}. \OutP c {\ax_2}} \process \emptyset {\frameh \0}\) cannot be matched in \(A\)
      by Lemma \ref{lem:nexp st-equiv}, we obtain \(B \not \TraceIncl A\). Hence, since trace equivalence is the coarsest of the considered equivalence relations, we obtain the desired result.
      \item[\(\Leftarrow\)]
      By contraposition, let us suppose that \(\varphi\) is unsatisfiable, and let us prove that \(A \LabBis B\) (which implies all other equivalences).
      Let us consider \(\bisim\) the smallest reflexive symmetric relation on extended processes such that:
      \begin{enumerate}[label=\emph{\arabic*.}]
        \item \(A \bisim B\)
        \item \(A'(x) \bisim B'(x)\) for all message \(x\), where \(A = \InP c x. A'(x)\) and \(B = \InP c x. B'(x)\)
        \item \(P_i \bisim P_i'\), where:
        \begin{align*}
          P_i & = \process {\multi {\OutP c {t_{i+1}} \ldots \OutP c {t_p}}} {\{\ax_1 \mapsto t_1, \ldots, \ax_i \mapsto t_i\}}\\
          P_i' & = \process {\multi {\OutP c {t_{i+1}'} \ldots \OutP c {t_p'}}} {\{\ax_1 \mapsto t_1', \ldots, \ax_i \mapsto t_i'\}}
        \end{align*}
        and where $\{\ax_1 \mapsto t_1, \ldots, \ax_p \mapsto t_p\}
        \StatEq
        \{\ax_1 \mapsto t_1', \ldots, \ax_p \mapsto t_p'\}$
      \end{enumerate}
      It easily follows from Lemma \ref{lem:nexp st-equiv},\ref{prop:correctness checktree},\ref{prop:correctness checksat} that \(\bisim\) is a bisimulation up to \(\silentstep\), hence the conclusion. \qedhere
    \end{itemize}
  \end{proof}
