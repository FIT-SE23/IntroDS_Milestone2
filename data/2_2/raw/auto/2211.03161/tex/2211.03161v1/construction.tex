
\newcommand{\cQ}{{\cal Q}}
\newcommand{\cL}{{\cal L}}
\newcommand{\cD}{{\cal D}}
\newcommand{\cC}{{\cal C}}

\newcommand{\tcount}{\mathtt{count}}
\newcommand{\tselect}{\mathtt{select}}
\newcommand{\fin}{\mathtt{end}}

\section{Construction Algorithm}
\label{sec:construct}

As explained in previous sections, our data structure relies on a large number of three-dimensional shallow cuttings. There are algorithms that construct shallow cuttings in nearly linear time. That is, a shallow cutting of an $n$-point set can be constructed in time $O(n\log n)$~\cite{AfshaniT18,AfshaniCT14}. If we directly apply these algorithms, it would take   $\Omega(n^{3/2})$ time to construct our data structure.  

In this paper we use a different approach: We observe that conflict lists of cells in shallow cuttings are not needed in our case. The construction algorithm is modified so that the runtime is pseudo-linear in the \emph{number of cells} of the constructed 3d shallow cutting. We start by reviewing the algorithm of Afshani and Tsakalides~\cite{AfshaniT18}. Then we describe our implementation. Next we  show how the new  algorithm for 3d shallow cuttings can be applied to create our data structure for restricted 5-sided queries (Theorem~\ref{thm:rest-5-sided}) in $O(n\log^5n)$ time. Finally we explain how this result can be used to construct data structures for general orthogonal range reporting. In this section we will denote the second, third, and fourth coordinates of a point $p$ by $x(p)$, $y(p)$, and $z(p)$ respectively. 


\paragraph{Previous Work: Overview of an $O(n\log n)$-Time Algorithm.}
In~\cite{AfshaniT18} the authors show how a 2d shallow cutting can be maintained under deletions. Then they combine their method with the sweep-plane approach and obtain a three-dimensional shallow cutting.  
A two-dimensional shallow cutting is a staircase, i.e., a polyline obtained by alternating horizontal and vertical segments, see Fig.~\ref{fig:staircase}.  An \emph{inner corner} of a 2d shallow cutting is the lower endpoint of a vertical segment (resp.\ the left endpoint of a horizontal segment) and an \emph{outer corner} is the upper endpoint of a vertical segment (resp.\ the right endpoint of a horizontal segment).    When some inner corner  dominates less than $k$ points, we start the process of \emph{patching} the staircase. Let $c_i$ denote the outer corner that precedes $d_i$. Let $c'_i$ denote the leftmost point such that $y(c_i)=y'(c_i)$ and $c'_i$ dominates $10k$ points. We extend the preceding outer corner to the point $c_i'$ and $c'_i$ becomes a new outer corner. Then we find the point $d'_{i+1}$, such that $x(d'_{i+1})=x(c'_i)$ and $d'_{i+1}$ dominates $9k$ points;  we add a vertical segment $[c_i',d'_{i+1}]$ to the staircase and $d'_{i+1}$ becomes a new inner corner. Next, we find the leftmost point $c'_{i+1}$ with  $x(c'_{i+1})=x(d'_{i+1}$ such that $c'_{i+1}$ dominates $10k$ points; we add the horizontal segment $[d'_{i+1},c'_{i+1}]$ to the staircase.  We continue adding horizontal and vertical segments with corresponding outer and inner corners to the staircase until the following termination condition is satisfied: Let $d_j$ be the rightmost inner corner dominated by $c'_i$. If $d_j$ dominates at least $7k$ points, we add the corner $c''_i$ instead of $c'_i$, so that $x(c''_i)=x(d_j)$ and $y(c''_i)=y(c'_i)$.  Finally we add a vertical segment $[c''_i,d_j]$ and finish the process of patching. All corners dominated by new outer corners are removed from the two-dimensional shallow cutting. 

In order to obtain a three-dimensional shallow cutting, a plane parallel to the $xy$-plane is moved in $-z$-direction starting at $z=+\infty$.
A two-dimensional shallow cutting is maintained for all points that are below the plane\footnote{To simplify the description, we sometimes do not distinguish between a point and its $xy$-projection.}.  Every time when the plane hits a point, we remove it from the set of points below the plane. When some inner corner of the staircase dominates less than $k$ points, we patch the staircase as described above.  Every added  outer corner becomes an apex point of some cell in the  three-dimensional shallow cutting.


\begin{figure}[tb]
  \centering
  \begin{minipage}{.5\textwidth}
    \centering
    \includegraphics[width=.4\linewidth,page=1]{Figures/staircase}
%  \captionof{figure}{(a)}
%  \label{fig:test1}
\end{minipage}%
\begin{minipage}{.5\textwidth}
  \centering
  \includegraphics[width=.4\linewidth,page=3]{Figures/staircase}
%  \captionof{figure}{(b)}
%  \label{fig:test2}
\end{minipage}  
  \caption{Left: Inner and outer corners of a staircase (2d shallow cutting). Right: Patching of a staircase. Patch and new corners are shown with dashed polyline. The old corner $c_j$ dominates at least $7k$ points, but old corners $c_{i+1}$, $\ldots$, $c_{j-1}$ dominate less than $7k$ points.}
  \label{fig:staircase}
\end{figure}




\paragraph{Our Implementation}
The crucial difference between our result and  the previous work is that we reduce the number of updates on the two-dimensional shallow cutting. An update happens only when we have to remove an outer corner and patch the staircase. To this aim, we associate with each outer corner $c_j$ the $z$-position of the sweep-plane when it should  be removed (provided that $c_j$ was not removed earlier by the patching procedure). A more detailed description of our method follows below.

We maintain a queue $\cQ$ of corner events. $\cQ$ supports insertions, deletions, and find-max operations.  Every time when an inner corner $d_i=(x,y)$ is added to the staircase, we compute the highest value  $v$ such that the point $(x,y,v)$ dominates less than $k$ points of $P$; we associate an event  $(x,y,v)$ with $d_i$ and add it  to $\cQ$.  Obviously, $d_i$ should be removed from the staircase when the $z$-coordinate of the sweep-plane is equal to $v$ (unless $d_i$ was removed earlier by the patching procedure). We will use the notation $\fin(d_i)=v$.  We also maintain the list $\cL$ of all outer and inner corners sorted by $x$-coordinate. For each corner $c_i$ in the list we keep a pointer to the associated event in $\cQ$ (as well as a reverse pointer from an event in $\cQ$ to the corner in $\cL$).


Our algorithm also requires a data structure that supports range counting and range selection queries in 3d. A 3d orthogonal range counting query on a set $P$ computes the number of points in $q\cap P$ for a three-dimensional axis-parallel rectangle $q'=\prod_{i=1}^3 [a_i,b_i]$. 
A three-dimensional $z$-selection query $(a,b,k)$ asks for the highest value $v$  such that the point $p=(a,b,v)$ dominates exactly $k$ points in $P$\footnote{In this paper we consider a special case of selection queries, the dominance selection queries. For simplicity, this special case will be denoted selection queries.}. A three-dimensional $y$-selection query $(a,b,k)$ asks for the highest value $v$  such that the point  $p=(a,v,b)$ dominates exactly $k$ points in $P$.
A three-dimensional $x$-selection query $(a,b,k)$ asks for the highest value $v$ such that  such that the point  $p=(v,a,b)$ dominates exactly $k$ points in $P$.



The complete algorithm works as follows. We find the largest $z$-coordinate of the sweep-plane, such that at least one inner corner of the staircase dominates less than  $k$ points. This value can be found by extracting an event with the highest $z$-coordinate from the queue $\cQ$ (if there are several events with the same $z$-coordinate, we select the event with the smallest $x$-coordinate). Then we patch the corresponding corner $d_i$ as described above. Let $c_i$ denote the outer corner that precedes $d_i$.  We find the  point  $c'_i$ with $y(c'_i)=y(d_{i-1})$ that dominates  exactly $10k$ points.  Finding  $c'_i$ is equivalent to answering a range selection query. When $c'_i$ is known we find the point  $d'_i$ with the highest $y$-coordinate, such that $x(c'_i)=x(d'_i)$ and $c'_i$ dominates $9k$ points. We can find $d'_i$ using a range selection query too. Next, we identify the rightmost old corner $d_j$, such that $x(d_j)\le x(d'_i)$. The corner $d_j$ can be found by binary search on $\cL$. If $d_j$ dominates more than $7k$ points If $d_j$ dominates at most $7k$ points, we set $x(d'_i)=x(d_j)$, discard $c'_i$, and connect $d'_i$ with $d_j$ by a vertical segment. This completes the patching procedure.  When $c'_i$ and $d'_i$ are computed, we update the list $\cL$. New corners  $c_i'$ and $d_i'$ are inserted into $\cL$; old outer corners dominated by $d_i'$ and preceding inner corners are removed from $\cL$. 
For every  new inner corner $d_i$ that is inserted into $\cL$, we compute $\fin(c_i)$ and insert $(x(c_i),y(c_i),\fin(c_i))$  into $\cQ$.

In summary, we can construct a $t$-level three-dimensional shallow cutting with $g=O(\frac{m}{t})$ cells by executing $O(g)$ binary searches, executing $O(g)$ queries  and updates of $\cQ$, answering $O(g)$ three-dimensional range counting queries, and answering $O(g)$ three-dimensional range selection queries. The queue $\cQ$ can be implemented as a binary search tree, so that updates and queries can be supported in $O(\log m)$ time. Our algorithm is summarized in the following lemma.  
\begin{lemma}
  \label{lemma:construct3d}
  Suppose that we are given a data structure that supports three-dimensional orthogonal range counting queries and two-dimensional range selection queries on a set $P$ in times $f_{\mathtt{count}}(m)$ and $f_{select}(m)$ respectively, where $m$ is the number of points in $P$.   Then a  $t$-shallow cutting for a set $P$ can be constructed in $O(g( \log m + f_{\tcount}(m)+f_{select}(m))$ time, where $m$ is the number of points in $P$ and $g=O(\frac{m}{t})$ is the number of cells in the shallow cutting. 
\end{lemma}

% For each point
% $p=(y(d_{i-1}),x)$ we can compute the number of points that are dominated by $(x,y(d_{i-1}),v)$ by answering a three-dimensional orthogonal range counting query.
% Using binary search we can find the leftmost point  $c'_i$ with $y(c'_i)=y(d_{i-1})$ that dominates  $10k$ points in time $O(f_{\tcount}\log n )$. When $c'_i$ is known we find the point  $d'_i$ with the highest $y$-coordinate, such that $x(c'_i)=x(d'_i)$ and $c'_i$ dominates $k$ points. Using binary search and range counting queries, $d'_i$  can be found in $O(f_{\tcount}\log n)$ time. 


% A three-dimensional $z$-selection query $(a,b,k)$ asks for the highest value $v$  such that the point $p=(a,b,v)$ dominates exactly $k$ points in $P$\footnote{In this paper we consider a special case of selection queries, the dominance selection queries. For simplicity, this special case will be denoted selection queries.}. A three-dimensional $y$-selection query $(a,b,k)$ asks for the highest value $v$  such that the point  $p=(a,v,b)$ dominates exactly $k$ points in $P$.
% A three-dimensional $x$-selection query $(a,b,k)$ asks for the highest value $v$ such that  such that the point  $p=(v,a,b)$ dominates exactly $k$ points in $P$.

%Thus we can construct a three-dimensional shallow cutting with $g=\frac{n}{t}$ cells by executing $O(g)$ binary searches, answering $O(g)$ three-dimensional range counting queries, and answering $O(g)$ three-dimensional range selection queries. 
% \begin{lemma}
%   \label{lemma:construct3d}
%   Suppose that we are given a data structure that supports three-dimensional orthogonal range counting queries and two-dimensional range selection queries on a set $V$ in times $f_{\mathtt{count}}(m)$ and $f_{select}(m)$ respectively, where $m$ is the number of points in $V$. \\
%   Then a $t$-level shallow cutting for a set $V$ can be constructed in $O(g(\log m + f_{tcount}(m)+f_{select}(m))$ time, where  $g=O(\frac{m}{t})$ is the number of cells in the shallow cutting. 
% \end{lemma}
%In Lemma~\ref{lemma:construct3d} we assume that the data structure for selection and counting queries is already constructed (i.e., we ignore the construction time).

\paragraph{Construction of  Shallow Cuttings in Trees $T_i$.}
We construct shallow cuttings for all sets $P(v,i,j)$ using the method from Lemma~\ref{lemma:construct3d}. In order to apply this method, we must answer three-dimensional orthogonal range counting and range selection queries. 

We construct a data structure that supports four-dimensional orthogonal range counting queries on the input set $P$. A three-dimensional orthogonal range counting query $q'$ on $P(v,i,j)$ is equivalent to a four-dimensional orthogonal range counting  query $[l,r]\times q'$ on $P$ where $l$ and $r$ are the smallest and the largest first coordinates of points in $P(v,i,j)$. Using range trees and fractional cascading, we can answer four-dimensional counting queries in $O(\log^3 n)$ time. We can reduce $x$-selection  to range counting via  binary search on $x$-coordinates: We store $x$-coordinates of all points from $P$ in a balanced binary tree. To answer an $x$-selection query $(a,b,k)$, we visit nodes starting with the root node. For each visited node $\nu$, we compute the number of points $k'$in $P(v,i,j)\cap (-\infty,e]\times(-\infty,a]\times (-\infty,b]$ where $e$ is the $x$-coordinate stored in $\nu$. If $k'=k$, we return $e$. If $k'<k$ we move to the right child of $\nu$, and if $k'>k$, we move to the left child of $\nu$. Since, we visit $O(\log n)$ nodes, an $x$-selection query is answered in $O(\log^4n)$ time.
We can answer $y$-selection and $z$-selection queries in the same way. 
Combining this method with Lemma~\ref{lemma:construct3d}, we can construct a shallow cutting on a set $P(v,i,j)$ in time
$O(g\log^4 n)$ where $g$ is the number of cells in the shallow cutting or in $O(\log^4n)$ time per cell. 

The data structure that supports four-dimensional range counting in $O(\log^3n)$ time can be constructed in $O(n\log^4 n)$ time.  
As explained in Lemma~\ref{lemma:size}, the total number of cells in all shallow cuttings is  $O(n\log n)$. Hence all shallow cuttings needed in our data structure can be constructed in time $O(n\log^5 n)$.


We also need to construct pointers between cells of  different shallow cuttings. To this end, we will use a separate data structure for each set $P(v,l,r)$.This structure stores the apex points of cells from  $C(v,l,r)$  and supports the following three-dimensional one-reporting queries: given a query range $q=[q_1,q_2]\times [q_x,\infty)\times [q_y,\infty)\times [q_z,\infty)$, we must report only one point from the query range. Using the dominance range reporting structure from~\cite{Afshani08} with minor modifications, we can support such queries in $O(\log n)$ time. The data structure for one-reporting queries can be constructed in $O(n\log  n)$ time.  Then, for $i=1,2,\ldots$, we visit all sets $P(v,l,r)$ associated to $T_i$. For every $P(v,l,r)$ of $T_i$ we identify five sets $P(u_j,l_j,r_j)$ such that $P(v,l,r)=\cup_{j=1}^3P(u_j,l_j,r_j)$ and $u_j$ are nodes of $T_{i+1}$. Next we consider all nested shallow cuttings of $\cC(v,l,r)$. For each cell of each nested shallow cutting, we find the cell $C_j$ of $P(u_j,l_j,r_j)$, $j=1$,$\ldots$,$5$,  that contains $C$. If  $C_j$ contains $C$, then the apex point of $C_j$ dominates the apex point of $C$. Hence we can find $C_j$ in $O(\log n)$ time by answering a query on a dominance one-reporting  data structure for  $C(u_j,l_r,r_j)$. Thus we can construct all necessary pointers between cells in $O(\log n)$ time per pointer.  Hence all pointers between cells can be computed in $O(n\log^2 n)$ time. Other components of data structure for restricted 5-sided queries (slow data structures and conflict lists of cells associated with nodes of $T_{\log_{\beta}\log n}$) can be also constructed in $O(n\log^4 n)$ time. 





% Our query procedure relies on existence of pointers that connect each cell $C_N$  of nested shallow cuttings associated to a tree  $T_i$ with containing cells $C_j$, $j=1,2,3$ of shallow cuttings associated with a tree $T_{i+1}$.  The containing cells are such that for any query $q$ contained in $C_N$,  $q\cap L(C_N)=\cup_{j=1}^3 q\cap L(C_j)$.  To this aim, we consider each  shallow cutting  of $P(v,l,r)$ . All apex points of cells in  are stored in a data structure that supports dominance range reporting queries; we modify the dominance range reporting structure so that for a query range $q'=[q_x,\infty)\times [q_y,\infty)\times [q_z,\infty)$ we must report only one point from the query range. Such one-reporting queries can be supported in $O(\log n)$ time by modifying the result of Afshani~\cite{Afshani08}.  All 3-d dominance data structures can be constructed in $O(n\log n)$ time.   For every set $P(v,l,r,)$ of $T_i$ we identify three sets $P(u_j,l_j,r_j)$ such that $P(v,l,r)=cup_{j=1}^3P(u_j,l_j,r_j)$ and $u_j$ are nodes of $T_{i+1}$. For every cell $C$ of each nested shallow cutting, we find the cell $C_j$ of $P(u_j,l_j,r_j)$, $j=1$,$\ldots$,$3$,  that contains $C$. If  $C_j$ contains $C$, then the apex point of $C_j$ dominates the apex point of $C$. Hence we can find $C_j$ in $O(\log n)$ time by answering a dominance one-reporting query. Thus we can construct all necessary pointers between cells in $O(\log n)$ time per pointer. 





Our main result is the following theorem. %A three-dimensional orthogonal range counting query asks for the number of points in a three-dimensional rectangle $q=\prod_{i=1}^3[a_i,b_i]$.
\begin{theorem}
  \label{theor:construct}
  Data structure for restricted 5-sided 4d queries, described in Theorem~\ref{thm:rest-5-sided},  can be constructed in $O(n\log^5 n)$ time. 
\end{theorem}

In order to construct the data structure for (unrestricted) 5-sided queries described in Theorem~\ref{theor:5sid}, we (1) construct the data structure for restricted queries and (2) recursively construct data structures for $n^{1/3}$ sets of $n^{2/3}$ points. Hence the construction time $C(n)$ satisfies the recurrence $C(n)=O(n\log^5n)+ n^{1/3}\cdot C(n^{2/3})$.
Let $c(n)=\frac{C(n)}{n}$. Then $c(n)=O(\log^5 n)+ c(n^{2/3})$. The latter recurrence resolves to $c(n)=O(\log^5 n)$.
Hence $C(n)=O(n\log^5 n)$ and the data structure of Theorem~\ref{theor:5sid} can be constructed in $O(n\log^5 n)$ time. 

Data structures for the general case of orthogonal range reporting consist of multiple instances of structures from Theorem~\ref{theor:5sid}.
Hence, applying Theorem~\ref{theor:construct}, we can construct the data structure for $d$-dimensional orthogonal range reporting queries described in Theorem~\ref{theor:multidim}. The construction time is $O(n\log^{4+d}n)$. 







%%% Local Variables:
%%% mode: latex
%%% TeX-master: "4d-dom-pm"
%%% End:
