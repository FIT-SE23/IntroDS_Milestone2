\section{Experiences and Lessons Learned} \label{lessons}

In this section, we summarize the lessons we distilled from our experience of designing and implementing a secure, off-the-shelf and readily-available framework against zero-click attacks. 
We hope that these lessons and the insights from real users will be useful for researchers and mobile developers who wish to develop more rigorous mobile security solutions.

\subsection{Running Mobile OS on the Server} 

\subsubsection*{{\textbf{Lesson Learned \# 1:}}} 
\textit{{There are only a few open solutions to virtually run the mobile OS 24/7 in portrait orientation, and the most usable and scalable option appears to be the official Android Emulator.}} 

The first and foremost task in setting up a virtual smartphone was to run the mobile OS on our Linux-based dedicated server.  
The basic requirement was to find an appropriate option that is free, reliable, updated, and provides display in portrait mode. 
To this end, we explored existing local and cloud-based emulators, simulators, and virtual environments for Android and iOS.

Since Apple only allows iOS to run on iOS devices and the Xcode simulator~\cite{xcode}, it was difficult to emulate the iOS environment at the remote end where the underlying OS was Linux.
Likewise, existing web-based iOS emulators, namely Appetize.io~\cite{appetize} and Corellium~\cite{corellium}, also use an iOS device at the backend to feature a virtual iOS device and are costly.
Such options are only feasible for \textit{testing} iOS apps and are not meant for providing 24/7 service.

In contrast, there are several public and proprietary solutions that emulate an Android device. 
Below we discuss our experience using these options in the light of our requirements, followed by its summary in Table~\ref{tab:mobileos}.  
The official Android Emulator~\cite{androidstudio} provided a stable environment to run Android OS.  
Unfortunately, Android Emulator had high system requirements and limited mobile devices that support Google Play Store. 
In addition, the mobile versions with Play Store were restricted to automatic graphics, whereas, for other devices, we could choose hardware or software graphics, vary heap size, etc.
This adversely affected the performance of Android applications in Play Store-compatible emulated devices.  
However, as we ran only one application per Android emulator, these issues did not compromise the user experience.

We also explored the option of freely available, unofficial Android gaming emulators such as Memu~\cite{memu} and BlueStacks~\cite{bluestacks}.  
These emulators were unreliable, had sluggish performance, and were often stuck on the boot.  
BlueStacks and Memu displayed many advertisements and were often detected to be malicious by antivirus solutions; hence, we disregarded these unreliable emulators. \input{tables/mobileos}

Besides, we also tested common Android emulators, Anbox~\cite{anbox} and GenyMotion~\cite{genymotion}, that can run Android applications in the cloud. 
Anbox is a stable option, but since it is a desktop emulator, it cannot run in portrait mode, making it difficult to view the remote landscape screen on the smartphone even with screen rotation enabled.  
In contrast, GenyMotion uses a custom AOSP ROM, and takes advantage of OpenGL-capable graphics cards to run Android OS on the cloud platform in portrait orientation smoothly. 
However, Genymotion was expensive (i.e., \$0.5 per hour per instance) and hence, not a practical option for a server that has to run multiple instances 24/7. 
Also, GenyMotion did not have a built-in Google Play Store, and was incompatible with most Google Apps (GApps). 

Android-x86 OS~\cite{androidx86}, a port of the Android Open Source Project (AOSP), is another powerful option that can run Android OS on Intel x86 or AMD-powered devices.  
Android-x86 can be installed on a physical or virtual machine.  
We installed it in VirtualBox~\cite{virtualbox} to virtualize the Android instance on our Linux-based dedicated server, with KVM enabled.  
By default, Android-x86 offers landscape orientation. 
We modified the GRUB boot loader to change the orientation to portrait mode, making it feasible to fit the remote screen on the user's smartphone.  
However, as VirtualBox runs a full copy of OS and a virtual copy of requisite hardware, the setup was resource-intensive for merely running a single chat application.

In contrast to the official Android Emulator, Android's Cuttlefish~\cite{cuttlefish} is a configurable virtual Android device that responds to the application interactions at the OS level, just like a physical phone.
Cuttlefish can run locally on Linux x86 computing machines and cloud offerings such as GCP. 
However, Cuttlefish supports API levels after 28, runs only on a few Debian-based distributions, and is extremely resource-intensive.  
For us, the installation alone took more than 8 hours and a minimum of 250 GB disk space, making it an infeasible option for setting up multiple Android instances.

Lastly, we tested Microsoft's Windows 11 subsystem for Android~\cite{androidwindows} which makes it possible to run Android applications on Windows 11. 
This is a promising solution; however, the Android applications continued to crash while running in the beta phase.  
To conclude, the official Android emulator seemed to be the most appropriate choice to run mobile OS at the server end reliably. 

\subsection{Sandboxing Applications on the Server}

\subsubsection*{{\textbf{Lesson Learned \# 2:}}} \textit{{Android's default
Application Sandbox is ineffective against zero-click cross-application attacks.
Hence, virtualization or containerization techniques can be employed to isolate applications with some security and resource trade-offs.}} 

Android OS has a default Application Sandbox~\cite{sandbox} that works by assigning a unique User ID (UID) to every Android application and runs each application in isolation as a separate process. 
This kernel-level sandbox extends protection to OS applications, native code and everything above the kernel, including OS libraries and application framework. 
Despite this, zero-click exploits can defeat the Android Application Sandbox and escalate privileges to gain root access to the entire device. 
Hence, we investigated more powerful isolation mechanisms, i.e., virtualization and containerization, to isolate Android applications on the server safely.

We ran individual applications in Android Emulator on top of separate virtual machines and believe that it provides ultimate security against zero-click-based cross-application exploits and cross-OS exploits.  
This is because a zero-click exploit cannot exfiltrate from Android instance A running application A to the Linux host and into Android instance B to compromise application B. 
Although secure, this setup was extremely resource-intensive.  
We also tested multiple instances of Android Emulator on top of Docker~\cite{docker}, which essentially allowed us to isolate each application in a separate container. 
Like virtualization, containerization also reduced the prospective susceptibility of the installed applications to invisible zero-click attacks; however, this setup was much more lightweight, and hence, was preferred.

\subsection{Implementing the Server on Cloud Platform}

\subsubsection*{{\textbf{Lesson Learned \# 3:}}} \textit{{Mobile OS requires hardware virtualization for enhanced performance and graphics; hence, running the mobile OS on bare-metal cloud servers is expensive and not a long-term and scalable solution. 
An appropriate trade-off is to employ software acceleration to run the mobile OS on public cloud platforms.}}

After successfully implementing containerized Android Emulator setup on our dedicated Linux server, we tested its feasibility in the cloud platforms, namely GCP, AWS, and Azure. 
Although the Android Emulator was successfully installed in the cloud, it showed sluggish performance. 
In general, the emulator's performance can be improved by enabling virtual machine and graphic acceleration~\cite{virtualization} forcing the hypervisor to use the processor of the underlying computer to improve the emulator's execution speed. 
As buying a bare-metal cloud instance or adding a GPU are not cost-effective options to run a mobile OS 24/7, we instead relied on enhancing the emulator's performance through software acceleration (where the Android Emulator simulated GPU processing using the computer's CPU).
This enabled us to run Android Emulator in Docker containers on the cloud with acceptable performance. 

Note that we also tested the feasibility of another viable alternative, i.e., Android-x86 OS-based VM on cloud platforms. However, it was unstable (i.e., it could not boot up or kept crashing) even with nested virtualization enabled.  
This is primarily because Android-x86 is not officially compatible with cloud platforms yet~\cite{gcp}, and requires a physical Linux machine with KVM enabled. 

\subsection{Exploring Remote Connection Protocols}

\subsubsection*{{\textbf{Lesson Learned \# 4:}}} \textit{{Existing open-source implementations of remote connection protocols, notably VNC and RDP, yield display in landscape orientation by default. 
This makes it difficult to control the remote device from the smartphone. 
In contrast, WebRTC is a secure alternative that offers screen sharing in portrait mode.}} 

With the server side set up, the next task was to remotely connect the server and the client such that there was no direct delivery of messages to the client device.  
We noticed that Microsoft's Remote Desktop Protocol (RDP)~\cite{rdp} and Virtual Network Computing (VNC)~\cite{vnc} are the two most widely-used remote connection protocols that share the server's screen at the client end, and let the user control the remote server.  
However, existing implementations of RDP and VNC are mostly designed for desktops and always yield display in landscape view. 
The remote landscape view was user-unfriendly when seen on the user's smartphone.  
We attempted changing the screen orientation at the client and server; however, the shared screen remained in landscape mode irrespective of the client's orientation.  
Besides these remote connection protocols, WebRTC provides screen sharing capability in web and native applications. 
As WebRTC offers screen sharing in portrait mode, we combined WebRTC's API with the React web application to provide screen sharing and remote control functionality. 

\subsection{Exploring Remote Connection Applications}

\subsubsection*{{\textbf{Lesson Learned \# 5:}}} \textit{{Unlike computer-to-computer and mobile-to-computer screen sharing applications, there are only a few mobile-to-mobile screen sharing applications available; however, most of them are
costly, work only in the local network, lack remote control functionality, and do not provide unattended access to the server.}} 

We also tested major screen sharing and remote control applications available on the Google Play Store and Apple App Store to see if any application can outperform WebRTC. 
We noticed that most available remote control applications, such as Remote Chrome Desktop~\cite{crd}, RealVNC~\cite{vncviewer}, SplashTop~\cite{splashtop}, ISL Lite~\cite{isllite}, Zoho~\cite{zoho}, and AnyScreen \cite{anyscreen}, required either the server or the client device to be a desktop computer.
In our case, both the client and server run the mobile OS; hence, these applications could not solve the screen orientation issue.

\input{tables/remote}
We, therefore, specifically looked for mobile-to-mobile remote access solutions (Table~\ref{tab:remote}).
While Skype~\cite{skype}, ScreenTalk~\cite{screentalk} and Inkwire~\cite{inkwire} provided high-quality mobile-to-mobile screen sharing, these technologies lacked the required remote control functionality.
Furthermore, applications such as Scrcpy~\cite{scrcpy} and Vysor~\cite{vysor} required physical (USB) access to the smartphone to mirror the screen.  
This was impractical in our case, where the server needs to be a standalone remote device that is always accessible by the user. 
In our search, we found out DroidVNC-ng~\cite{droidng}, RemoDroid~\cite{remodroid} and AirpowerMirror~\cite{airpower} provided both screen mirroring and remote control functionality.
However, Droid-ng and RemoDroid were unstable, and the connection was frequently terminated.
Also, RemoDroid and AirpowerMirror had high latency of up to 8 seconds and could only work within the local network. 
Since our basic requirement was remote user access, we disregarded these options.

Professional proprietary solutions such as TeamViewer~\cite{teamviewer}, AnyDesk~\cite{anydesk} and AirDroid~\cite{airdroid} also meet our requirement of screen sharing and remote access. 
Unfortunately, TeamViewer and AnyDesk had costly licenses, which made it impractical to run the proposed prototype for even a single user. 
In contrast, AirDroid was cost-effective (\$3 a month) and provided high-quality screen mirroring and remote control functionality over the Internet.  
However, as AirDroid is a proprietary application, the user does not have full control over the mirrored data that also passes through the AirDroid infrastructure. 
Thus, we preferred using the WebRTC-based screen sharing service over remote control applications.

\subsection{Open-Ended Security and Usability Issues}

Our framework aims to ensure that the zero-click infection is confined only to the targeted application in case of an attack, while the client device and other isolated remote applications remain safeguarded.  
Below, we highlight the missing components that we deem necessary to achieve better security guarantees against zero-click attacks, and enhance the user's experience of a virtual smartphone.

\paragraph{Security:}

Since our implementation uses COTS components, any vulnerability on the remote server can infect the client device, and invade the user's privacy.
For utmost protection, the server should remain updated to the latest version. 
In practice, any installed chat app or SMS Gateway can also be malicious or compromised.
However, in such a case, only that specific instance will be compromised, and other isolated apps or the client device will not be affected.

Moreover, as iMessages can only be exchanged between Apple devices, shifting iMessage to the server requires a dedicated iOS device which is not a cost-effective solution.
On the contrary, allowing iMessages on the client device can compromise the security of the client device. 
Our framework makes a trade-off between the client device's safety and additional features that iMessage provides over SMS (e.g., end-to-end encrypted chat, screen effects, etc.).
Essentially, we shifted SMS onto the remote server; hence, now iMessages are received as regular SMS on the server and securely mirrored on the client device.  

In addition, the MVT~\cite{mvt} tool can be used to scan the dump of containerized instances every few days and check if any instance is infected with zero-click exploits. 
However, the detection of IoCs is dependent on how frequently the MVT repository is updated. 

\paragraph{Usability:}
With regards to usability, the current off-the-shelf implementation we evaluated to gain experience about zero-click solution requirements does not have a notification mechanism, i.e., the user has to manually check for new messages. 
A possible solution would be to develop an application that reads the status of other applications on the server, and notifies the client device whenever a notification is received. 
However, this is not possible without rooting/jailbreaking the phone, as Android OS and iOS run each application in the sandbox, and have limited content sharing across applications. 
However, rooting the device makes it vulnerable to many other attacks.
Hence, like secure government systems that require the user to check messages manually, there is a trade-off taken between security and usability. 

In contrast to Apple's Lockdown mode that severely restricts the download of attachments, e.g., files on the phone, our setup allows users to download, view and access files remotely.
However, as the remote instances are periodically reset, any received file cannot be saved for future use. The user has to decide the frequency of resetting the server as per his needs. 

Beside text messages, images and files, the virtual smartphone can also receive videos and audio messages. However, since the server's messages are displayed through screen sharing on the user's smartphone, the user can only view the video but not listen to the audio.  
Hence, there would also be a need to effectively relay the audio of communicating parties so that the user can listen to audio messages and secure calls. 
