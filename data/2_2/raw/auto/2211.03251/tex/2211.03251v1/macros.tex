\definecolor{myblue}  {RGB}{3,122,235}
\definecolor{mypurple}{RGB}{176,095,183}
\definecolor{myorange}{RGB}{252,128,8}
\definecolor{mygreen} {RGB}{0,143,0}
\definecolor{myred}   {RGB}{231,091,093}
\definecolor{mymaroon}   {RGB}{175,012,035}
\definecolor{mygray}  {RGB}{234,234,241}
\definecolor{nugray}  {RGB}{220,220,227}

\definecolor{mydarkgray}  {RGB}{80,80,80}

\newcommand{\TODO}[1]{\textbf{{\color{todocolor}TODO: #1}}}

\newcommand{\figref}[1]{\Cref{fig:#1}}
\newcommand{\secref}[1]{\Cref{sec:#1}}
\newcommand{\subsecref}[1]{\S\,\ref{sec:#1}}
\newcommand{\eqnref}[1]{Eq.~\ref{eqn:#1}}
\newcommand{\eqnsref}[2]{Eqs.~\ref{eqn:#1} and~\ref{eqn:#2}}
\newcommand{\eqnrref}[2]{Eqs.~\ref{eqn:#1}--\ref{eqn:#2}}
\newcommand{\defref}[1]{Definition~\ref{def:#1}}
\newcommand{\tabref}[1]{\Cref{tab:#1}}
\newcommand{\HIDE}[1]{}

\newcommand{\pluseq}{\mathrel{+}=}
\newcommand{\asteq}{\mathrel{*}=}

\newcommand\defeq{\mathrel{\overset{\makebox[0pt]{\mbox{\normalfont\scriptsize\sffamily def}}}{=}}}

\newcommand\code[1]{\lstinline[mathescape=true,basicstyle=\ttfamily\normalsize]|#1|}
\newcommand\codesmall[1]{\lstinline[mathescape=true,basicstyle=\ttfamily\footnotesize]|#1|}
\newcommand{\spmv}{\texttt{SpMV}\xspace}

\algnewcommand{\LineComment}[1]{\State // #1}

\newcommand{\olivia}[1]{{\color{purple} {\bf Olivia:} #1}}

% Commands for BNF notation.
\newcommand{\bnfdef}{\mathrel{::=}}
\newcommand{\bnfalt}{\mathrel{\mid}}
\newcommand{\mT}{\mathcal{T}}


% Commands for coiteration algorithm 
\newcommand{\iterFn}{lowerIter}

\colorlet{emititerationcolor}{myblue}
\colorlet{emitmappingcolor} {mypurple}
\colorlet{emitassemblycolor} {mygreen}
\colorlet{emitcomputecolor}  {mygreen}
\newcommand\emititerationcolor[1]{\textcolor{emititerationcolor}{#1}}
\newcommand\emitmappingcolor[1]{\textcolor{emitmappingcolor}{#1}}
\newcommand\emitcomputecolor[1]{\textcolor{emitcomputecolor}{#1}}
\newcommand\emitassemblycolor[1]{\textcolor{emitassemblycolor}{#1}}

\colorlet{emititerationrefcolor}{emititerationcolor}
\colorlet{emitmappingrefcolor}  {emitmappingcolor}
\colorlet{emitcomputerefcolor}  {emitcomputecolor}
\colorlet{emitassemblyrefcolor} {emitassemblycolor}

\newcommand\emititerationref[1]{\hypersetup{linkcolor=emititerationrefcolor}\textcolor{emititerationrefcolor}{\secref{#1}}\hypersetup{linkcolor=black}}
\newcommand\emitmappingref[1]{\hypersetup{linkcolor=emitmappingrefcolor}\textcolor{emitmappingrefcolor}{\secref{#1}}\hypersetup{linkcolor=black}}
\newcommand\emitcomputeref[1]{\hypersetup{linkcolor=emitcomputerefcolor}\textcolor{emitcomputerefcolor}{\secref{#1}}\hypersetup{linkcolor=black}}
\newcommand\emitassemblyref[1]{\hypersetup{linkcolor=emitassemblyrefcolor}\textcolor{emitassemblyrefcolor}{\secref{#1}}\hypersetup{linkcolor=black}}

\newcommand\EmitPseudo[2]{
  \expandafter\newcommand\csname #1\endcsname{%
    \textbf{emit} #2
  }
}

\EmitPseudo{initIters}{initialize iterators}
\EmitPseudo{initIterMeta}{initialize iterator metadata}
\EmitPseudo{loopHeader}{loop header}
\EmitPseudo{loopFooter}{loop footer}
\EmitPseudo{accessIters}{access iterators}
\EmitPseudo{resolveCoord}{resolve the coordinate of $i$}
\EmitPseudo{locateLocators}{locate from locators }
\EmitPseudo{condHeader}{conditional header}
\EmitPseudo{condFooter}{conditional footer}
\EmitPseudo{advanceIters}{advance iterators}

\EmitPseudo{mapTo}{map candidate coordinates to the original space}
\EmitPseudo{mapFrom}{map resolved coordinate to each derived space}

\newcommand{\ldotspack}{.\hskip-.5ex.\hskip-.5ex.}
%\newcommand{\ldotspack}{...}
\EmitPseudo{denseIter}{\texttt{Foreach or Reduce(\ldotspack{}=> i\ldotspack{})}}
\EmitPseudo{interIter}{\texttt{Foreach(Scan(\ldotspack{}or\ldotspack{}=> i\ldotspack{})}}
\EmitPseudo{unionIter}{\texttt{Foreach(Scan(\ldotspack{}and\ldotspack{}=> i\ldotspack{})}}
\EmitPseudo{sparseBVIter}{\texttt{Foreach(\ldotspack{}=> pos\ldotspack{})}}
\EmitPseudo{sparseIter}{\texttt{Foreach(Scan(\ldotspack{}=> i\ldotspack{})}}

\EmitPseudo{genBVtwo}{$\mathcal{B}_2=$ \Call{genBitvector}{$\mT_2$}}
\EmitPseudo{genBVone}{$\mathcal{B}_1=$ \Call{genBitvector}{$\mT_1$}}
\EmitPseudo{genBVResult}{scanner for result positions}

\EmitPseudo{computeCode}{compute code}
\EmitPseudo{assemblyCode}{assembly code}
\EmitPseudo{segmentInsert}{position insert code}

\algnewcommand\algorithmicswitch{\textbf{switch}}
\algnewcommand\algorithmiccase{\textbf{case}}
\algnewcommand\algorithmicdefault{\textbf{default}}

\algdef{SE}[SWITCH]{Switch}{EndSwitch}[1]{\algorithmicswitch\ #1\ \algorithmicdo}{\algorithmicend\ \algorithmicswitch}%
\algdef{SE}[CASE]{Case}{EndCase}[1]{\algorithmiccase\ #1}{\algorithmicend\ \algorithmiccase}%
\algdef{SE}[DEFAULT]{Default}{EndDefault}[1]{\algorithmicdefault\ }{\algorithmicend\ \algorithmicdefault}%
\algtext*{EndSwitch}%
\algtext*{EndCase}%
\algtext*{EndDefault}%

\algtext*{EndWhile}
\algtext*{EndIf}

\newcommand{\name}{Stardust\xspace}

\newcommand*\circled[1]{\tikz[baseline=(char.base)]{
            \node[shape=circle,draw,inner sep=2pt] (char) {#1};}}
            
\sisetup{detect-all}
