\subsection{Error Pattern, Syndrome, and Parity}
A surface code can be represented by the model graph $G(U,F)$, where $U$ is the set of vertices, each representing a stabilizer, and $F$ is the set of edges, each representing an independent error source, including data qubit.
$\forall u\in U$, let $F(u)$ denote the set of edges that are incident to $u$; likewise, $\forall f\in F$, $U(f)$ denotes the set of vertices that are incident to $f$.


\paragraph{Error Pattern}
In this work, we only consider Pauli errors. Therefore, an error to $f\in F$ can be regarded as an operator $\hat{f}$ that ``flips'' the state of $f$. Obviously $\hat{f}\hat{f}=I$.
An error pattern $\E$ is a subset of error sources (edges) in which error happens. On the model graph, it can be denoted as $E\subseteq F$. 
An error pattern can also be considered as an operator $\hat{\E}$ that flips the corresponding error sources: $\hat{\E}=\prod_{f\in E} \hat{f}$. 
Because there is a bijective mapping between error patterns and operators, we often use an error pattern $\E$ and its operator $\hat{\E}$ in an interchangeable manner.

Borrowing the notations from~\cite{bombin2013introduction}, we can represent $\E$ as a sum over all edges: $\E=\sum_{f\in E}f$.

With this sum form, two error patterns can be added together to form a new one with $f+f=0$, because an error flips the state of error source $f$.
Given two error patterns, $\E_1$ and $\E_2$, we define their sum as 
\[ \E_1\oplus\E_2= \sum_{f\in E_1}f+\sum_{f\in E_2}f=\sum_{f\in E_1 \triangle E_2}f\]


The error patterns and $\oplus$ constitute an Abelian group. The inverse of an error pattern is simply itself. For simplicity, we use $+$ in place of $\oplus$.

A special type of error pattern is a path of contiguous edges that starts with one vertex and ends with another. A circle is a path that starts and ends with the same vertex.

\paragraph{Syndrome}
For a stabilizer $u\in U$, it gives a nontrivial measurement outcome if an odd number of edges it connects with experience error.  Intuitively, one can consider an error in an edge incidental to $u$ ``flips'' the stabilizer measurement outcome.

For error patterns of a single error, $\forall f\in F$, we can represent its syndrome in a similar sum form  
\[S(\{f\})=\sum_{u\in U(f)} u.\] 
 That is, a single error in $f$ causes nontrivial measurement outcomes in all stabilizers it is connected with. 

Given an error pattern $\E$, its syndrome $S$ includes all the nontrivial measurement outcomes. We can represent $S$ as a sum over the syndromes of all its errors.
\begin{equation}
S(\E)=\sum_{f\in E}S(\{f\})
\end{equation}
where $\forall u\in U$, $u+u=0$, because a stabilizer gives a nontrivial measurement outcome if an odd number of edges it connects with experience error. 

Given two error patterns $\E_1$ and $\E_2$, we have 

\[S(\E_1+\E_2)=S(\E_1)+S(\E_2).\]

Given a path $\mathcal{P}$ in the model graph connecting two vertices $u$ and $v$, we have $S(\mathcal{P})=u+v$.

\paragraph{Parity}
For $u\in U$, let $V_L(u)$ indicate whether $u$ is a left virtual boundary vertex: 1 if yes; 0 if not. 

For error patterns of a single error, $\forall f\in F$, its left parity $P_L(\{f\})$ is defined as parity of how many left virtual boundary vertices $f$ is incident to. 
\[P_L(\{f\})=\sum_{u\in U(f)} V_L(u)\]
where $V_L(u)+V_L(u)=0$. Given an error pattern $\E$, its left parity $P_L$ is the sum of the parity of all its single errors. 
\begin{equation}
P_L(\E) = \sum_{f\in E} P_L(\{f\}).
\end{equation}
where $1+1=0$. Given two error patterns $\E_1$ and $\E_2$, we have 

\[P_L(\E_1+\E_2) = P_L(\E_1)+P_L(\E_2).\]

Given a path $\mathcal{P}$ in the model graph connecting two vertices $u$ and $v$, we have $P_L(\mathcal{P})=V_L(u)+V_L(v)$.


The parity on the right boundary $P_R(\E)$ is similarly defined. For open-boundary surface code, we have: 
\begin{equation}
\label{equ:parity-syndrome}
P_L(\E) + P_R(\E) = |S(\E)| \ (\mathrm{mod}\ 2).
\end{equation}

We provide some intuition behind this property that links the parity with the syndrome. 
When the error pattern is empty, $P_L(\E) + P_R(\E) = |S(\E)| \ (\mathrm{mod}\ 2) = 0$.
Otherwise, $\forall f=\langle u,v \rangle \in E$, if $V_L(u)=1$, i.e., $f$ is incidental to the left virtual boundary, $v$ must be a stabilizer. We have $P_L(\{f\})=1$ and $S(\{f\})=v$. That is, $f$ will flip both $P_L(\E)$ and $|S(\E)| (\mathrm{mod}\ 2)$. The same can be said about edges incidental to the right virtual boundary.
 if $f$ is not incidental to either virtual boundary, $P_L(\{f\})=P_R(\{f\})$=0 and $f$ will flip the states of both $u$ and $v$ and as a result, leave $|S(\E)| (\mathrm{mod}\ 2)$ unchanged.


\paragraph{Logical operator and trivial logical operator} 
When an operator is applied to the surface code, a subset of the stabilizers may have nontrivial measurement outcomes. When the subset is empty, i.e., all measurement outcomes are trivial, the operator is a \emph{logical operator}. That is, a logical operator does not produce any syndrome. 

\vspace{1ex}\noindent \emph{Definition (Logical Operator)}: an error pattern $\E$ is a logical operator if and only $S(\E)=0$.

If $\E$ is a logical operator,  
we have $S(\E) = 0$ and therefore $P_L(\E) = P_R(\E)$. Therefore, when we know $\E$ is a logical operator, we will use $P(\E)$ as a short-hand for both $P_L(\E)$ and $P_R(\E)$.

A trivial logical operator does not change the logical state of the surface code. 
In \S\ref{sec:background_surface}, we introduced the notion of trivial logical operator and mentioned that error patterns that form closed circles are trivial logical operators. We define it formally below.

\vspace{1ex}\noindent \emph{Definition (Trivial Logical Operator)}:~~A logical operator $\E$ is trivial iff $P(\E)=0$.

A circle on the model graph is a trivial logical operator. This is because a circle $\mathcal{C}$ starts and ends with the same vertex $u$: $S(\mathcal{C})=u+u=0$ and $P(\mathcal{C})=V_L(u)+V_L(u)=0$.

Given any trivial logical operator $\mathcal{T}$ and $\E$ an error pattern, we have $S(\E+\mathcal{T})=S(\E)$ and $P(\E+\mathcal{T})=P(\E)$. That is, adding a trivial logical operator to any error pattern will not change the syndrome or parity. 
