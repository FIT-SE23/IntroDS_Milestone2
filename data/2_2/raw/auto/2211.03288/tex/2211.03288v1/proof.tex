\subsection{Analytical Evidence}\label{ss:analytical_evidence}

We next leverage the interpretation in \S\ref{sec:interpretation} to shed analytical insight into the empirical data reported above about the decoding accuracy given the XZZX code towards infinite noise bias.


\begin{figure}
    \renewcommand*\thesubfigure{(\alph{subfigure})}  % add parentheses manually
	\centering
% 	\includegraphics[width=0.80\linewidth]{figures/graph_making.pdf}
%	\begin{subfigure}{.46\linewidth}
	    \centering
        \includegraphics[width=.48\linewidth]{figures/graph/model_graph_XZZX_inf.pdf}
        % \caption{Model Graph}
        % \label{fig:xzzxg_construction_a}
%    \end{subfigure}
    % \begin{subfigure}{.46\linewidth}
	   % \centering
    %     \includegraphics[width=.9\linewidth]{figures/graph/complete_syndrome_graph_XZZX_inf.pdf}
    %     \caption{Syndrome Graph}
    %     \label{fig:xzzxg_construction_d}
    % \end{subfigure}
	\caption{The model graph of a $3\times 3$ XZZX surface code with infinite bias and perfect stabilizer measurements.}
	\label{fig:xzzxg_construction}
\end{figure}

\begin{figure*}[ht]
    \renewcommand*\thesubfigure{(\arabic{subfigure})}  % add parentheses manually
    \centering

\begin{minipage}{\textwidth}
    \centering
	\begin{subfigure}{.24\textwidth}
        \includegraphics[width=\linewidth]{figures/equivalency_single_line_2/blossom_multi_grow/blossom_multi_grow_1.4.pdf}
        \caption{$\sum y = 2.4$}
        \label{fig:equivalency_single_line_A}
    \end{subfigure}
	\begin{subfigure}{.24\textwidth}
        \includegraphics[width=\linewidth]{figures/equivalency_single_line_2/blossom_multi_grow/blossom_multi_grow_1.6.pdf}
        \caption{$\sum y = 2.6$}
        \label{fig:equivalency_single_line_B}
    \end{subfigure}
	\begin{subfigure}{.24\textwidth}
        \includegraphics[width=\linewidth]{figures/equivalency_single_line_2/blossom_multi_grow/blossom_multi_grow_2.5.pdf}
        \caption{$\sum y = 3.5$}
        \label{fig:equivalency_single_line_C}
    \end{subfigure}
	\begin{subfigure}{.24\textwidth}
        \includegraphics[width=\linewidth]{figures/equivalency_single_line_2/blossom_multi_grow/blossom_multi_grow_4.pdf}
        \caption{$\sum y = 5$}
        \label{fig:equivalency_single_line_D}
    \end{subfigure}
% 	\includegraphics[width=0.95\linewidth]{figures/approximate_dual_update/approximate_dual_update.pdf}
	\caption{ Blossom Algorithm: (1) from left to right is the root node, child node and leaf node (2) both root node and leaf node grow dual variables but child node shrinks by the same amount. (3) a blossom is created. (4) the final matching result and the correction. Note that only the horizontal boundaries of a cluster are meaningful in such a 1D graph. We still draw the cluster in 2D to be consistent with \autoref{fig:blossom_multi_grow}.}
	\label{fig:equivalency_single_line_Blossom}
\end{minipage}

\hfill

\begin{minipage}{\textwidth}
	\begin{subfigure}{.24\textwidth}
        \includegraphics[width=\linewidth]{figures/equivalency_single_line_2/union_find_multi_grow/union_find_multi_grow_1.4.pdf}
        \caption{}
        \label{fig:equivalency_single_line_E}
    \end{subfigure}
	\begin{subfigure}{.24\textwidth}
        \includegraphics[width=\linewidth]{figures/equivalency_single_line_2/union_find_multi_grow/union_find_multi_grow_1.6.pdf}
        \caption{}
        \label{fig:equivalency_single_line_F}
    \end{subfigure}
	\begin{subfigure}{.24\textwidth}
        \includegraphics[width=\linewidth]{figures/equivalency_single_line_2/union_find_multi_grow/union_find_multi_grow_2.5.pdf}
        \caption{}
        \label{fig:equivalency_single_line_G}
    \end{subfigure}
	\begin{subfigure}{.24\textwidth}
        \includegraphics[width=\linewidth]{figures/equivalency_single_line_2/union_find_multi_grow/union_find_multi_grow_4.pdf}
        \caption{}
        \label{fig:equivalency_single_line_H}
    \end{subfigure}
% 	\includegraphics[width=0.95\linewidth]{figures/approximate_dual_update/approximate_dual_update.pdf}
	\caption{ UF Decoder: (1)(2)(3) Odd clusters grow uniformly. (4) the resulting correction pattern, which corresponds to the same perfect matching as \autoref{fig:equivalency_single_line_D}}
	\label{fig:equivalency_single_line_UF}
\end{minipage}

\end{figure*}

Delfosse et al~\cite{delfosse2021almost} have already proved that the unweighted UF decoder is optimal when the error model is i.i.d in a quantum repetition code.
We next show that it is optimal for the XZZX code with infinite noise bias and noiseless stabilizers, without the i.i.d. assumption. 

Without loss of generality, we assume there are only Z errors on data qubits.
The model graph now becomes a set of disjoint subgraphs: each is a line as shown in \autoref{fig:xzzxg_construction}. As a result, the syndrome graph also becomes a set of parallel lines.
A perfect matching of the syndrome graph must comprise of perfect matchings for all such lines, each found separately.
Let us examine one such line with the \diagram to compare the blossom algorithm (\autoref{fig:equivalency_single_line_Blossom}) and the UF decoder (\autoref{fig:equivalency_single_line_UF}).
Similar to the diagram in \S\ref{ssec:blossom_sc}, the Manhattan distance between vertices $u, v$ is the weight $w_e$ of the edge $e = \langle u, v \rangle$ in the syndrome graph.
There is no need to assume identical physical error rates: the distances between adjacent vertices $w_e = -\log \frac{p_e}{1-p_e}$ depend on each individual physical error rate $p_e$, and the distances between any three vertices in a row $u, x, v$ satisfy $w_{\langle u, v \rangle} = w_{\langle u, x \rangle} + w_{\langle x, v \rangle}$.

We next show the two conditions presented in \S\ref{sec:interpretation} are true for the XZZX code with infinite bias and noiseless stabilizers.

\nosection{Identical Clusters.}
We show that the clusters in the UF decoder and the \clusters in the blossom algorithm for the XZZX code are always the same.
% \lin{The explanation below heavily relies on the notion of alternating tree. Could you do it without using it too much? Remember to this point, this paper only mentions the concept in passing.}\yue{Here I'm using mathematical induction to prove the identical clusters by 1. identical start point 2. identical next state supposing identical current state. Without using alternating tree to explain what is the next state given any current state, I cannot prove 2 even intuitively: how to explain an odd dual cluster always grow evenly on the left and right?}
% \lin{Could we provide an intuitive explanation here without involving alternating tree? ``explanation'' is not ``proof''. You can provide an inductive, rigorous proof in the appendix? There you can define alternating tree precisely.}\yue{I don't have such an intuitive explanation. If we were to put it in the appendix, I could say ``an odd dual cluster always grow evenly on the left and right'' here, and put the proof of this behavior in appendix. Of course, this is just a conclusion, not very intuitive.}
This is because in a 1D chain, an even dual cluster is always solved and an odd dual cluster always grows evenly on the left and right during the algorithm, as explained in \S\ref{ap:blossom_1d_chain}.
% each alternating tree is simply a chain of odd number of nodes.
% Both the left-most node and the right-most node is growing node in an alternating tree, thus this odd dual cluster grows evenly on the left and right.
% A dual cluster stops growing when it becomes an even dual cluster or it touches a virtual boundary vertex.
% This is because an even dual cluster or a dual cluster touching virtual boundary in such a 1D chain can always be perfectly matched internally using only tight edges in a nearest-neighbor manner.
For the UF decoder, even clusters stop growing while odd clusters grow evenly on the left and right: the growing condition is the same as the MWPM decoder.
Thus, the MWPM decoder (with the multiple tree approach~\cite{kolmogorov2009blossom}) and the UF decoder update clusters in exactly the same way and terminates at the same clusters.
This is illustrated by the example of \autoref{fig:equivalency_single_line_UF} and \autoref{fig:equivalency_single_line_Blossom}.

\nosection{Equivalent Matchings}
The only nontrivial logical operator is an error chain connecting the left and right virtual boundary vertices.
According to \hyperref[lemma:equivalent_matchings]{\textit{Lemma (Equivalent Matchings)}}, any two perfect matchings inside a cluster differ by a trivial logical operator if this cluster is detached.
A cluster is attached if and only if it touches both the left and right virtual boundary vertices. 
If the code distance is an odd number in an i.i.d. error model, a cluster will never be attached because the diameter of the cluster is twice the total weight of an error pattern, which will never be an odd number.
More generally, in a possibly non-i.i.d. error model and any code distances, if the sum of all weights along the 1D chain is an odd number, then a single cluster will never touch both virtual boundary vertices.
In these cases, the correction pattern from the UF decoder and the MWPM decoder never differ by a nontrivial logical operator, i.e. their logical error rate is the same.
Otherwise, if a cluster does touch both virtual boundary vertices, then there are two correction patterns that are equally weighted but complementary to each other, i.e. they differ by a nontrivial logical operator.
When this happens, since both error patterns are equally probably, choosing any of them will lead to conditional 50\% logical error rate given this syndrome.
Thus, the UF decoder and the MWPM decoder have the same logical error rate no matter whether there is an attached cluster.

% By satisfying both conditions of \autoref{theorem:criteria}, the weighted UF decoder is equally accurate as the MWPM decoder under infinite bias and perfect stabilizer measurements, even in non-i.i.d. error models.

% \subsubsection{Less Accurate: Circuit-Level Noise}
% \label{sssec:ana_less_accurate}

\vspace{+1ex} We note the two conditions are not true with the circuit-level noise model.
Although some of the edges can be removed under infinitely biased noise, the model graph remains 2D connectivity along the time axis and space axis of the dominant error.
Thus, it has similar sub-optimality as the CSS surface code, and the UF decoder is no longer optimal under the circuit-level noise for the XZZX surface code, even under infinite noise bias.





















\begin{comment}

Lemma 1. In the 1D graph, a unique minimum-weight perfect matching exists for each coset which only matches neighbor syndrome.

Proof:
if two non-neighbor syndromes match together, shown as the dark green lines in \figref{fig:non_neighbor_matching_reduce_to_neighbor_ones}, then the syndrome in the middle must also match to another syndrome which has an overlapping matching path with this non-neighbor matching.
In this case we can reduce the total weight of these two matchings without changing the coset by matching the left two together and right two together shown as light orange lines.
This also applies to boundary matchings, where the parity of matchings does not change for the \yue{defined: virtual boundary node}, which implies the coset does not change (coset change must include a logical error which is an error chain connecting the two boundaries and changes the parity on both virtual boundary nodes).
Thus, since the coset determines whether the left boundary is matching to some syndrome, the minimum-weight perfect matching in this coset is unique.

\begin{figure}
	\centering
	\includegraphics[width=0.80\linewidth]{figures/draw1/optimal_matching_1D.pdf}
	\caption{Non-neighbor Matching not Exists in MWPM.}
	\label{fig:non_neighbor_matching_reduce_to_neighbor_ones}
\end{figure}

Lemma 2. If the code distance $d$ is an odd number, then a unique minimum-weight perfect matching exists which determines the coset of the decoding result.

Proof:
According to Lemma 1, the unique minimum-weight perfect matching exists for each coset by connecting neighbor syndromes. These two matchings are complementary, which means adding their matching path together like \figref{fig:complementary_MWPM_each_coset} leads to an error chain with $d$ errors connecting the left and right boundary with $d$. Assume one 

\begin{figure}
	\centering
	\includegraphics[width=0.80\linewidth]{figures/draw1/complementary_MWPM_each_coset.pdf}
	\caption{MWPM of each Coset is Complementary.}
	\label{fig:complementary_MWPM_each_coset}
\end{figure}

, one has a connection to the left boundary, and the other doesn't have a connection to the left boundary.
In UF decoder, only odd clusters are growing. Let's prove two lemma to assist the proof.

Lemma 1. An odd cluster must match to either left side or right side with the same weight.
Lemma 2. An even cluster can match internally or match to both side with the same weight.

Proof:
It is obvious that an odd cluster can only match to left or right side, in order to leave even number of syndrome matched internally.
Similarly, even cluster has even number of syndromes and thus can match internally, or it can match one syndrome to left and one syndrome to right so that the remaining syndromes are still even number and can match internally.

UF decoder starts with all the syndrome as odd clusters, each odd cluster only has 1 syndrome. When the cluster grows, it always grows left and right side with equal weight. Thus, the odd cluster with only 1 syndrome matches to either left or right with same weight. When some clusters merges


When one odd cluster grows its exploratory region by one, 

\yue{todo: }

\end{comment}