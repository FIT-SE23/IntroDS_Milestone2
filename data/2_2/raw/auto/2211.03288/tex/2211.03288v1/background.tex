\section{Background}
\label{sec:background}

\subsection{Surface code}
\label{sec:background_surface}

A surface code is a lattice of interleaved ancilla and data qubits arranged on a surface in which each ancilla qubit entangles with neighboring data qubits.
In this work, we focus on surface codes with open boundaries. That is, the surface is a bounded plane.
Measuring an ancilla qubit is equivalent of performing a \emph{stabilizer} operation on its entangled data qubits. 
We assume the stabilizer measurements are noiseless for simplicity, and will generalize to noisy stabilizer measurements in \S\ref{ssec:generalize3d}.
\autoref{fig:surfacecode} shows an instance of the popular CSS surface code.
The stabilizer is either $\otimes^4 X$ (X-type ancilla) or $\otimes^4 Z$ (Z-type ancilla) on adjacent data qubits as shown in \autoref{fig:CSS_Z_circuit} and \autoref{fig:CSS_X_circuit}, respectively.
An X (or Z) error in a data qubit will flip the measurement outcomes between +1 and \textminus 1 of its Z-type (or X-type) ancillas.

%%%% Encoding
A qubit, logical or physical, can be represented by a vector in a 2-dimensional Hilbert space. 
The array of $N$ data qubits is therefore represented by a vector in a $2^{N}$-dimensional Hilbert space.
An error-correction code identifies a subspace of this huge space, called \emph{code space}.
Each state in the code space corresponds to a state in the 2-dimensional Hilbert space, i.e., a \emph{logical} state. That is, a code space state encodes a \emph{logical} qubit. 
In an error-free world, as the array functions as a logical qubit, it will remain in the code space. 
An error in a data qubit will bring the array outside the code space. 

%%%% Syndromes
%will change from the trivial value (+1) to the nontrivial value (-1).
Because direct measurement is destructive, QEC relies on the measurement outcomes of ancilla qubits, i.e., the \emph{syndrome}, to detect errors and then correct them, to bring the array back the code space, hopefully to the same \emph{logical} state. If the array ends up in a different logical state, a logical error happens. 

Both an error pattern, denoted by $\mathcal{E}$, and a correction, $C$, can be considered as an operator $\hat{\mathcal{E}}$ and $\hat{\mathcal{C}}$ that changes the states of the corresponding data qubits.
Any error pattern or multi-qubit operator can be written as a linear combination of Pauli errors (operators).
Hence, we only look at decoding a tensor product of identity operators $\hat{I}$ or Pauli operators ($\hat{X}$, $\hat{Y}$, and $\hat{Z}$), which directly leads to $\hat{\mathcal{E}} \hat{\mathcal{E}} = \hat{I}$.
That is, $C=\mathcal{E}$ corrects the error pattern $\mathcal{E}$.
However, there are usually more than one correction $C$ that could avoid the logical state change under $\mathcal{E}$. We denote the set of such corrections as $\mathbf{C}_\mathcal{E}$.

Error correction is challenging because different error patterns may have the same syndrome. Two classes of error patterns have no syndrome at all, which means they are not detectable and can be considered as the \emph{logical operators} of the surface code.
In the first class, errors of the same type (X or Z) form a closed circle. 
Such a pattern (and its corresponding operator) does not affect the logical state of the surface code.
That is, it is a trivial logical operator, i.e., identity.
Apparently, any $C\in \mathbf{C}_{\mathcal{E}}$, $\hat{C} \hat{\mathcal{E}}$ must be a trivial logical operator. 
In the second class, errors of the same type (X or Z) form a continuous chain connecting the respective boundaries, as shown \autoref{fig:X_logical_error}.
Such a pattern (and its corresponding operator) changes the logical state of the surface code.
That is, it is a nontrivial logical operator (X or Z) of the surface code.
We note these classes exist for general surface codes but involve more nuanced topology of the surface and error patterns~\cite{bombin2013introduction}.

\begin{figure*}[ht]
    \renewcommand*\thesubfigure{(\alph{subfigure})}  % add parentheses manually
    \centering
    \begin{subfigure}{.3\linewidth}
        \centering
        \includegraphics[width=0.7\linewidth]{figures/surface_codes/basic_CSS.pdf}
        \caption{}
        \label{fig:basic_CSS}
    \end{subfigure}
    \begin{subfigure}{.3\linewidth}
        \centering
        \includegraphics[width=0.7\linewidth]{figures/surface_codes/CSS_Z_circuit.pdf}
        \caption{}
        \label{fig:CSS_Z_circuit}
    \end{subfigure}
    \begin{subfigure}{.3\linewidth}
        \centering
        \includegraphics[width=0.7\linewidth]{figures/surface_codes/CSS_X_circuit.pdf}
        \caption{}
        \label{fig:CSS_X_circuit}
    \end{subfigure}
    \caption{(a) : distance-3 CSS surface code. The data qubits are shown in white circles and the Z-type and X-type ancillas are shown in black circles. (b) and (c) : Measurement circuit of Z-type and X-type ancillas. Excluding the ancillas in the border, each Z-type and X-type ancilla interacts with 4 adjacent data qubits. Z-type and X-type ancillas have different gate orders to prevent certain type of hook error~\cite{yoder2017surface, tomita2014low}.}
    \label{fig:surfacecode}
\end{figure*}

\begin{figure*}[!ht]
    \renewcommand*\thesubfigure{(\alph{subfigure})}  % add parentheses manually
    \centering
    \begin{subfigure}{.16\linewidth}
        \centering
        \includegraphics[width=1\linewidth]{figures/surface_codes/single_X_error.pdf}
        \caption{}
        \label{fig:single_X_error}
    \end{subfigure}
    \begin{subfigure}{.16\linewidth}
        \centering
        \includegraphics[width=1\linewidth]{figures/surface_codes/single_Z_error.pdf}
        \caption{}
        \label{fig:single_Z_error}
    \end{subfigure}
    \begin{subfigure}{.16\linewidth}
        \centering
        \includegraphics[width=1\linewidth]{figures/surface_codes/single_Y_error.pdf}
        \caption{}
        \label{fig:single_Y_error}
    \end{subfigure}
    \begin{subfigure}{.16\linewidth}
        \centering
        \includegraphics[width=1\linewidth]{figures/surface_codes/single_X_boundary_error.pdf}
        \caption{}
        \label{fig:single_X_boundary_error}
    \end{subfigure}
    \begin{subfigure}{.16\linewidth}
        \centering
        \includegraphics[width=1\linewidth]{figures/surface_codes/X_chained_error.pdf}
        \caption{}
        \label{fig:X_chained_error}
    \end{subfigure}
    \begin{subfigure}{.16\linewidth}
        \centering
        \includegraphics[width=1\linewidth]{figures/surface_codes/X_logical_error.pdf}
        \caption{}
        \label{fig:X_logical_error}
    \end{subfigure}
    \caption{Visualization of multiple error patterns on d = 3 surface code. The physical qubit errors are marked by X and Z. Ancillas reporting nontrivial measurements are shown in red. The red lines are to visualize error chains. (a) isolated X error (b) isolated Z error (c) isolated Y error (d) X error generating single nontrivial measurement (e) error chain of three X errors (f) error chain introducing a logical error. Note that even though (a) and (e) are different error patterns, they produce the same syndrome.}
    \label{fig:error-patterns}
\end{figure*}


\subsection{Decoding and its challenges} 
Generally speaking, a decoder starts with the syndrome, denoted by $S$, and the error model, denoted by the probability distribution of error patterns $P(\mathcal{E})$, and computes a correction, denoted by $C$, which is an operator on the surface code.
The error model $P(\mathcal{E})$ is determined by the code and the hardware; it can be acquired offline. In contrast, the syndrome $S$ is measured at runtime.

Given the syndrome $S$, we can compute the probability of not having a logical error if correction $C$ is applied as
\begin{equation}
P(C,S)= \sum\limits_{\mathcal{E}| C\in{\mathbf{C}_\mathcal{E}}} P(\mathcal{E}|S)
\label{eq:probability}
\end{equation}
Both $P(\mathcal{E}|S)$ and $\mathbf{C}_\mathcal{E}$ can be computed offline.

Then we can compute the best correction $C(S)$, in terms of lowest probability of logical error as

\begin{equation}
    \begin{aligned}
C(S)=\arg \max\limits_C P(C,S)\\=\arg \max\limits_C \sum\limits_{\mathcal{E}| C\in{\mathbf{C}_\mathcal{E}}} P(\mathcal{E}|S)
\label{eq:coset}
\end{aligned}
\end{equation}

Note that the optimal correction $C(S)$ is generally not unique, and we denote the set of the best corrections for $S$ with $\mathbf{C}(S)$.

\textbf{Challenges}~~The above process, however, faces scaling challenges in both storage and computation. 
(\textit{i}) First, there are about $4^{2d^2}$ different error patterns given about $2d^2$ data qubits each can have no error (identity $I$) or a Pauli $X$, $Z$ or $Y$ error.
As a result, a complete error model $P(\mathcal{E})$ requires $4^{2d^2}$ entries.
(\textit{ii}) Second, given $S$ and $P(\mathcal{E})$, the computational complexity for $\mathbf{C}(S)$ is $O(d^2 (4^{2d^2})^2)$ using \autoref{eq:coset}.

\textbf{Lookup table decoder} tackles Challenge (\textit{ii}) above by pre-computing an optimal $C(S)$ for every possible syndrome $S$ offline, storing them in a table, and looking it up at runtime, with constant decoding time.
It does not address Challenge (\textit{i}), which makes the offline computation non-scalable. 
Moreover, the table has one entry per syndrome and there are about $2^{2d^2}$ possible syndromes.
Even for $d=5$, the table will have over a quadrillion ($10^{15}$) entries.
